@node Sequences
@chapter Sequences
@menu
* Sequence Concepts::
* Rules about Test Functions::
* Sequences Dictionary::
@end menu

@node Sequence Concepts
@section Sequence Concepts

A @newterm{sequence} is an ordered collection of @term{elements},
implemented as either a @term{vector} or a @term{list}.

@term{Sequences} can be created by @thefunction{make-sequence},
as well as other @term{functions} that create @term{objects}
of @term{types} that are @term{subtypes} of @symbolref{sequence, SYM}
(@eg{} @code{list}, @symbolref{make-list, SYM}, @symbolref{mapcar, SYM}, and @code{vector}).

A @newterm{sequence function} is a @term{function}
defined by this specification
or added as an extension by the @term{implementation}
that operates on one or more @term{sequences}.
Whenever a @term{sequence function} must construct and return
a new @term{vector}, it always returns a @term{simple vector}.
Similarly, any @term{strings} constructed will be @term{simple strings}.



@float Figure,SequenceFunctions
@cartouche
@multitable{delete-duplicates}{nsubstitute-if-not}{remove-duplicates}

@item concatenate @tab length @tab remove
@item copy-seq @tab map @tab remove-duplicates
@item count @tab map-into @tab remove-if
@item count-if @tab merge @tab remove-if-not
@item count-if-not @tab mismatch @tab replace
@item delete @tab notany @tab reverse
@item delete-duplicates @tab notevery @tab search
@item delete-if @tab nreverse @tab some
@item delete-if-not @tab nsubstitute @tab sort
@item elt @tab nsubstitute-if @tab stable-sort
@item every @tab nsubstitute-if-not @tab subseq
@item fill @tab position @tab substitute
@item find @tab position-if @tab substitute-if
@item find-if @tab position-if-not @tab substitute-if-not
@item find-if-not @tab reduce @tab
@end multitable
@end cartouche
@caption{Standardized Sequence Functions}
@end float


@menu
* General Restrictions on Parameters that must be Sequences::
@end menu
@node General Restrictions on Parameters that must be Sequences
@subsection General Restrictions on Parameters that must be Sequences

In general, @term{lists} (including @term{association lists} and @term{property lists})
that are treated as @term{sequences} must be @term{proper lists}.



@node Rules about Test Functions
@section Rules about Test Functions

@menu
* Satisfying a Two-Argument Test::
* Satisfying a One-Argument Test::
@end menu
@node Satisfying a Two-Argument Test
@subsection Satisfying a Two-Argument Test

When an @term{object} @mat{O} is being considered iteratively
against each @term{element} @mat{E@subs1{i}}
of a @term{sequence} @mat{S}
by an @term{operator} @mat{F} listed in @thenextfigure{},
it is sometimes useful to control the way in which the presence of @mat{O}
is tested in @mat{S} is tested by @mat{F}.
This control is offered on the basis of a @term{function} designated with
either a @kwd{test} or @kwd{test-not} @term{argument}.


@float Figure,fig17.2
@cartouche
@multitable{nset-difference}{nset-exclusive-or}{set-exclusive-or}

@item adjoin @tab nset-exclusive-or @tab search
@item assoc @tab nsublis @tab set-difference
@item count @tab nsubst @tab set-exclusive-or
@item delete @tab nsubstitute @tab sublis
@item find @tab nunion @tab subsetp
@item intersection @tab position @tab subst
@item member @tab pushnew @tab substitute
@item mismatch @tab rassoc @tab tree-equal
@item nintersection @tab remove @tab union
@item nset-difference @tab remove-duplicates @tab
@end multitable
@end cartouche
@caption{Operators that have Two-Argument Tests to be Satisfied}
@end float


The object @mat{O} might not be compared directly to @mat{E@subs1{i}}.
If a @kwd{key} @term{argument} is provided,
it is a @term{designator} for a @term{function} of one @term{argument}
to be called with each @mat{E@subs1{i}} as an @term{argument},
and @term{yielding} an @term{object} @mat{Z@subs1{i}} to be used for comparison.
(If there is no @kwd{key} @term{argument}, @mat{Z@subs1{i}} is @mat{E@subs1{i}}.)

The @term{function} designated by @thekeyarg{key} is never called on @mat{O} itself.
However, if the function operates on multiple sequences
(@eg{} as happens in @symbolref{set-difference, SYM}), @mat{O}
will be the result of calling the @kwd{key} function on an
@term{element} of the other sequence.

A @kwd{test} @term{argument}, if supplied to @mat{F},
is a @term{designator} for a  @term{function}
of two @term{arguments}, @mat{O} and @mat{Z@subs1{i}}.
An @mat{E@subs1{i}} is said (or, sometimes, an @mat{O} and an @mat{E@subs1{i}} are said)
to @newterm{satisfy the test}
if this @kwd{test} @term{function} returns a @term{generalized boolean} representing
@term{true}.

A @kwd{test-not} @term{argument}, if supplied to @mat{F},
is @term{designator} for a @term{function}
of two @term{arguments}, @mat{O} and @mat{Z@subs1{i}}.
An @mat{E@subs1{i}} is said (or, sometimes, an @mat{O} and an @mat{E@subs1{i}} are said)
to @newterm{satisfy the test}
if this @kwd{test-not} @term{function}
returns a @term{generalized boolean} representing @term{false}.

If neither a @kwd{test} nor a @kwd{test-not} @term{argument} is supplied,
it is as if a @kwd{test} argument of @f{#'eql} was supplied.

The consequences are unspecified if both a @kwd{test} and a @kwd{test-not} @term{argument}
are supplied in the same @term{call} to @mat{F}.

@node Examples of Satisfying a Two-Argument Test
@subsubsection Examples of Satisfying a Two-Argument Test

@lisp
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equal)
@EV{} (foo bar "BAR" "foo" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equalp)
@EV{} (foo bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string-equal)
@EV{} (bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string=)
@EV{} (BAR "BAR" "foo" "bar")

 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'eql)
@EV{} (1)
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'=)
@EV{} (1 1.0 #C(1.0 0.0))
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #'=))
@EV{} (1 1.0 #C(1.0 0.0))

 (count 1 '((one 1) (uno 1) (two 2) (dos 2)) :key #'cadr) @EV{} 2

 (count 2.0 '(1 2 3) :test #'eql :key #'float) @EV{} 1

 (count "FOO" (list (make-pathname :name "FOO" :type "X")
                    (make-pathname :name "FOO" :type "Y"))
        :key #'pathname-name
        :test #'equal)
@EV{} 2
@end lisp




@node Satisfying a One-Argument Test
@subsection Satisfying a One-Argument Test

When using one of the @term{functions} in @thenextfigure{},
the elements @mat{E} of a @term{sequence} @mat{S} are filtered
not on the basis of the presence or absence of an object @mat{O}
under a two @term{argument} @term{predicate},
as with the @term{functions} described in @ref{Satisfying a Two-Argument Test},
but rather on the basis of a one @term{argument} @term{predicate}.


@float Figure,fig17.3
@cartouche
@multitable{delete-if-not}{nsubstitute-if-not}{substitute-if-not}

@item assoc-if @tab member-if @tab rassoc-if
@item assoc-if-not @tab member-if-not @tab rassoc-if-not
@item count-if @tab nsubst-if @tab remove-if
@item count-if-not @tab nsubst-if-not @tab remove-if-not
@item delete-if @tab nsubstitute-if @tab subst-if
@item delete-if-not @tab nsubstitute-if-not @tab subst-if-not
@item find-if @tab position-if @tab substitute-if
@item find-if-not @tab position-if-not @tab substitute-if-not
@end multitable
@end cartouche
@caption{Operators that have One-Argument Tests to be Satisfied}
@end float


The element @mat{E@subs1{i}} might not be considered directly.
If a @kwd{key} @term{argument} is provided,
it is a @term{designator} for a @term{function} of one @term{argument}
to be called with each @mat{E@subs1{i}} as an @term{argument},
and @term{yielding} an @term{object} @mat{Z@subs1{i}} to be used for comparison.
(If there is no @kwd{key} @term{argument}, @mat{Z@subs1{i}} is @mat{E@subs1{i}}.)

@term{Functions} defined in this specification and having a name that
ends in ``@f{-if}'' accept a first @term{argument} that is a @term{designator} for a
@term{function} of one @term{argument}, @mat{Z@subs1{i}}.
An @mat{E@subs1{i}} is said to @newterm{satisfy the test} if this @kwd{test} @term{function}
returns a @term{generalized boolean} representing @term{true}.

@term{Functions} defined in this specification and having a name that
ends in ``@f{-if-not}'' accept a first @term{argument} that is a @term{designator} for a
@term{function} of one @term{argument}, @mat{Z@subs1{i}}.
An @mat{E@subs1{i}} is said to @newterm{satisfy the test} if this @kwd{test} @term{function}
returns a @term{generalized boolean} representing @term{false}.

@node Examples of Satisfying a One-Argument Test
@subsubsection Examples of Satisfying a One-Argument Test

@lisp
 (count-if #'zerop '(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) @EV{} 4

 (remove-if-not #'symbolp '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
@EV{} (A B C D E F)
 (remove-if (complement #'symbolp) '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
@EV{} (A B C D E F)

 (count-if #'zerop '("foo" "" "bar" "" "" "baz" "quux") :key #'length)
@EV{} 3
@end lisp

@node Sequences Dictionary
@section Sequences Dictionary


@menu
* sequence::
* copy-seq::
* elt::
* fill::
* make-sequence::
* subseq::
* map::
* map-into::
* reduce::
* count; count-if; count-if-not::
* length::
* reverse; nreverse::
* sort; stable-sort::
* find; find-if; find-if-not::
* position; position-if; position-if-not::
* search::
* mismatch::
* replace::
* substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+::
* concatenate::
* merge::
* remove; remove-if; remove-if-not; delete; delete-if; delete-if-not::
* remove-duplicates; delete-duplicates::
@end menu

@node sequence
@syindexanchor{sequence, SYM}
@subsection sequence (System Class)
@cindex sequence


@subsubheading Class Precedence List:
@symbolref{sequence, SYM},
@symbolref{t, SC}

@subsubheading Description:

@term{Sequences} are ordered collections of @term{objects},
called the @term{elements} of the @term{sequence}.

@Thetypes{vector} and @thetype{list} are @term{disjoint} @subtypesof{sequence},
but are not necessarily an @term{exhaustive partition} of @term{sequence}.

When viewing a @term{vector} as a @term{sequence},
only the @term{active} @term{elements} of that @term{vector}
are considered @term{elements} of the @term{sequence};
that is,
@term{sequence} operations respect the @term{fill pointer}
when given @term{sequences} represented as @term{vectors}.


@node copy-seq
@syindexanchor{copy-seq, SYM}
@subsection copy-seq (Function)
@cindex copy-seq


@subsubheading Syntax:

@DefunWithValues{copy-seq, sequence, copied-sequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{copied-sequence}---a @term{proper sequence}.

@subsubheading Description:

Creates a copy of @param{sequence}.  The @term{elements} of the new
@term{sequence} are the @term{same} as the corresponding @term{elements} of
the given @param{sequence}.

If @param{sequence} is a @term{vector},
the result is a @term{fresh} @term{simple array}
of @term{rank} one
that has the same @term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list},
the result is a @term{fresh} @term{list}.

@subsubheading Examples:
@lisp
 (setq str "a string") @EV{} "a string"
 (equalp str (copy-seq str)) @EV{} @term{true}
 (eql str (copy-seq str)) @EV{} @term{false}
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{copy-list}

@subsubheading Notes:

From a functional standpoint,
@lisp
 (copy-seq x) @EQ{} (subseq x 0)
@end lisp

However, the programmer intent is typically very different in these two cases.


@node elt
@syindexanchor{elt, SYM}
@subsection elt (Accessor)
@cindex elt


@subsubheading Syntax:

@DefunWithValues{elt, sequence index, object}
@Defsetf{elt, sequence index, new-object}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{index}---a @term{valid sequence index} for @param{sequence}.

@param{object}---an @term{object}.

@param{new-object}---an @term{object}.

@subsubheading Description:

@term{Accesses} the @term{element} of @param{sequence} specified by @param{index}.

@subsubheading Examples:

@lisp
 (setq str (copy-seq "0123456789")) @EV{} "0123456789"
 (elt str 6) @EV{} #@bsl{}6
 (setf (elt str 0) #@bsl{}#) @EV{} #@bsl{}#
 str @EV{} "#123456789"
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}
@Shouldchecktype{index, a @term{valid sequence index} for @param{sequence}}

@subsubheading See Also:

@ref{aref},
@ref{nth},
@ref{Compiler Terminology}

@subsubheading Notes:

@symbolref{aref, SYM} may be used to @term{access} @term{vector}
elements that are beyond the @term{vector}'s @term{fill pointer}.


@node fill
@syindexanchor{fill, SYM}
@subsection fill (Function)
@cindex fill


@subsubheading Syntax:

@DefunWithValues{fill, sequence item @keyparam{} start end, sequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{item}---a @term{sequence}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@subsubheading Description:

Replaces the @term{elements} of @param{sequence}
@term{bounded} by @param{start} and @param{end}
with @param{item}.

@subsubheading Examples:

@lisp
 (fill (list 0 1 2 3 4 5) '(444)) @EV{} ((444) (444) (444) (444) (444) (444))
 (fill (copy-seq "01234") #@bsl{}e :start 3) @EV{} "012ee"
 (setq x (vector 'a 'b 'c 'd 'e)) @EV{} #(A B C D E)
 (fill x 'z :start 1 :end 3) @EV{} #(A Z Z D E)
 x @EV{} #(A Z Z D E)
 (fill x 'p) @EV{} #(P P P P P)
 x @EV{} #(P P P P P)
@end lisp


@subsubheading Side Effects:

@param{Sequence} is destructively modified.

@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}
@Shouldchecktype{start, a non-negative @term{integer}}
@Shouldchecktype{end, a non-negative @term{integer} or @nil{}}

@subsubheading See Also:

@ref{replace}, @ref{nsubstitute}

@subsubheading Notes:

@tt{ (fill @param{sequence} @param{item}) @EQ{}
(nsubstitute-if @param{item} (constantly t) @param{sequence})}


@node make-sequence
@syindexanchor{make-sequence, SYM}
@subsection make-sequence (Function)
@cindex make-sequence


@subsubheading Syntax:

@DefunWithValues{make-sequence, result-type size @keyparam{} initial-element, sequence}

@subsubheading Arguments and Values:

@param{result-type}---a @symbolref{sequence, SYM} @term{type specifier}.

@param{size}---a non-negative @term{integer}.

@param{initial-element}---an @term{object}.
@Default{@term{implementation-dependent}}

@param{sequence}---a @term{proper sequence}.

@subsubheading Description:

Returns a @term{sequence} of the type @param{result-type} and of length @param{size},
each of the @term{elements} of which has been initialized to @param{initial-element}.

If the @param{result-type} is a @term{subtype} of @code{list},
the result will be a @term{list}.

If the @param{result-type} is a @term{subtype} of @code{vector},
then if the implementation can determine the element type specified
for the @param{result-type}, the element type of the resulting array
is the result of @term{upgrading} that element type; or, if the
implementation can determine that the element type is unspecified (or @f{*}),
the element type of the resulting array is @symbolref{t, SC};
otherwise, an error is signaled.

@subsubheading Examples:

@lisp
 (make-sequence 'list 0) @EV{} ()
 (make-sequence 'string 26 :initial-element #@bsl{}.)
@EV{} ".........................."
 (make-sequence '(vector double-float) 2
                :initial-element 1d0)
@EV{} #(1.0d0 1.0d0)
@end lisp


@lisp
 (make-sequence '(vector * 2) 3) should signal an error
 (make-sequence '(vector * 4) 3) should signal an error
@end lisp


@subsubheading Affected By:

The @term{implementation}.

@subsubheading Exceptional Situations:

The consequences are unspecified if @param{initial-element}
is not an @term{object} which can be stored in the resulting @term{sequence}.

An error @oftype{type-error} must be signaled if the @param{result-type} is neither
a @term{recognizable subtype} of @code{list},
nor a @term{recognizable subtype} of @code{vector}.

An error @oftype{type-error} should be signaled if @param{result-type} specifies
the number of elements and @param{size} is different from that number.

@subsubheading See Also:

@ref{make-array}, @ref{make-list}

@subsubheading Notes:
@lisp
 (make-sequence 'string 5) @EQ{} (make-string 5)
@end lisp


@node subseq
@syindexanchor{subseq, SYM}
@subsection subseq (Accessor)
@cindex subseq


@subsubheading Syntax:

@DefunWithValues{subseq, sequence start @opt{} end, subsequence}
@Defsetf{subseq, sequence start @opt{} end, new-subsequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@DefaultFor{@param{end}, @nil{}}

@param{subsequence}---a @term{proper sequence}.

@param{new-subsequence}---a @term{proper sequence}.

@subsubheading Description:

@symbolref{subseq, SYM} creates a @term{sequence}
that is a copy of the subsequence of @param{sequence}
@param{bounded} by @param{start} and @param{end}.

@param{Start} specifies an offset into the original @param{sequence} and
marks the beginning position of the subsequence.
@param{end} marks the position following the last element of the subsequence.

@symbolref{subseq, SYM} always allocates a new @term{sequence} for a result;
it never shares storage with an old @term{sequence}.
The result subsequence is always of the same @term{type} as @param{sequence}.

If @param{sequence} is a @term{vector},
the result is a @term{fresh} @term{simple array}
of @term{rank} one
that has the same @term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list},
the result is a @term{fresh} @term{list}.

@symbolref{setf, SYM} may be used with @symbolref{subseq, SYM} to destructively replace
@term{elements} of a subsequence with @term{elements}
taken from a @term{sequence} of new values.
If the subsequence and the new sequence are not of equal length,
the shorter length determines the number of elements that are
replaced.  The remaining @term{elements} at the end of the longer sequence
are not modified in the operation.

@subsubheading Examples:

@lisp
 (setq str "012345") @EV{} "012345"
 (subseq str 2) @EV{} "2345"
 (subseq str 3 5) @EV{} "34"
 (setf (subseq str 4) "abc") @EV{} "abc"
 str @EV{} "0123ab"
 (setf (subseq str 0 2) "A") @EV{} "A"
 str @EV{} "A123ab"
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}
@Lazychecktype{new-subsequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{replace}


@node map
@syindexanchor{map, SYM}
@subsection map (Function)
@cindex map


@subsubheading Syntax:

@DefunWithValues{map, result-type function @rest{} @plus{sequences}, result}

@subsubheading Arguments and Values:

@param{result-type}---a @symbolref{sequence, SYM} @term{type specifier}, or @nil{}.

@param{function}---a @term{function designator}.
@param{function} must take as many arguments as
there are @param{sequences}.

@param{sequence}---a @term{proper sequence}.

@param{result}---if @param{result-type} is a @term{type specifier} other than @nil{},
then a @term{sequence} of the @term{type} it denotes;
otherwise (if the @param{result-type} is @nil{}), @nil{}.

@subsubheading Description:

Applies @param{function} to successive sets of arguments in which
one argument is obtained from each @term{sequence}.
The @param{function} is called first on all the elements with index @f{0},
then on all those with index @f{1}, and so on.
The @param{result-type} specifies the @term{type} of the resulting @term{sequence}.

@symbolref{map, SYM} returns @nil{}@spc{}if @param{result-type} is @nil{}.
Otherwise, @symbolref{map, SYM} returns
a @term{sequence} such that element @f{j} is the result
of applying @param{function} to element @f{j} of each of the
@param{sequences}.  The result @term{sequence}
is as long as the shortest of the
@param{sequences}.
The consequences are undefined if the result of applying @param{function}
to the successive elements of the @param{sequences} cannot
be contained in a @term{sequence} of the @term{type} given by @param{result-type}.

If the @param{result-type} is a @term{subtype} of @code{list},
the result will be a @term{list}.

If the @param{result-type} is a @term{subtype} of @code{vector},
then if the implementation can determine the element type specified
for the @param{result-type}, the element type of the resulting array
is the result of @term{upgrading} that element type; or, if the
implementation can determine that the element type is unspecified (or @f{*}),
the element type of the resulting array is @symbolref{t, SC};
otherwise, an error is signaled.

@subsubheading Examples:

@lisp
 (map 'string #'(lambda (x y)
                  (char "01234567890ABCDEF" (mod (+ x y) 16)))
       '(1 2 3 4)
       '(10 9 8 7)) @EV{} "AAAA"
 (setq seq '("lower" "UPPER" "" "123")) @EV{} ("lower" "UPPER" "" "123")
 (map nil #'nstring-upcase seq) @EV{} NIL
 seq @EV{} ("LOWER" "UPPER" "" "123")
 (map 'list #'- '(1 2 3 4)) @EV{} (-1 -2 -3 -4)
 (map 'string
      #'(lambda (x) (if (oddp x) #@bsl{}1 #@bsl{}0))
      '(1 2 3 4)) @EV{} "1010"
@end lisp


@lisp
 (map '(vector * 4) #'cons "abc" "de") should signal an error
@end lisp


@subsubheading Exceptional Situations:

An error @oftype{type-error} must be signaled if the @param{result-type} is
not a @term{recognizable subtype} of @code{list},
not a @term{recognizable subtype} of @code{vector},
and not @nil{}.

@Lazycheckanytype{sequence, a @term{proper sequence}}

An error @oftype{type-error} should be signaled
if @param{result-type} specifies the
number of elements and the minimum length of the @param{sequences}
is different from that number.

@subsubheading See Also:

@ref{Traversal Rules and Side Effects}


@node map-into
@syindexanchor{map-into, SYM}
@subsection map-into (Function)
@cindex map-into



@subsubheading Syntax:

@DefunWithValues{map-into, result-sequence function @rest{} sequences, result-sequence}

@subsubheading Arguments and Values:

@param{result-sequence}---a @term{proper sequence}.

@param{function}---a @term{designator} for a @term{function}
of as many @term{arguments} as there are @param{sequences}.

@param{sequence}---a @term{proper sequence}.

@subsubheading Description:

Destructively modifies @param{result-sequence} to contain the results of
applying @param{function} to each element in the argument @param{sequences}
in turn.

@param{result-sequence} and each element of @param{sequences} can each be
either a @term{list} or a @term{vector}.
If @param{result-sequence} and each element of @param{sequences} are not all
the same length, the iteration terminates when the shortest @term{sequence}
(of any of the @param{sequences} or the @param{result-sequence})
is exhausted.
If @param{result-sequence} is a @term{vector} with a
@term{fill pointer}, the @term{fill pointer} is ignored when deciding how
many iterations to perform, and afterwards the @term{fill pointer} is set to
the number of times @param{function} was applied.
If @param{result-sequence} is longer than the shortest element of @param{sequences},
extra elements at the end of @param{result-sequence} are left unchanged.
If @param{result-sequence} is @nil{}, @symbolref{map-into, SYM} immediately returns
@nil{}, since @nil{}@spc{}is a @term{sequence} of length zero.

If @param{function} has side effects, it can count on being called
first on all of the elements with index 0, then on all of those
numbered 1, and so on.

@subsubheading Examples:

@lisp
 (setq a (list 1 2 3 4) b (list 10 10 10 10)) @EV{} (10 10 10 10)
 (map-into a #'+ a b) @EV{} (11 12 13 14)
 a @EV{} (11 12 13 14)
 b @EV{} (10 10 10 10)
 (setq k '(one two three)) @EV{} (ONE TWO THREE)
 (map-into a #'cons k a) @EV{} ((ONE . 11) (TWO . 12) (THREE . 13) 14)
 (map-into a #'gensym) @EV{} (#:G9090 #:G9091 #:G9092 #:G9093)
 a @EV{} (#:G9090 #:G9091 #:G9092 #:G9093)
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{result-sequence, a @term{proper sequence}}
@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading Notes:

@symbolref{map-into, SYM} differs from @symbolref{map, SYM} in that it modifies an
existing @term{sequence} rather than creating a new one.
In addition, @symbolref{map-into, SYM} can be called with only two
arguments, while @symbolref{map, SYM} requires at least three arguments.

@symbolref{map-into, SYM} could be defined by:

@lisp
 (defun map-into (result-sequence function &rest sequences)
   (loop for index below (apply #'min
                                (length result-sequence)
                                (mapcar #'length sequences))
         do (setf (elt result-sequence index)
                  (apply function
                         (mapcar #'(lambda (seq) (elt seq index))
                                 sequences))))
   result-sequence)
@end lisp



@node reduce
@syindexanchor{reduce, SYM}
@subsection reduce (Function)
@cindex reduce


@subsubheading Syntax:

@DefunWithValues{reduce, function sequence @keyparam{} keyparam from-end start end initial-value, result}

@subsubheading Arguments and Values:

@param{function}---a @term{designator} for a @term{function}
that might be called with either zero or two @term{arguments}.

@param{sequence}---a @term{proper sequence}.

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{initial-value}---an @term{object}.

@param{result}---an @term{object}.

@subsubheading Description:

@symbolref{reduce, SYM} uses a binary operation, @param{function},
to combine the @term{elements} of @param{sequence}
@term{bounded} by @param{start} and @param{end}.

The @param{function} must accept as @term{arguments} two @term{elements}
of @param{sequence} or the results from combining those @term{elements}.
The @param{function} must also be able to accept no arguments.

If @param{key} is supplied, it is used is used to extract the values to reduce.
The @param{key} function is applied exactly once to each element of @param{sequence}
in the order implied by the reduction order but not to the value of
@param{initial-value}, if supplied.
The @param{key} function typically returns part of the @term{element} of @param{sequence}.
If @param{key} is not supplied or is @nil{}, the @param{sequence} @term{element} itself is used.

The reduction is left-associative,
unless @param{from-end} is @term{true} in which case it is right-associative.

If @param{initial-value} is supplied,
it is logically placed before the subsequence
(or after it if @param{from-end} is @term{true})
and included in the reduction operation.

In the normal case, the result of @symbolref{reduce, SYM} is the combined
result of @param{function}'s being applied to successive pairs of @term{elements}
of @param{sequence}.
If the subsequence contains exactly one @term{element}
and no @param{initial-value} is given,
then that @term{element} is returned and @param{function} is not called.
If the subsequence is empty and an @param{initial-value} is given,
then the @param{initial-value} is returned and @param{function} is not called.
If the subsequence is empty and no @param{initial-value} is given,
then the @param{function} is called with zero arguments,
and @symbolref{reduce, SYM} returns whatever @param{function} does.
This is the only case where the
@param{function} is called with other than two arguments.

@subsubheading Examples:
@lisp
 (reduce #'* '(1 2 3 4 5)) @EV{} 120
 (reduce #'append '((1) (2)) :initial-value '(i n i t)) @EV{} (I N I T 1 2)
 (reduce #'append '((1) (2)) :from-end t
                             :initial-value '(i n i t)) @EV{} (1 2 I N I T)
 (reduce #'- '(1 2 3 4)) @EQ{} (- (- (- 1 2) 3) 4) @EV{} -8
 (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.
@EQ{} (- 1 (- 2 (- 3 4))) @EV{} -2
 (reduce #'+ '()) @EV{} 0
 (reduce #'+ '(3)) @EV{} 3
 (reduce #'+ '(foo)) @EV{} FOO
 (reduce #'list '(1 2 3 4)) @EV{} (((1 2) 3) 4)
 (reduce #'list '(1 2 3 4) :from-end t) @EV{} (1 (2 (3 4)))
 (reduce #'list '(1 2 3 4) :initial-value 'foo) @EV{} ((((foo 1) 2) 3) 4)
 (reduce #'list '(1 2 3 4)
        :from-end t :initial-value 'foo) @EV{} (1 (2 (3 (4 foo))))
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{Traversal Rules and Side Effects}


@node count; count-if; count-if-not
@syindexanchor{count, SYM}
@subsection count, count-if, count-if-not (Function)
@syindexanchor{count-if, SYM}
@cindex count
@syindexanchor{count-if-not, SYM}
@cindex count-if
@cindex count-if-not


@subsubheading Syntax:

@DefunWithValues{count, item sequence @keyparam{} from-end start end keyparam test test-not, n}
@DefunWithValues{count-if, predicate sequence @keyparam{} from-end start end keyparam, n}
@DefunWithValues{count-if-not, predicate sequence @keyparam{} from-end start end keyparam, n}

@subsubheading Arguments and Values:

@param{item}---an @term{object}.

@param{sequence}---a @term{proper sequence}.

@param{predicate}---a @term{designator} for a @term{function} of one @term{argument}
that returns a @term{generalized boolean}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{n}---a non-negative @term{integer}
less than or equal to the @term{length} of @param{sequence}.

@subsubheading Description:

@symbolref{count, SYM}, @symbolref{count-if, SYM}, and @symbolref{count-if-not, SYM}
count and return the number of @term{elements} in
the @param{sequence} @term{bounded} by @param{start} and @param{end}
that @term{satisfy the test}.

The @param{from-end} has no direct effect on the result.
However, if @param{from-end} is @term{true},
the @term{elements} of @param{sequence} will be supplied as @term{arguments} to
the @param{test},
@param{test-not},
and @param{key} in reverse order,
which may change the side-effects, if any, of those functions.

@subsubheading Examples:

@lisp
 (count #@bsl{}a "how many A's are there in here?") @EV{} 2
 (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) @EV{} 2
 (count-if #'upper-case-p "The Crying of Lot 49" :start 4) @EV{} 2
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{Rules about Test Functions},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

The @kwd{test-not} @term{argument} is deprecated.

@Thefunction{count-if-not} is deprecated.


@node length
@syindexanchor{length, SYM}
@subsection length (Function)
@cindex length


@subsubheading Syntax:

@DefunWithValues{length, sequence, n}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{n}---a non-negative @term{integer}.

@subsubheading Description:

Returns the number of @term{elements} in @param{sequence}.

If @param{sequence} is a @term{vector} with a @term{fill pointer},
the active length as specified by the @term{fill pointer} is returned.

@subsubheading Examples:

@lisp
 (length "abc") @EV{} 3
 (setq str (make-array '(3) :element-type 'character
                            :initial-contents "abc"
                            :fill-pointer t)) @EV{} "abc"
 (length str) @EV{} 3
 (setf (fill-pointer str) 2) @EV{} 2
 (length str) @EV{} 2
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{list-length},
@ref{sequence}


@node reverse; nreverse
@syindexanchor{reverse, SYM}
@subsection reverse, nreverse (Function)
@syindexanchor{nreverse, SYM}
@cindex reverse
@cindex nreverse
@anchor{reverse}
@anchor{nreverse}


@subsubheading Syntax:

@DefunWithValues{reverse, sequence, reversed-sequence}

@DefunWithValues{nreverse, sequence, reversed-sequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{reversed-sequence}---a @term{sequence}.

@subsubheading Description:

@symbolref{reverse, SYM} and @symbolref{nreverse, SYM} return a new @term{sequence}
of the same kind as @param{sequence}, containing the same @term{elements},
but in reverse order.

@symbolref{reverse, SYM} and @symbolref{nreverse, SYM} differ in that @symbolref{reverse, SYM}
always creates and returns a new @term{sequence}, whereas @symbolref{nreverse, SYM}
might modify and return the given @param{sequence}.  @symbolref{reverse, SYM} never
modifies the given @param{sequence}.

For @symbolref{reverse, SYM}, if @param{sequence} is a @term{vector},
the result is a @term{fresh} @term{simple array} of @term{rank} one
that has the same @term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list}, the result is a @term{fresh} @term{list}.

For @symbolref{nreverse, SYM}, if @param{sequence} is a @term{vector},
the result is a @term{vector}
that has the same @term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list}, the result is a @term{list}.

For @symbolref{nreverse, SYM},
@param{sequence} might be destroyed and re-used to produce the result.
The result might or might not be @term{identical} to @param{sequence}.
Specifically, when @param{sequence} is a @term{list},
@symbolref{nreverse, SYM} is permitted to @symbolref{setf, SYM} any part, @symbolref{car, SYM} or @symbolref{cdr, SYM},
of any @term{cons} that is part of the @term{list structure} of @param{sequence}.
When @param{sequence} is a @term{vector},
@symbolref{nreverse, SYM} is permitted to re-order the elements of @param{sequence}
in order to produce the resulting @term{vector}.

@subsubheading Examples:
@lisp
 (setq str "abc") @EV{} "abc"
 (reverse str) @EV{} "cba"
 str @EV{} "abc"
 (setq str (copy-seq str)) @EV{} "abc"
 (nreverse str) @EV{} "cba"
 str @EV{} @term{implementation-dependent}
 (setq l (list 1 2 3)) @EV{} (1 2 3)
 (nreverse l) @EV{} (3 2 1)
 l @EV{} @term{implementation-dependent}
@end lisp


@subsubheading Side Effects:

@symbolref{nreverse, SYM} might either create a new @term{sequence},
modify the argument @param{sequence}, or both.
(@symbolref{reverse, SYM} does not modify @param{sequence}.)

@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}


@node sort; stable-sort
@syindexanchor{sort, SYM}
@subsection sort, stable-sort (Function)
@syindexanchor{stable-sort, SYM}
@cindex sort
@cindex stable-sort
@anchor{sort}
@anchor{stable-sort}


@subsubheading Syntax:

@DefunWithValues{sort, sequence predicate @keyparam{} keyparam, sorted-sequence}
@DefunWithValues{stable-sort, sequence predicate @keyparam{} keyparam, sorted-sequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{predicate}---a @term{designator} for
a @term{function} of two arguments that returns a @term{generalized boolean}.

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{sorted-sequence}---a @term{sequence}.

@subsubheading Description:

@symbolref{sort, SYM} and @symbolref{stable-sort, SYM} destructively sort @param{sequences}
according to the order determined by the @param{predicate} function.

If @param{sequence} is a @term{vector},
the result is a @term{vector}
that has the same @term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list},
the result is a @term{list}.

@symbolref{sort, SYM} determines the relationship between two elements
by giving keys extracted from the elements to the @param{predicate}.
The first argument to the @param{predicate} function is the part of one element
of @param{sequence} extracted by the @param{key} function
(if supplied); the second
argument is the part of another element
of @param{sequence} extracted by the @param{key} function
(if supplied).
@param{Predicate} should return @term{true} if and only if the first argument is
strictly less than the second (in some appropriate sense).
If the first argument is greater than or equal to the second
(in the appropriate sense), then the @param{predicate} should return @term{false}.

The argument to the @param{key} function is the @param{sequence} element.
The return value of the @param{key} function
becomes an argument to @param{predicate}.
If @param{key} is not supplied or @nil{}, the @param{sequence} element itself is used.
There is no guarantee on the number of times the @param{key} will be called.

If the @param{key} and @param{predicate} always return,
then the sorting operation will always terminate,
producing a @term{sequence} containing the same @term{elements} as @param{sequence}
(that is, the result is a permutation of @param{sequence}).
This is guaranteed even if the @param{predicate}
does not really consistently represent a total order
(in which case the @term{elements} will be scrambled in some unpredictable way,
but no @term{element} will be lost).
If the @param{key} consistently returns meaningful keys,
and the @param{predicate} does reflect some total ordering criterion on those keys,
then the @term{elements} of the @param{sorted-sequence}
will be properly sorted according to that ordering.

The sorting operation performed by @symbolref{sort, SYM} is not guaranteed stable.
Elements considered equal by the @param{predicate} might or might not
stay in their original order.  The @param{predicate} is assumed to
consider two elements @f{x} and @f{y} to be equal if
@f{(funcall @i{predicate} @i{x} @i{y})} and
@f{(funcall @i{predicate} @i{y} @i{x})} are both @term{false}.
@symbolref{stable-sort, SYM} guarantees stability.

The sorting operation can be destructive in all cases.  In the case of a
@term{vector}
argument, this is accomplished by permuting the elements in place.
In the case of a @term{list}, the @term{list} is
destructively reordered in the same manner as for
@symbolref{nreverse, SYM}.

@subsubheading Examples:

@lisp
 (setq tester (copy-seq "lkjashd")) @EV{} "lkjashd"
 (sort tester #'char-lessp) @EV{} "adhjkls"
 (setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) @EV{} ((1 2 3) (4 5 6) (7 8 9))
 (sort tester #'> :key #'car)  @EV{} ((7 8 9) (4 5 6) (1 2 3))
 (setq tester (list 1 2 3 4 5 6 7 8 9 0)) @EV{} (1 2 3 4 5 6 7 8 9 0)
 (stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))
@EV{} (1 3 5 7 9 2 4 6 8 0)
 (sort (setq committee-data
             (vector (list (list "JonL" "White") "Iteration")
                     (list (list "Dick" "Waters") "Iteration")
                     (list (list "Dick" "Gabriel") "Objects")
                     (list (list "Kent" "Pitman") "Conditions")
                     (list (list "Gregor" "Kiczales") "Objects")
                     (list (list "David" "Moon") "Objects")
                     (list (list "Kathy" "Chapman") "Editorial")
                     (list (list "Larry" "Masinter") "Cleanup")
                     (list (list "Sandra" "Loosemore") "Compiler")))
       #'string-lessp :key #'cadar)
@EV{} #((("Kathy" "Chapman") "Editorial")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("Sandra" "Loosemore") "Compiler")
     (("Larry" "Masinter") "Cleanup")
     (("David" "Moon") "Objects")
     (("Kent" "Pitman") "Conditions")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration"))
 ;; Note that individual alphabetical order within `committees'
 ;; is preserved.
 (setq committee-data
       (stable-sort committee-data #'string-lessp :key #'cadr))
@EV{} #((("Larry" "Masinter") "Cleanup")
     (("Sandra" "Loosemore") "Compiler")
     (("Kent" "Pitman") "Conditions")
     (("Kathy" "Chapman") "Editorial")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("David" "Moon") "Objects"))
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{merge},
@ref{Compiler Terminology},
@ref{Traversal Rules and Side Effects},
@ref{Destructive Operations}

@subsubheading Notes:

If @param{sequence} is a @term{vector},
the result might or might not be simple,
and might or might not be @term{identical} to @param{sequence}.


@node find; find-if; find-if-not
@syindexanchor{find, SYM}
@subsection find, find-if, find-if-not (Function)
@syindexanchor{find-if, SYM}
@cindex find
@syindexanchor{find-if-not, SYM}
@cindex find-if
@cindex find-if-not
@anchor{find}


@subsubheading Syntax:

@DefunWithValues{find, item sequence @keyparam{} from-end test test-not start end keyparam, element}
@DefunWithValues{find-if, predicate sequence @keyparam{} from-end start end keyparam, element}
@DefunWithValues{find-if-not, predicate sequence @keyparam{} from-end start end keyparam, element}

@subsubheading Arguments and Values:

@param{item}---an @term{object}.

@param{sequence}---a @term{proper sequence}.

@param{predicate}---a @term{designator} for a @term{function} of one @term{argument}
that returns a @term{generalized boolean}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{element}---an @term{element} of the @param{sequence}, or @nil{}.

@subsubheading Description:

@symbolref{find, SYM}, @symbolref{find-if, SYM}, and @symbolref{find-if-not, SYM}
each search for an @term{element} of the @param{sequence}
@term{bounded} by @param{start} and @param{end}
that @i{satisfies the predicate} @param{predicate}
or that @i{satisfies the test} @param{test} or @param{test-not},
as appropriate.

If @param{from-end} is @term{true},
then the result is the rightmost @term{element} that @i{satisfies the test}.

If the @param{sequence} contains an @term{element} that @i{satisfies the test},
then the leftmost or rightmost @param{sequence} element,
depending on @param{from-end},
is returned;
otherwise @nil{}@spc{}is returned.

@subsubheading Examples:

@lisp
 (find #@bsl{}d "here are some letters that can be looked at" :test #'char>)
@EV{} #@bsl{}Space
 (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) @EV{} 3
 (find-if-not #'complexp
             '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
             :start 2) @EV{} NIL
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{position},
@ref{Rules about Test Functions},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

The @kwd{test-not} @term{argument} is deprecated.

@Thefunction{find-if-not} is deprecated.


@node position; position-if; position-if-not
@syindexanchor{position, SYM}
@subsection position, position-if, position-if-not (Function)
@syindexanchor{position-if, SYM}
@cindex position
@syindexanchor{position-if-not, SYM}
@cindex position-if
@cindex position-if-not
@anchor{position}


@subsubheading Syntax:

@DefunWithValues{position, item sequence @keyparam{} from-end test test-not start end keyparam, position}

@DefunWithValues{position-if, predicate sequence @keyparam{} from-end start end keyparam, position}
@DefunWithValues{position-if-not, predicate sequence @keyparam{} from-end start end keyparam, position}

@subsubheading Arguments and Values:

@param{item}---an @term{object}.

@param{sequence}---a @term{proper sequence}.

@param{predicate}---a @term{designator} for a @term{function} of one argument
that returns a @term{generalized boolean}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{position}---a @term{bounding index} of @param{sequence}, or @nil{}.

@subsubheading Description:

@symbolref{position, SYM}, @symbolref{position-if, SYM}, and @symbolref{position-if-not, SYM}
each search @param{sequence} for an @term{element} that @i{satisfies the test}.

The @param{position} returned is the index within @param{sequence}
of the leftmost  (if @param{from-end} is @term{true})
or of the rightmost (if @param{from-end} is @term{false})
@term{element} that @i{satisfies the test};
otherwise @nil{}@spc{}is returned.
The index returned is relative to the left-hand end of the entire @param{sequence},
regardless of the value of @param{start}, @param{end}, or @param{from-end}.

@subsubheading Examples:

@lisp
 (position #@bsl{}a "baobab" :from-end t) @EV{} 4
 (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) @EV{} 2
 (position 595 '()) @EV{} NIL
 (position-if-not #'integerp '(1 2 3 4 5.0)) @EV{} 4
@end lisp


@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{find},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

The @kwd{test-not} @term{argument} is deprecated.

@Thefunction{position-if-not} is deprecated.


@node search
@syindexanchor{search, SYM}
@subsection search (Function)
@cindex search


@subsubheading Syntax:

@DefunWithValuesNewline{search, sequence-1 sequence-2  @keyparam{} @vtop{@hbox{from-end test test-not} @hbox{keyparam start1 start2} @hbox{end1 end2}}, position}

@subsubheading Arguments and Values:

@param{Sequence-1}---a @term{sequence}.

@param{Sequence-2}---a @term{sequence}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{start1}, @param{end1}---@term{bounding index designators} of @param{sequence-1}.
@Defaults{@param{start1} and @param{end1}, @f{0} and @nil{}}

@param{start2}, @param{end2}---@term{bounding index designators} of @param{sequence-2}.
@Defaults{@param{start2} and @param{end2}, @f{0} and @nil{}}

@param{position}---a @term{bounding index} of @param{sequence-2},
or @nil{}.

@subsubheading Description:

Searches @param{sequence-2} for a subsequence that matches @param{sequence-1}.

The implementation may choose to search @param{sequence-2} in any order;
there is no guarantee on the number of times the test is made.
For example,
when @param{start-end} is @term{true},
the @param{sequence} might actually be searched from left to right
instead of from right to left (but in either case would return
the rightmost matching subsequence).
If the search succeeds,
@symbolref{search, SYM} returns the offset into @param{sequence-2}
of the first element of the leftmost or rightmost matching subsequence,
depending on @param{from-end};
otherwise @symbolref{search, SYM} returns @nil{}.

If @param{from-end} is @term{true}, the index of the leftmost
element of the rightmost matching subsequence is returned.

@subsubheading Examples:
@lisp
 (search "dog" "it's a dog's life") @EV{} 7
 (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) @EV{} 2
@end lisp


@subsubheading See Also:

@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

The @kwd{test-not} @term{argument} is deprecated.


@node mismatch
@syindexanchor{mismatch, SYM}
@subsection mismatch (Function)
@cindex mismatch


@subsubheading Syntax:

@DefunWithValuesNewline{mismatch, sequence-1 sequence-2  @keyparam{} from-end test test-not keyparam start1 start2 end1 end2, position}

@subsubheading Arguments and Values:

@param{Sequence-1}---a @term{sequence}.

@param{Sequence-2}---a @term{sequence}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start1}, @param{end1}---@term{bounding index designators} of @param{sequence-1}.
@Defaults{@param{start1} and @param{end1}, @f{0} and @nil{}}

@param{start2}, @param{end2}---@term{bounding index designators} of @param{sequence-2}.
@Defaults{@param{start2} and @param{end2}, @f{0} and @nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{position}---a @term{bounding index} of @param{sequence-1},
or @nil{}.

@subsubheading Description:

The specified subsequences of
@param{sequence-1} and @param{sequence-2} are compared element-wise.

The @param{key} argument is used for both the @param{sequence-1} and the @param{sequence-2}.

If @param{sequence-1} and @param{sequence-2}
are of equal length and match in every element, the result is
@term{false}.  Otherwise, the result is a non-negative @term{integer},
the index within
@param{sequence-1} of the leftmost or rightmost position, depending
on @param{from-end}, at which the two
subsequences fail to match.
If one subsequence
is shorter than and a matching prefix of the other,
the result is the index
relative to @param{sequence-1} beyond the last position tested.

If @param{from-end} is @term{true}, then one plus the index of the rightmost
position in which the @param{sequences}
differ is returned.  In effect, the subsequences
are aligned at their right-hand ends; then, the last elements are compared,
the penultimate elements, and so on.  The index returned is
an index relative to @param{sequence-1}.

@subsubheading Examples:
@lisp
 (mismatch "abcd" "ABCDE" :test #'char-equal) @EV{} 4
 (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) @EV{} 3
 (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) @EV{} NIL
 (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) @EV{} NIL
@end lisp


@subsubheading See Also:

@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

The @kwd{test-not} @term{argument} is deprecated.


@node replace
@syindexanchor{replace, SYM}
@subsection replace (Function)
@cindex replace


@subsubheading Syntax:

@DefunWithValues{replace, sequence-1 sequence-2 @keyparam{} start1 end1 start2 end2, sequence-1}

@subsubheading Arguments and Values:

@param{sequence-1}---a @term{sequence}.

@param{sequence-2}---a @term{sequence}.

@param{start1}, @param{end1}---@term{bounding index designators} of @param{sequence-1}.
@Defaults{@param{start1} and @param{end1}, @f{0} and @nil{}}

@param{start2}, @param{end2}---@term{bounding index designators} of @param{sequence-2}.
@Defaults{@param{start2} and @param{end2}, @f{0} and @nil{}}

@subsubheading Description:

Destructively modifies @param{sequence-1}
by replacing the @term{elements} of @param{subsequence-1}
@term{bounded} by @param{start1} and @param{end1}
with the @term{elements} of @param{subsequence-2}
@term{bounded} by @param{start2} and @param{end2}.

@param{Sequence-1} is destructively modified by copying successive
@term{elements} into it from @param{sequence-2}.
@term{Elements} of the subsequence of @param{sequence-2}
@term{bounded} by @param{start2} and @param{end2}
are copied into the subsequence of @param{sequence-1}
@term{bounded} by @param{start1} and @param{end1}.
If these subsequences are not of the same length,
then the shorter length determines how many @term{elements} are copied;
the extra @term{elements} near the end of the longer subsequence
are not involved in the operation.
The number of elements copied can be expressed as:

@lisp
 (min (- @i{end1} @i{start1}) (- @i{end2} @i{start2}))
@end lisp


If @param{sequence-1} and @param{sequence-2} are the @term{same} @term{object}
and the region being modified overlaps the region being copied
from, then it is as if the entire source region were copied to another
place and only then copied back into the target region.
However, if @param{sequence-1} and @param{sequence-2} are not the same,
but the region being modified overlaps the region being copied from
(perhaps because of shared list structure or displaced @term{arrays}),
then after the @symbolref{replace, SYM} operation
the subsequence of @param{sequence-1} being modified will have
unpredictable contents.
It is an error if the elements of @param{sequence-2} are not of a
@term{type} that can be stored into @param{sequence-1}.

@subsubheading Examples:
@lisp
 (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4)
@EV{} "abcd456hij"
 (setq lst "012345678") @EV{} "012345678"
 (replace lst lst :start1 2 :start2 0) @EV{} "010123456"
 lst @EV{} "010123456"
@end lisp


@subsubheading Side Effects:

The @param{sequence-1} is modified.

@subsubheading See Also:

@ref{fill}


@node substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+
@syindexanchor{substitute, SYM}
@subsection substitute, substitute-if, substitute-if-not, nsubstitute, nsubstitute-if, nsubstitute-if-not (Function)
@syindexanchor{substitute-if, SYM}
@cindex substitute
@syindexanchor{substitute-if-not, SYM}
@cindex substitute-if
@syindexanchor{nsubstitute, SYM}
@cindex substitute-if-not
@syindexanchor{nsubstitute-if, SYM}
@cindex nsubstitute
@syindexanchor{nsubstitute-if-not, SYM}
@cindex nsubstitute-if
@cindex nsubstitute-if-not
@anchor{substitute}
@anchor{nsubstitute}


@subsubheading Syntax:

@DefunWithValuesNewline{substitute, newitem  olditem  sequence  @keyparam{} @vtop{@hbox{from-end test} @hbox{test-not start} @hbox{end count keyparam}}, result-sequence}

@DefunWithValuesNewline{substitute-if, newitem predicate sequence @keyparam{} from-end start end count keyparam, result-sequence}

@DefunWithValuesNewline{substitute-if-not, newitem predicate sequence @keyparam{} from-end start end count keyparam, result-sequence}

@DefunWithValuesNewline{nsubstitute, newitem  olditem  sequence @keyparam{} from-end test test-not start end count keyparam, sequence}

@DefunWithValuesNewline{nsubstitute-if, newitem predicate sequence @keyparam{} from-end start end count keyparam, sequence}

@DefunWithValuesNewline{nsubstitute-if-not, newitem predicate sequence @keyparam{} from-end start end count keyparam, sequence}

@subsubheading Arguments and Values:

@param{newitem}---an @term{object}.

@param{olditem}---an @term{object}.

@param{sequence}---a @term{proper sequence}.

@param{predicate}---a @term{designator} for a @term{function} of one @term{argument}
that returns a @term{generalized boolean}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{count}---an @term{integer} or @nil{}.
@Default{@nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{result-sequence}---a @term{sequence}.

@subsubheading Description:

@symbolref{substitute, SYM}, @symbolref{substitute-if, SYM}, and @symbolref{substitute-if-not, SYM}
return a
copy of @param{sequence} in which each @term{element}
that @i{satisfies the test} has been replaced with @param{newitem}.

@symbolref{nsubstitute, SYM}, @symbolref{nsubstitute-if, SYM}, and @symbolref{nsubstitute-if-not, SYM}
are like @symbolref{substitute, SYM}, @symbolref{substitute-if, SYM}, and
@symbolref{substitute-if-not, SYM} respectively, but they may modify
@param{sequence}.

If
@param{sequence} is a @term{vector}, the result is a
@term{vector} that has the same
@term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list}, the result is a
@term{list}.

@param{Count}, if supplied, limits the number of elements
altered; if more than @param{count} @term{elements} @term{satisfy the test},
then of these @term{elements} only the leftmost or rightmost, depending
on @param{from-end}, are replaced,
as many as specified by @param{count}.
If @param{count} is supplied and negative,
the behavior is as if zero had been supplied instead.
If @param{count} is @nil{}, all matching items are affected.

Supplying a @param{from-end} of @term{true} matters only when the
@param{count} is provided (and @term{non-nil});
in that case,
only the rightmost @param{count} @term{elements} @i{satisfying the test} are removed
(instead of the leftmost).

@param{predicate}, @param{test}, and @param{test-not}
might be called more than once for each @term{sequence} @term{element},
and their side effects can happen in any order.

The result of all these functions is a @term{sequence}
of the same @term{type} as @param{sequence}
that has the same elements except that those in the subsequence
@term{bounded} by @param{start} and @param{end} and @i{satisfying the test}
have been replaced by @param{newitem}.

@symbolref{substitute, SYM}, @symbolref{substitute-if, SYM}, and @symbolref{substitute-if-not, SYM}
return a @param{sequence} which can share with @param{sequence}
or may be @term{identical} to the input @param{sequence}
if no elements need to be changed.

@symbolref{nsubstitute, SYM} and  @symbolref{nsubstitute-if, SYM} are required to
@symbolref{setf, SYM} any @symbolref{car, SYM} (if @param{sequence} is a @term{list})
or @symbolref{aref, SYM} (if @param{sequence} is a @term{vector})
of @param{sequence} that is required to be replaced with @param{newitem}.
If @param{sequence} is a @term{list},
none of the @term{cdrs} of the top-level @term{list} can be modified.

@subsubheading Examples:

@lisp
 (substitute #@bsl{}. #@bsl{}SPACE "0 2 4 6") @EV{} "0.2.4.6"
 (substitute 9 4 '(1 2 4 1 3 4 5)) @EV{} (1 2 9 1 3 9 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) @EV{} (1 2 9 1 3 4 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
@EV{} (1 2 4 1 3 9 5)
 (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) @EV{} (9 9 4 9 3 4 5)

 (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
@EV{} ((1) (2) (3) 0)
 (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) @EV{} (9 2 4 9 9 4 9)
 (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
@EV{} (1 2 4 1 3 9 5)

 (setq some-things (list 'a 'car 'b 'cdr 'c)) @EV{} (A CAR B CDR C)
 (nsubstitute-if "function was here" #'fboundp some-things
                 :count 1 :from-end t) @EV{} (A CAR B "function was here" C)
 some-things @EV{} (A CAR B "function was here" C)
 (setq alpha-tester (copy-seq "ab ")) @EV{} "ab "
 (nsubstitute-if-not #@bsl{}z #'alpha-char-p alpha-tester) @EV{} "abz"
 alpha-tester @EV{} "abz"
@end lisp


@subsubheading Side Effects:

@symbolref{nsubstitute, SYM}, @symbolref{nsubstitute-if, SYM}, and @symbolref{nsubstitute-if-not, SYM}
modify @param{sequence}.

@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{subst},
@ref{nsubst},
@ref{Compiler Terminology},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

If @param{sequence} is a @term{vector},
the result might or might not be simple,
and might or might not be @term{identical} to @param{sequence}.

The @kwd{test-not} @term{argument} is deprecated.

The functions @symbolref{substitute-if-not, SYM} and @symbolref{nsubstitute-if-not, SYM} are deprecated.

@symbolref{nsubstitute, SYM} and @symbolref{nsubstitute-if, SYM} can be used
in for-effect-only positions in code.

Because the side-effecting variants (@eg{} @symbolref{nsubstitute, SYM})
potentially change the path that is being traversed, their effects in
the presence of shared or circular structure may vary in surprising ways when
compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

@lisp
 (defun test-it (fn)
   (let ((x (cons 'b nil)))
     (rplacd x x)
     (funcall fn 'a 'b x :count 1)))
 (test-it #'substitute) @EV{} (A . #1=(B . #1#))
 (test-it #'nsubstitute) @EV{} (A . #1#)
@end lisp



@node concatenate
@syindexanchor{concatenate, SYM}
@subsection concatenate (Function)
@cindex concatenate


@subsubheading Syntax:

@DefunWithValues{concatenate, result-type @rest{} sequences, result-sequence}

@subsubheading Arguments and Values:

@param{result-type}---a @symbolref{sequence, SYM} @term{type specifier}.

@param{sequences}---a @term{sequence}.

@param{result-sequence}---a @term{proper sequence} of @term{type} @param{result-type}.

@subsubheading Description:

@symbolref{concatenate, SYM} returns a @term{sequence} that contains
all the individual elements of all the @param{sequences} in the order
that they are supplied.
The @term{sequence} is of type @param{result-type},
which must be a @subtypeof{sequence}.

All of the @param{sequences} are copied from; the result
does not share any structure with any of the @param{sequences}.
Therefore, if only one @param{sequence} is provided
and it is of type @param{result-type},
@symbolref{concatenate, SYM} is required to copy @param{sequence} rather than simply
returning it.

It is an error if any element of the @param{sequences} cannot be an
element of the @term{sequence} result.
@reviewer{Barmar: Should signal?}

If the @param{result-type} is a @term{subtype} of @code{list},
the result will be a @term{list}.

If the @param{result-type} is a @term{subtype} of @code{vector},
then if the implementation can determine the element type specified
for the @param{result-type}, the element type of the resulting array
is the result of @term{upgrading} that element type; or, if the
implementation can determine that the element type is unspecified (or @f{*}),
the element type of the resulting array is @symbolref{t, SC};
otherwise, an error is signaled.

@subsubheading Examples:

@lisp
(concatenate 'string "all" " " "together" " " "now") @EV{} "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
@EV{} (#@bsl{}A #@bsl{}B #@bsl{}C D E F 1 2 3 1 0 1 1)
(concatenate 'list) @EV{} NIL
@end lisp


@lisp
  (concatenate '(vector * 2) "a" "bc") should signal an error
@end lisp


@subsubheading Exceptional Situations:

An error is signaled if the @param{result-type} is neither
a @term{recognizable subtype} of @code{list},
nor a @term{recognizable subtype} of @code{vector}.

An error @oftype{type-error} should be signaled if @param{result-type}
specifies the number of elements and the sum of @param{sequences}
is different from that number.

@subsubheading See Also:

@ref{append}


@node merge
@syindexanchor{merge, SYM}
@subsection merge (Function)
@cindex merge


@subsubheading Syntax:

@DefunWithValues{merge, result-type sequence-1 sequence-2 predicate @keyparam{} keyparam, result-sequence}

@subsubheading Arguments and Values:

@param{result-type}---a @symbolref{sequence, SYM} @term{type specifier}.

@param{sequence-1}---a @term{sequence}.

@param{sequence-2}---a @term{sequence}.

@param{predicate}---a @term{designator} for
a @term{function} of two arguments that returns a @term{generalized boolean}.

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{result-sequence}---a @term{proper sequence} of @term{type} @param{result-type}.

@subsubheading Description:

Destructively merges @param{sequence-1} with @param{sequence-2} according
to an order determined by the @param{predicate}.  @symbolref{merge, SYM} determines
the relationship between two elements by giving keys extracted from the
sequence elements to the @param{predicate}.

The first argument to the @param{predicate} function is an element of
@param{sequence-1} as returned by the @param{key} (if supplied);
the second argument is an element of @param{sequence-2} as returned by
the @param{key} (if supplied).
@param{Predicate} should return @term{true} if and only if its first
argument is strictly less than the second (in some appropriate sense).
If the first argument is greater than or equal to the second
(in the appropriate sense), then @param{predicate} should return @term{false}.
@symbolref{merge, SYM}
considers two elements @f{x} and @f{y} to be equal if
@f{(funcall predicate x y)} and
@f{(funcall predicate y x)} both @term{yield} @term{false}.

The argument to the @param{key} is the @param{sequence} element.
Typically, the return value of the @param{key}
becomes the argument to @param{predicate}.
If @param{key} is not supplied or @nil{}, the sequence element itself is used.
The @param{key} may be executed more than once for each @term{sequence} @term{element},
and its side effects may occur in any order.

If @param{key} and @param{predicate} return, then the merging operation
will terminate.  The result of merging two @term{sequences} @f{x} and @f{y}
is a new @term{sequence} of type @param{result-type} @f{z},
such that the length of @f{z} is the sum of the lengths of @f{x}
and @f{y}, and @f{z} contains all the elements of @f{x} and @f{y}.
If @f{x1} and @f{x2} are two elements of @f{x}, and @f{x1} precedes
@f{x2} in @f{x}, then @f{x1} precedes @f{x2} in @f{z}, and similarly for
elements of @f{y}.  In short, @f{z} is an interleaving of @f{x} and @f{y}.

If @f{x} and @f{y} were correctly sorted according to the
@param{predicate}, then @f{z} will also be correctly sorted.
If @f{x} or @f{y} is not so sorted, then @f{z} will not be sorted,
but will nevertheless be an interleaving of @f{x} and @f{y}.

The merging operation is guaranteed stable;
if two or more elements are considered equal by the @param{predicate},
then the elements from @param{sequence-1} will
precede those from @param{sequence-2} in the result.

@param{sequence-1} and/or @param{sequence-2} may be destroyed.

If the @param{result-type} is a @term{subtype} of @code{list},
the result will be a @term{list}.

If the @param{result-type} is a @term{subtype} of @code{vector},
then if the implementation can determine the element type specified
for the @param{result-type}, the element type of the resulting array
is the result of @term{upgrading} that element type; or, if the
implementation can determine that the element type is unspecified (or @f{*}),
the element type of the resulting array is @symbolref{t, SC};
otherwise, an error is signaled.

@subsubheading Examples:
@lisp
 (setq test1 (list 1 3 4 6 7))
 (setq test2 (list 2 5 8))
 (merge 'list test1 test2 #'<) @EV{} (1 2 3 4 5 6 7 8)
 (setq test1 (copy-seq "BOY"))
 (setq test2 (copy-seq :nosy"))
 (merge 'string test1 test2 #'char-lessp) @EV{} "BnOosYy"
 (setq test1 (vector ((red . 1) (blue . 4))))
 (setq test2 (vector ((yellow . 2) (green . 7))))
 (merge 'vector test1 test2 #'< :key #'cdr)
@EV{} #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7))
@end lisp

@lisp
 (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error
@end lisp


@subsubheading Exceptional Situations:

An error must be signaled if the @param{result-type} is neither
a @term{recognizable subtype} of @code{list},
nor a @term{recognizable subtype} of @code{vector}.

An error @oftype{type-error} should be signaled
if @param{result-type} specifies the number of elements
and the sum of the lengths of @param{sequence-1} and @param{sequence-2}
is different from that number.

@subsubheading See Also:

@ref{sort},
@ref{stable-sort},
@ref{Compiler Terminology},
@ref{Traversal Rules and Side Effects}


@node remove; remove-if; remove-if-not; delete; delete-if; delete-if-not
@syindexanchor{remove, SYM}
@subsection remove, remove-if, remove-if-not, delete, delete-if, delete-if-not (Function)
@syindexanchor{remove-if, SYM}
@cindex remove
@syindexanchor{remove-if-not, SYM}
@cindex remove-if
@syindexanchor{delete, SYM}
@cindex remove-if-not
@syindexanchor{delete-if, SYM}
@cindex delete
@syindexanchor{delete-if-not, SYM}
@cindex delete-if
@cindex delete-if-not


@subsubheading Syntax:

@DefunWithValues{remove, item sequence @keyparam{} from-end test test-not start end count keyparam, result-sequence}

@DefunWithValues{remove-if, test sequence @keyparam{} from-end start end count keyparam, result-sequence}

@DefunWithValues{remove-if-not, test sequence @keyparam{} from-end start end count keyparam, result-sequence}

@DefunWithValues{delete, item sequence @keyparam{} from-end test test-not start end count keyparam, result-sequence}

@DefunWithValues{delete-if, test sequence @keyparam{} from-end start end count keyparam, result-sequence}

@DefunWithValues{delete-if-not, test sequence @keyparam{} from-end start end count keyparam, result-sequence}

@subsubheading Arguments and Values:

@param{item}---an @term{object}.

@param{sequence}---a @term{proper sequence}.

@param{test}---a @term{designator} for a @term{function}
of one @term{argument} that returns a @term{generalized boolean}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{count}---an @term{integer} or @nil{}.
@Default{@nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{result-sequence}---a @term{sequence}.

@subsubheading Description:

@symbolref{remove, SYM}, @symbolref{remove-if, SYM}, and @symbolref{remove-if-not, SYM}
return a @param{sequence} from which
the elements that @term{satisfy the test}
have been removed.

@symbolref{delete, SYM}, @symbolref{delete-if, SYM}, and @symbolref{delete-if-not, SYM}
are like @symbolref{remove, SYM}, @symbolref{remove-if, SYM}, and
@symbolref{remove-if-not, SYM} respectively,
but they may modify @param{sequence}.

If @param{sequence} is a @term{vector}, the result is a
@term{vector} that has the same
@term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list}, the result is a @term{list}.

Supplying a @param{from-end} of @term{true} matters only when the
@param{count} is provided; in that case only the rightmost @param{count} elements
@i{satisfying the test} are deleted.

@param{Count}, if supplied, limits the number of elements
removed or deleted; if more than @param{count} elements @term{satisfy the test},
then of these elements only the leftmost or rightmost, depending on
@param{from-end},
are deleted or removed,
as many as specified by @param{count}.
If @param{count} is supplied and negative,
the behavior is as if zero had been supplied instead.
If @param{count} is @nil{}, all matching items are affected.

For all these functions,
elements
not removed or deleted occur in the same order in the result
as they did in @param{sequence}.

@symbolref{remove, SYM}, @symbolref{remove-if, SYM}, @symbolref{remove-if-not, SYM} return
a @term{sequence}
of the same @term{type} as @param{sequence}
that has the same elements except that those in the subsequence
@term{bounded} by @param{start} and @param{end} and @i{satisfying the test}
have been removed.
This is a non-destructive operation. If any
elements need to be removed, the result will be a copy.
The result of @symbolref{remove, SYM} may share
with @param{sequence};
the result may be @term{identical} to the input @param{sequence}
if no elements need to be removed.

@symbolref{delete, SYM}, @symbolref{delete-if, SYM}, and @symbolref{delete-if-not, SYM}
return a @term{sequence}
of the same @term{type} as @param{sequence}
that has the same elements except that those in the subsequence
@term{bounded} by @param{start} and @param{end} and @i{satisfying the test}
have been deleted.
@param{Sequence} may be destroyed and used to construct
the result; however, the result might or might not be @term{identical}
to @param{sequence}.

@symbolref{delete, SYM}, when @param{sequence} is a @term{list}, is permitted to
@symbolref{setf, SYM} any part, @symbolref{car, SYM} or @symbolref{cdr, SYM}, of the
top-level list structure in that @param{sequence}.
When @param{sequence} is a @term{vector},  @symbolref{delete, SYM} is
permitted to change the dimensions of the @term{vector}
and to slide its elements into new positions without
permuting them to produce the resulting @term{vector}.

@symbolref{delete-if, SYM} is constrained to behave exactly as follows:

@lisp
 (delete nil @i{sequence}
             :test #'(lambda (ignore @i{item}) (funcall @i{test} @i{item}))
             ...)
@end lisp



@subsubheading Examples:
@lisp
 (remove 4 '(1 3 4 5 9)) @EV{} (1 3 5 9)
 (remove 4 '(1 2 4 1 3 4 5)) @EV{} (1 2 1 3 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1) @EV{} (1 2 1 3 4 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) @EV{} (1 2 4 1 3 5)
 (remove 3 '(1 2 4 1 3 4 5) :test #'>) @EV{} (4 3 4 5)
 (setq lst '(list of four elements)) @EV{} (LIST OF FOUR ELEMENTS)
 (setq lst2 (copy-seq lst)) @EV{} (LIST OF FOUR ELEMENTS)
 (setq lst3 (delete 'four lst)) @EV{} (LIST OF ELEMENTS)
 (equal lst lst2) @EV{} @term{false}
 (remove-if #'oddp '(1 2 4 1 3 4 5)) @EV{} (2 4 4)
 (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
@EV{} (1 2 4 1 3 5)
 (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
@EV{} (1 2 3 4 5 6 8)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete 4 tester) @EV{} (1 2 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete 4 tester :count 1) @EV{} (1 2 1 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete 4 tester :count 1 :from-end t) @EV{} (1 2 4 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete 3 tester :test #'>) @EV{} (4 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete-if #'oddp tester) @EV{} (2 4 4)
 (setq tester (list 1 2 4 1 3 4 5)) @EV{} (1 2 4 1 3 4 5)
 (delete-if #'evenp tester :count 1 :from-end t) @EV{} (1 2 4 1 3 5)
 (setq tester (list 1 2 3 4 5 6)) @EV{} (1 2 3 4 5 6)
 (delete-if #'evenp tester) @EV{} (1 3 5)
 tester @EV{} @term{implementation-dependent}
@end lisp


@lisp
 (setq foo (list 'a 'b 'c)) @EV{} (A B C)
 (setq bar (cdr foo)) @EV{} (B C)
 (setq foo (delete 'b foo)) @EV{} (A C)
 bar @EV{} ((C)) or ...
 (eq (cdr foo) (car bar)) @EV{} T or ...
@end lisp


@subsubheading Side Effects:

For @symbolref{delete, SYM}, @symbolref{delete-if, SYM}, and @symbolref{delete-if-not, SYM},
@param{sequence} may be destroyed and used to construct the result.

@subsubheading Exceptional Situations:

@Lazychecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{Compiler Terminology},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

If @param{sequence} is a @term{vector},
the result might or might not be simple,
and might or might not be @term{identical} to @param{sequence}.

The @kwd{test-not} @term{argument} is deprecated.

The functions @symbolref{delete-if-not, SYM} and @symbolref{remove-if-not, SYM} are deprecated.


@node remove-duplicates; delete-duplicates
@syindexanchor{remove-duplicates, SYM}
@subsection remove-duplicates, delete-duplicates (Function)
@syindexanchor{delete-duplicates, SYM}
@cindex remove-duplicates
@cindex delete-duplicates


@subsubheading Syntax:

@DefunWithValuesNewline{remove-duplicates, sequence @keyparam{} @vtop{@hbox{from-end test test-not} @hbox{start end keyparam}}, result-sequence}

@DefunWithValuesNewline{delete-duplicates, sequence @keyparam{}  @vtop{@hbox{from-end test test-not} @hbox{start end keyparam}}, result-sequence}

@subsubheading Arguments and Values:

@param{sequence}---a @term{proper sequence}.

@param{from-end}---a @term{generalized boolean}.
@Default{@term{false}}

@param{test}---a @term{designator} for a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{test-not}---a @term{designator} for
a @term{function} of two @term{arguments}
that returns a @term{generalized boolean}.

@param{start}, @param{end}---@term{bounding index designators} of @param{sequence}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{key}---a @term{designator} for a @term{function} of one argument,
or @nil{}.

@param{result-sequence}---a @term{sequence}.

@subsubheading Description:

@symbolref{remove-duplicates, SYM} returns a modified copy of @param{sequence}
from which any element that matches another element occurring in
@param{sequence} has been removed.

If @param{sequence} is a @term{vector}, the result is a
@term{vector} that has the same
@term{actual array element type} as @param{sequence}.
If @param{sequence} is a @term{list}, the result is a @term{list}.

@symbolref{delete-duplicates, SYM} is like @symbolref{remove-duplicates, SYM},
but @symbolref{delete-duplicates, SYM} may modify @param{sequence}.

The elements of @param{sequence} are compared @term{pairwise}, and if any two match,
then the one occurring earlier in @param{sequence}
is discarded, unless @param{from-end} is @term{true}, in which case the one
later in @param{sequence} is discarded.

@symbolref{remove-duplicates, SYM} and @symbolref{delete-duplicates, SYM}
return a @term{sequence} of the same @term{type} as
@param{sequence} with enough elements removed so that no two of the remaining
elements match.  The order of the elements remaining in the result
is the same as the order in which they appear in @param{sequence}.

@symbolref{remove-duplicates, SYM} returns a @term{sequence}
that may share
with @param{sequence} or may be @term{identical} to @param{sequence}
if no elements need to be removed.

@symbolref{delete-duplicates, SYM}, when @param{sequence} is a @term{list},
is permitted to @symbolref{setf, SYM} any part, @symbolref{car, SYM} or @symbolref{cdr, SYM},
of the top-level list structure in that @param{sequence}.
When @param{sequence} is a @term{vector}, @symbolref{delete-duplicates, SYM}
is permitted to change the dimensions of the @term{vector}
and to slide its elements into new positions without
permuting them to produce the resulting @term{vector}.

@subsubheading Examples:

@lisp
 (remove-duplicates "aBcDAbCd" :test #'char-equal :from-end t) @EV{} "aBcD"
 (remove-duplicates '(a b c b d d e)) @EV{} (A C B D E)
 (remove-duplicates '(a b c b d d e) :from-end t) @EV{} (A B C D E)
 (remove-duplicates '((foo #@bsl{}a) (bar #@bsl{}%) (baz #@bsl{}A))
     :test #'char-equal :key #'cadr) @EV{} ((BAR #@bsl{}%) (BAZ #@bsl{}A))
 (remove-duplicates '((foo #@bsl{}a) (bar #@bsl{}%) (baz #@bsl{}A))
     :test #'char-equal :key #'cadr :from-end t) @EV{} ((FOO #@bsl{}a) (BAR #@bsl{}%))
 (setq tester (list 0 1 2 3 4 5 6))
 (delete-duplicates tester :key #'oddp :start 1 :end 6) @EV{} (0 4 5 6)
@end lisp


@subsubheading Side Effects:

@symbolref{delete-duplicates, SYM} might destructively modify @param{sequence}.

@subsubheading Exceptional Situations:

@Shouldchecktype{sequence, a @term{proper sequence}}

@subsubheading See Also:

@ref{Compiler Terminology},
@ref{Traversal Rules and Side Effects}

@subsubheading Notes:

If @param{sequence} is a @term{vector},
the result might or might not be simple,
and might or might not be @term{identical} to @param{sequence}.

The @kwd{test-not} @term{argument} is deprecated.

These functions are useful for converting @param{sequence} into a canonical
form suitable for representing a set.
