@node Reader
@chapter Reader
@menu
* Reader Concepts::
* Reader Dictionary::
@end menu

@node Reader Concepts
@section Reader Concepts

@menu
* Dynamic Control of the Lisp Reader::
* Effect of Readtable Case on the Lisp Reader::
* Argument Conventions of Some Reader Functions::
@end menu
@node Dynamic Control of the Lisp Reader
@subsection Dynamic Control of the Lisp Reader

Various aspects of the @term{Lisp reader} can be controlled dynamically.
See @ref{Readtables}@spc{}and @ref{Variables that affect the Lisp Reader}.


@node Effect of Readtable Case on the Lisp Reader
@subsection Effect of Readtable Case on the Lisp Reader

The @term{readtable case} of the @term{current readtable} affects the @term{Lisp reader}
in the following ways:


@table @asis
@item @id{@kwd{upcase}}


When the @term{readtable case} is @kwd{upcase},
unescaped constituent @term{characters} are converted to @term{uppercase},
as specified in @ref{Reader Algorithm}.

@item @id{@kwd{downcase}}


When the @term{readtable case} is @kwd{downcase},
unescaped constituent @term{characters} are converted to @term{lowercase}.

@item @id{@kwd{preserve}}


When the @term{readtable case} is @kwd{preserve},
the case of all @term{characters} remains unchanged.

@item @id{@kwd{invert}}


When the @term{readtable case} is @kwd{invert},
then if all of the unescaped letters in the extended token are of the same @term{case},
those (unescaped) letters are converted to the opposite @term{case}.
@end table


@node Examples of Effect of Readtable Case on the Lisp Reader
@subsubsection Examples of Effect of Readtable Case on the Lisp Reader
@lisp
 (defun test-readtable-case-reading ()
   (let ((*readtable* (copy-readtable nil)))
     (format t "READTABLE-CASE  Input   Symbol-name~
              ~%-----------------------------------~
              ~%")
     (dolist (readtable-case '(:upcase :downcase :preserve :invert))
       (setf (readtable-case *readtable*) readtable-case)
       (dolist (input '("ZEBRA" "Zebra" "zebra"))
         (format t "~&:~A~16T~A~24T~A"
                 (string-upcase readtable-case)
                 input
                 (symbol-name (read-from-string input)))))))
@end lisp


The output from @f{(test-readtable-case-reading)} should be as follows:

@lisp
 READTABLE-CASE     Input Symbol-name
 -------------------------------------
    :UPCASE         ZEBRA   ZEBRA
    :UPCASE         Zebra   ZEBRA
    :UPCASE         zebra   ZEBRA
    :DOWNCASE       ZEBRA   zebra
    :DOWNCASE       Zebra   zebra
    :DOWNCASE       zebra   zebra
    :PRESERVE       ZEBRA   ZEBRA
    :PRESERVE       Zebra   Zebra
    :PRESERVE       zebra   zebra
    :INVERT         ZEBRA   zebra
    :INVERT         Zebra   Zebra
    :INVERT         zebra   ZEBRA
@end lisp




@node Argument Conventions of Some Reader Functions
@subsection Argument Conventions of Some Reader Functions

@node The EOF-ERROR-P argument
@subsubsection The EOF-ERROR-P argument

@param{Eof-error-p} in input function calls
controls what happens if input is from a file (or any other
input source that has a definite end) and the end of the file is reached.
If @param{eof-error-p} is @term{true} (the default),
an error @oftype{end-of-file} is signaled
at end of file.  If it is @term{false}, then no error is signaled, and instead
the function returns @param{eof-value}.

Functions such as @symbolref{read, SYM} that read the representation
of an @term{object} rather than a single
character always signals an error, regardless of @param{eof-error-p}, if
the file ends in the middle of an object representation.
For example, if a file does
not contain enough right parentheses to balance the left parentheses in
it, @symbolref{read, SYM} signals an error.  If a file ends in a
@term{symbol} or a @term{number}
immediately followed by end-of-file, @symbolref{read, SYM} reads the
@term{symbol} or
@term{number}
successfully and when called again will
act according to @param{eof-error-p}.
Similarly, @thefunction{read-line}
successfully reads the last line of a file even if that line
is terminated by end-of-file rather than the newline character.
Ignorable text, such as lines containing only @term{whitespace}@sub{2} or comments,
are not considered to begin an @term{object};
if @symbolref{read, SYM} begins to read an @term{expression} but sees only such
ignorable text, it does not consider the file to end in the middle of an @term{object}.
Thus an @param{eof-error-p} argument controls what happens
when the file ends between @term{objects}.


@node The RECURSIVE-P argument
@subsubsection The RECURSIVE-P argument

If @param{recursive-p} is supplied and not @nil{}, it specifies that
this function call is not an outermost call to @symbolref{read, SYM} but an
embedded call, typically from a @term{reader macro function}.
It is important to distinguish such recursive calls for three reasons.


@enumerate 1
@item
An outermost call establishes the context within which the
@f{#@param{n}=} and @f{#@param{n}#} syntax is scoped.  Consider, for example,
the expression

@lisp
 (cons '#3=(p q r) '(x y . #3#))
@end lisp

If the @term{single-quote} @term{reader macro} were defined in this way:

@lisp
 (set-macro-character #@bsl{}'       ;incorrect
    #'(lambda (stream char)
         (declare (ignore char))
         (list 'quote (read stream))))
@end lisp


then each call to the @term{single-quote} @term{reader macro function} would establish
independent contexts for the scope of @symbolref{read, SYM} information, including the scope of
identifications between markers like ``@f{#3=}'' and ``@f{#3#}''.  However, for
this expression, the scope was clearly intended to be determined by the outer set
of parentheses, so such a definition would be incorrect.
The correct way to define the @term{single-quote}
@term{reader macro} uses @param{recursive-p}:

@lisp
 (set-macro-character #@bsl{}'       ;correct
    #'(lambda (stream char)
         (declare (ignore char))
         (list 'quote (read stream t nil t))))
@end lisp


@item
A recursive call does not alter whether the reading process
is to preserve @term{whitespace}@sub{2} or not (as determined by whether the
outermost call was to @symbolref{read, SYM} or @symbolref{read-preserving-whitespace, SYM}).
Suppose again that @term{single-quote}
were to be defined as shown above in the incorrect definition.
Then a call to @symbolref{read-preserving-whitespace, SYM}
that read the expression @f{'foo@SpaceChar{}} would fail to preserve the space
character following the symbol @f{foo} because the @term{single-quote}
@term{reader macro function} calls @symbolref{read, SYM},
not @symbolref{read-preserving-whitespace, SYM},
to read the following expression (in this case @f{foo}).
The correct definition, which passes the value @term{true} for @param{recursive-p}
to @symbolref{read, SYM}, allows the outermost call to determine
whether @term{whitespace}@sub{2} is preserved.

@item
When end-of-file is encountered and the @param{eof-error-p} argument
is not @nil{}, the kind of error that is signaled may depend on the value
of @param{recursive-p}.  If @param{recursive-p}
is @term{true}, then the end-of-file
is deemed to have occurred within the middle of a printed representation;
if @param{recursive-p} is @term{false}, then the end-of-file may be deemed to have
occurred between @term{objects} rather than within the middle of one.
@end enumerate

@node Reader Dictionary
@section Reader Dictionary


@menu
* readtable::
* copy-readtable::
* make-dispatch-macro-character::
* read; read-preserving-whitespace::
* read-delimited-list::
* read-from-string::
* readtable-case::
* readtablep::
* set-dispatch-macro-character; get-dispatch-macro-character::
* set-macro-character; get-macro-character::
* set-syntax-from-char::
* with-standard-io-syntax::
* *read-base*::
* *read-default-float-format*::
* *read-eval*::
* *read-suppress*::
* *readtable*::
* reader-error::
@end menu

@node readtable
@subsection readtable (System Class)
@syindexanchor{readtable, SYM}
@cindex readtable


@subsubheading Class Precedence List:
@symbolref{readtable, SYM},
@code{t}

@subsubheading Description:

A @term{readtable} maps @term{characters} into @term{syntax types} for
the @term{Lisp reader}; see @ref{Syntax, Chapter 2 (Syntax)}.
A @term{readtable} also
contains associations between @term{macro characters}
and their @term{reader macro functions},
and records information about the case conversion rules
to be used by the @term{Lisp reader} when parsing @term{symbols}.

Each @term{simple} @term{character} must be representable in the @term{readtable}.
It is @term{implementation-defined} whether @term{non-simple} @term{characters}
can have syntax descriptions in the @term{readtable}.

@subsubheading See Also:

@ref{Readtables},
@ref{Printing Other Objects}


@node copy-readtable
@subsection copy-readtable (Function)
@syindexanchor{copy-readtable, SYM}
@cindex copy-readtable


@subsubheading Syntax:

@DefunWithValues{copy-readtable, @opt{} from-readtable to-readtable, readtable}

@subsubheading Arguments and Values:

@param{from-readtable}---a @term{readtable designator}.
@Default{the @term{current readtable}}

@param{to-readtable}---a @term{readtable} or @nil{}.
@Default{@nil{}}

@param{readtable}---the @param{to-readtable} if it is @term{non-nil},
or else a @term{fresh} @term{readtable}.

@subsubheading Description:

@symbolref{copy-readtable, SYM} copies @param{from-readtable}.

If @param{to-readtable} is @nil{}, a new @term{readtable} is created and returned.
Otherwise the @term{readtable} specified by @param{to-readtable} is modified and returned.

@symbolref{copy-readtable, SYM} copies the setting of @symbolref{readtable-case, SYM}.

@subsubheading Examples:

@lisp
 (setq zvar 123) @EV{} 123
 (set-syntax-from-char #@bsl{}z #@bsl{}' (setq table2 (copy-readtable))) @EV{} T
 zvar @EV{} 123
 (copy-readtable table2 *readtable*) @EV{} #<READTABLE 614000277>
 zvar @EV{} VAR
 (setq *readtable* (copy-readtable)) @EV{} #<READTABLE 46210223>
 zvar @EV{} VAR
 (setq *readtable* (copy-readtable nil)) @EV{} #<READTABLE 46302670>
 zvar @EV{} 123
@end lisp


@subsubheading See Also:

@ref{readtable},
@ref{*readtable*}

@subsubheading Notes:

@lisp
(setq *readtable* (copy-readtable nil))
@end lisp

restores the input syntax to standard @clisp{}@spc{}syntax, even if
the @term{initial readtable} has been clobbered
(assuming it is not so badly clobbered that you cannot type in the above expression).

On the other hand,

@lisp
(setq *readtable* (copy-readtable))
@end lisp

replaces the current @term{readtable} with a copy of itself.
This is useful if you want to save a copy of a readtable for later use,
protected from alteration in the meantime.  It is also useful if you want to
locally bind the readtable to a copy of itself, as in:

@lisp
(let ((*readtable* (copy-readtable))) ...)
@end lisp



@node make-dispatch-macro-character
@subsection make-dispatch-macro-character (Function)
@syindexanchor{make-dispatch-macro-character, SYM}
@cindex make-dispatch-macro-character


@subsubheading Syntax:

@DefunWithValues{make-dispatch-macro-character, char @opt{} non-terminating-p readtable, @code{t}}

@subsubheading Arguments and Values:

@param{char}---a @term{character}.

@param{non-terminating-p}---a @term{generalized boolean}.
@Default{@term{false}}

@param{readtable}---a @term{readtable}.
@Default{the @term{current readtable}}

@subsubheading Description:

@symbolref{make-dispatch-macro-character, SYM} makes @param{char}
be a @term{dispatching macro character} in @param{readtable}.

Initially, every @term{character} in the dispatch table
associated with the @param{char} has an associated function
that signals an error @oftype{reader-error}.

If @param{non-terminating-p} is @term{true},
the @term{dispatching macro character}
is made a @term{non-terminating} @term{macro character};
if @param{non-terminating-p} is @term{false},
the @term{dispatching macro character}
is made a @term{terminating} @term{macro character}.

@subsubheading Examples:

@lisp
 (get-macro-character #@bsl{}@lbr{}) @EV{} NIL, @term{false}
 (make-dispatch-macro-character #@bsl{}@lbr{}) @EV{} T
 (not (get-macro-character #@bsl{}@lbr{})) @EV{} @term{false}
@end lisp


The @param{readtable} is altered.

@subsubheading See Also:

@ref{*readtable*}, @ref{set-dispatch-macro-character}


@node read; read-preserving-whitespace
@subsection read, read-preserving-whitespace (Function)
@syindexanchor{read, SYM}
@cindex read
@syindexanchor{read-preserving-whitespace, SYM}
@cindex read-preserving-whitespace
@anchor{read}
@anchor{read-preserving-whitespace}


@subsubheading Syntax:

@DefunWithValues{read, @opt{} input-stream eof-error-p eof-value recursive-p, object}

@DefunWithValuesNewline{read-preserving-whitespace, @opt{} @vtop{@hbox{input-stream eof-error-p} @hbox{eof-value recursive-p}}, object}

@subsubheading Arguments and Values:

@param{input-stream}---an @term{input} @term{stream designator}.

@param{eof-error-p}---a @term{generalized boolean}.
@Default{@term{true}}

@param{eof-value}---an @term{object}.
@Default{@nil{}}

@param{recursive-p}---a @term{generalized boolean}.
@Default{@term{false}}

@param{object}---an @term{object} (parsed by the @term{Lisp reader})
or the @param{eof-value}.

@subsubheading Description:

@symbolref{read, SYM} parses the printed representation of an @term{object}
from @param{input-stream} and builds such an @term{object}.

@symbolref{read-preserving-whitespace, SYM} is like @symbolref{read, SYM} but preserves
any @term{whitespace}@sub{2} @term{character}
that delimits the printed representation of the @term{object}.
@symbolref{read-preserving-whitespace, SYM} is exactly like @symbolref{read, SYM}
when the @param{recursive-p} @term{argument} to @symbolref{read-preserving-whitespace, SYM}
is @term{true}.

When @symbolref{*read-suppress*, SYM} is @term{false},
@symbolref{read, SYM} throws away the delimiting @term{character} required by
certain printed representations if it is a
@term{whitespace}@sub{2} @term{character};
but @symbolref{read, SYM} preserves the character
(using @symbolref{unread-char, SYM}) if it is
syntactically meaningful, because it could be the start of the next expression.

If a file ends in a @term{symbol} or a @term{number}
immediately followed by an @term{end of file}@sub{1},
@symbolref{read, SYM} reads the @term{symbol} or @term{number} successfully;
when called again, it sees the @term{end of file}@sub{1} and
only then acts according to @param{eof-error-p}.
If a file contains ignorable text at the end, such
as blank lines and comments, @symbolref{read, SYM}
does not consider it to end in the
middle of an @term{object}.

If @param{recursive-p} is @term{true}, the call to @symbolref{read, SYM} is
expected to be made
from within some function that itself
has been called from @symbolref{read, SYM} or from a similar input function, rather
than from the top level.


Both functions return the @term{object} read from @param{input-stream}.
@param{Eof-value} is returned if @param{eof-error-p} is @term{false} and end of file
is reached before the beginning of an @term{object}.

@subsubheading Examples:

@lisp
 (read)
@OUT{} @IN{'a}
@EV{} (QUOTE A)
 (with-input-from-string (is " ") (read is nil 'the-end)) @EV{} THE-END
 (defun skip-then-read-char (s c n)
    (if (char= c #@bsl{}@lcurly{}) (read s t nil t) (read-preserving-whitespace s))
    (read-char-no-hang s)) @EV{} SKIP-THEN-READ-CHAR
 (let ((*readtable* (copy-readtable nil)))
    (set-dispatch-macro-character #@bsl{}# #@bsl{}@lcurly{} #'skip-then-read-char)
    (set-dispatch-macro-character #@bsl{}# #@bsl{}@rcurly{} #'skip-then-read-char)
    (with-input-from-string (is "#@lcurly{}123 x #@rcurly{}123 y")
      (format t "~S ~S" (read is) (read is)))) @EV{} #@bsl{}x, #@bsl{}Space, NIL
@end lisp


As an example, consider this @term{reader macro} definition:

@lisp
 (defun slash-reader (stream char)
   (declare (ignore char))
   `(path . ,(loop for dir = (read-preserving-whitespace stream t nil t)
                   then (progn (read-char stream t nil t)
                               (read-preserving-whitespace stream t nil t))
                   collect dir
                   while (eql (peek-char nil stream nil nil t) #@bsl{}/))))
 (set-macro-character #@bsl{}/ #'slash-reader)
@end lisp


Consider now calling @symbolref{read, SYM} on this expression:

@lisp
 (zyedh /usr/games/zork /usr/games/boggle)
@end lisp

The @f{/} macro reads objects separated by more @f{/} characters;
thus @f{/usr/games/zork} is intended to read as @f{(path usr games zork)}.
The entire example expression should therefore be read as

@lisp
 (zyedh (path usr games zork) (path usr games boggle))
@end lisp

However, if @symbolref{read, SYM} had been used instead of
@symbolref{read-preserving-whitespace, SYM}, then after the reading of the symbol
@f{zork}, the following space would be discarded; the next call
to @symbolref{peek-char, SYM} would see the following @f{/}, and the loop would
continue, producing this interpretation:

@lisp
 (zyedh (path usr games zork usr games boggle))
@end lisp

There are times when @term{whitespace}@sub{2} should be discarded.
If a command interpreter takes single-character commands,
but occasionally reads an @term{object} then if the @term{whitespace}@sub{2}
after a @term{symbol}
is not discarded it might be interpreted as a command
some time later after the @term{symbol} had been read.

@subsubheading Affected By:

@symbolref{*standard-input*, SYM},
@symbolref{*terminal-io*, SYM},
@symbolref{*readtable*, SYM},
@symbolref{*read-default-float-format*, SYM},
@symbolref{*read-base*, SYM},
@symbolref{*read-suppress*, SYM},
@symbolref{*package*, SYM},
@symbolref{*read-eval*, SYM}.

@subsubheading Exceptional Situations:

@symbolref{read, SYM} signals an error @oftype{end-of-file},
regardless of @param{eof-error-p}, if
the file ends in the middle of an @term{object} representation.
For example, if a file does
not contain enough right parentheses to balance the left parentheses in
it, @symbolref{read, SYM} signals an error.
This is detected when @symbolref{read, SYM} or @symbolref{read-preserving-whitespace, SYM}
is called with @param{recursive-p} and @param{eof-error-p} @term{non-nil},
and end-of-file is reached before the beginning of an @term{object}.

If @param{eof-error-p} is @term{true}, an error @oftype{end-of-file}
is signaled at the end of file.

@subsubheading See Also:

@ref{peek-char},
@ref{read-char},
@ref{unread-char},
@ref{read-from-string},
@ref{read-delimited-list},
@ref{parse-integer},
@ref{Syntax, Chapter 2 (Syntax)},
@ref{Reader Concepts}


@node read-delimited-list
@subsection read-delimited-list (Function)
@syindexanchor{read-delimited-list, SYM}
@cindex read-delimited-list


@subsubheading Syntax:

@DefunWithValues{read-delimited-list, char @opt{} input-stream recursive-p, list}

@subsubheading Arguments and Values:

@param{char}---a @term{character}.

@param{input-stream}---an @term{input} @term{stream designator}.
@Default{@term{standard input}}

@param{recursive-p}---a @term{generalized boolean}.
@Default{@term{false}}

@param{list}---a @term{list} of the @term{objects} read.

@subsubheading Description:

@symbolref{read-delimited-list, SYM} reads @term{objects} from @param{input-stream}
until the next character after an @term{object}'s
representation (ignoring @term{whitespace}@sub{2} characters and comments) is @param{char}.

@symbolref{read-delimited-list, SYM} looks ahead at each step
for the next non-@term{whitespace}@sub{2} @term{character}
and peeks at it as if with @symbolref{peek-char, SYM}.
If it is @param{char},
then the @term{character} is consumed and the @term{list} of @term{objects} is returned.
If it is a @term{constituent} or @term{escape} @term{character},
then @symbolref{read, SYM} is used to read an @term{object},
which is added to the end of the @term{list}.
If it is a @term{macro character},
its @term{reader macro function} is called;
if the function returns a @term{value},
that @term{value} is added to the @term{list}.
The peek-ahead process is then repeated.

If @param{recursive-p} is @term{true},
this call is expected to be embedded in a higher-level call to @symbolref{read, SYM}
or a similar function.

It is an error to reach end-of-file during the operation of
@symbolref{read-delimited-list, SYM}.

The consequences are undefined
if @param{char} has a @term{syntax type} of @term{whitespace}@sub{2}
in the @term{current readtable}.

@subsubheading Examples:
@lisp
 (read-delimited-list #@bsl{}@rbracket{}) 1 2 3 4 5 6 @rbracket{}
@EV{} (1 2 3 4 5 6)
@end lisp

Suppose you wanted @f{#@lcurly{}@i{a} @i{b} @i{c} @mat{@ldots{}} @i{z}@rcurly{}}
to read as a list of all pairs of the elements @i{a}, @i{b}, @i{c},
@mat{@ldots{}}, @i{z}, for example.

@lisp
 #@lcurly{}p q z a@rcurly{}  reads as  ((p q) (p z) (p a) (q z) (q a) (z a))
@end lisp

This can be done by specifying a macro-character definition for @f{#@lcurly{}}
that does two things: reads in all the items up to the @f{@rcurly{}},
and constructs the pairs.  @symbolref{read-delimited-list, SYM} performs
the first task.

@lisp
 (defun |#@lcurly{}-reader| (stream char arg)
   (declare (ignore char arg))
   (mapcon #'(lambda (x)
              (mapcar #'(lambda (y) (list (car x) y)) (cdr x)))
          (read-delimited-list #@bsl{}@rcurly{} stream t))) @EV{} |#@lcurly{}-reader|

 (set-dispatch-macro-character #@bsl{}# #@bsl{}@lcurly{} #'|#@lcurly{}-reader|) @EV{} T
 (set-macro-character #@bsl{}@rcurly{} (get-macro-character #@bsl{}) @nil{}))
@end lisp

Note that @term{true} is supplied for the @param{recursive-p} argument.

It is necessary here to give a definition to the character @f{@rcurly{}} as
well to prevent it from being a constituent.
If the line

@lisp
 (set-macro-character #@bsl{}@rcurly{} (get-macro-character #@bsl{}) @nil{}))
@end lisp

shown above were not included, then the @f{@rcurly{}} in

@lisp
 #@lcurly{} p q z a@rcurly{}
@end lisp

would be considered a constituent character, part of the symbol named
@f{a@rcurly{}}.  This could be corrected by putting a space before
the @f{@rcurly{}}, but it is better to call
@symbolref{set-macro-character, SYM}.

Giving @f{@rcurly{}} the same
definition as the standard definition of the character @f{)} has the
twin benefit of making it terminate tokens for use with
@symbolref{read-delimited-list, SYM} and also making it invalid for use in any
other context. Attempting to read a stray @f{@rcurly{}} will signal an error.

@subsubheading Affected By:

@symbolref{*standard-input*, SYM},
@symbolref{*readtable*, SYM},
@symbolref{*terminal-io*, SYM}.

@subsubheading See Also:

@ref{read},
@ref{peek-char},
@ref{read-char},
@ref{unread-char}.

@subsubheading Notes:

@symbolref{read-delimited-list, SYM} is intended for use in implementing @term{reader macros}.
Usually it is desirable for @param{char} to be a @term{terminating} @term{macro character}
so that it can be used to delimit tokens; however, @symbolref{read-delimited-list, SYM}
makes no attempt to alter the syntax specified for @param{char} by the current
readtable.  The caller must make any necessary changes to the readtable syntax
explicitly.


@node read-from-string
@subsection read-from-string (Function)
@syindexanchor{read-from-string, SYM}
@cindex read-from-string


@subsubheading Syntax:

@DefunWithValuesNewline{read-from-string, string @vtop{@hbox{@opt{} eof-error-p eof-value} @hbox{@keyparam{} start end preserve-whitespace}}, object\, position}

@subsubheading Arguments and Values:

@param{string}---a @term{string}.

@param{eof-error-p}---a @term{generalized boolean}.
@Default{@term{true}}

@param{eof-value}---an @term{object}.
@Default{@nil{}}

@param{start}, @param{end}---@term{bounding index designators} of @param{string}.
@Defaults{@param{start} and @param{end}, @f{0} and @nil{}}

@param{preserve-whitespace}---a @term{generalized boolean}.
@Default{@term{false}}

@param{object}---an @term{object} (parsed by the @term{Lisp reader})
or the @param{eof-value}.

@param{position}---an @term{integer} greater than or equal to zero,
and less than or equal to
one more than the @term{length} of the @param{string}.

@subsubheading Description:

Parses the printed representation of an @term{object}
from the subsequence of @param{string} @term{bounded} by @param{start} and @param{end},
as if @symbolref{read, SYM} had been called on an @term{input} @term{stream}
containing those same @term{characters}.

If @param{preserve-whitespace} is @term{true},
the operation will preserve @term{whitespace}@sub{2}
as @symbolref{read-preserving-whitespace, SYM} would do.

If an @term{object} is successfully parsed, the @term{primary value}, @param{object},
is the @term{object} that was parsed.
If @param{eof-error-p} is @term{false} and if the end of the @param{substring} is reached,
@param{eof-value} is returned.

The @term{secondary value}, @param{position}, is the index of the first @term{character}
in the @term{bounded} @param{string} that was not read.
The @param{position} may depend upon the value of @param{preserve-whitespace}.
If the entire @param{string} was read,
the @param{position} returned is either the @param{length} of the @param{string}
or one greater than the @param{length} of the @param{string}.

@subsubheading Examples:

@lisp
 (read-from-string " 1 3 5" t nil :start 2) @EV{} 3, 5
 (read-from-string "(a b c)") @EV{} (A B C), 7
@end lisp


@subsubheading Exceptional Situations:

If the end of the supplied substring
occurs before an @term{object} can be read, an
error is signaled if @param{eof-error-p} is @term{true}.
An error is signaled if the end of the @param{substring} occurs
in the middle of an incomplete @term{object}.

@subsubheading See Also:

@ref{read},
@ref{read-preserving-whitespace}

@subsubheading Notes:

The reason that @param{position} is allowed to be beyond the
@term{length} of the @param{string} is to permit (but not require)
the @term{implementation} to work by simulating the effect of a
trailing delimiter at the end of the @term{bounded} @param{string}.
When @param{preserve-whitespace} is @term{true},
the @param{position} might count the simulated delimiter.


@node readtable-case
@subsection readtable-case (Accessor)
@syindexanchor{readtable-case, SYM}
@cindex readtable-case


@subsubheading Syntax:

@DefunWithValues{readtable-case, readtable, mode}

@Defsetf{readtable-case, readtable, mode}

@subsubheading Arguments and Values:

@param{readtable}---a @term{readtable}.

@param{mode}---a @term{case sensitivity mode}.

@subsubheading Description:

@term{Accesses} the @term{readtable case} of @param{readtable},
which affects the way in which the @term{Lisp Reader}  reads  @term{symbols}
and the way in which the @term{Lisp Printer} writes @term{symbols}.

@subsubheading Examples:

See @ref{Examples of Effect of Readtable Case on the Lisp Reader}@spc{}and @ref{Examples of Effect of Readtable Case on the Lisp Printer}.

@subsubheading Exceptional Situations:

@Shouldchecktype{readtable, a @term{readtable}}
@Shouldchecktype{mode, a @term{case sensitivity mode}}

@subsubheading See Also:

@ref{*readtable*},
@ref{*print-escape*},
@ref{Reader Algorithm},
@ref{Effect of Readtable Case on the Lisp Reader},
@ref{Effect of Readtable Case on the Lisp Printer}

@subsubheading Notes:

@symbolref{copy-readtable, SYM} copies the @term{readtable case} of the @param{readtable}.


@node readtablep
@subsection readtablep (Function)
@syindexanchor{readtablep, SYM}
@cindex readtablep


@subsubheading Syntax:

@DefunWithValues{readtablep, object, generalized-boolean}

@subsubheading Arguments and Values:

@param{object}---an @term{object}.

@param{generalized-boolean}---a @term{generalized boolean}.

@subsubheading Description:

@TypePredicate{object, readtable}

@subsubheading Examples:

@lisp
 (readtablep *readtable*) @EV{} @term{true}
 (readtablep (copy-readtable)) @EV{} @term{true}
 (readtablep '*readtable*) @EV{} @term{false}
@end lisp


@subsubheading Notes:

@lisp
 (readtablep @param{object}) @EQ{} (typep @param{object} 'readtable)
@end lisp



@node set-dispatch-macro-character; get-dispatch-macro-character
@subsection set-dispatch-macro-character, get-dispatch-macro-character (Function)
@syindexanchor{set-dispatch-macro-character, SYM}
@cindex set-dispatch-macro-character
@syindexanchor{get-dispatch-macro-character, SYM}
@cindex get-dispatch-macro-character
@anchor{set-dispatch-macro-character}


@subsubheading Syntax:

@DefunWithValues{get-dispatch-macro-character, disp-char sub-char @opt{} readtable, function}

@DefunWithValues{set-dispatch-macro-character, disp-char sub-char new-function @opt{} readtable, @code{t}}

@subsubheading Arguments and Values:

@param{disp-char}---a @term{character}.

@param{sub-char}---a @term{character}.

@param{readtable}---a @term{readtable designator}.
@Default{the @term{current readtable}}

@param{function}---a @term{function designator} or @nil{}.

@param{new-function}---a @term{function designator}.

@subsubheading Description:

@symbolref{set-dispatch-macro-character, SYM} causes @param{new-function} to be called
when @param{disp-char} followed by @param{sub-char} is read.
If @param{sub-char} is a lowercase letter,
it is converted to its uppercase equivalent.
It is an error if @param{sub-char} is one of the ten decimal digits.

@symbolref{set-dispatch-macro-character, SYM} installs a @param{new-function} to be called
when a particular @term{dispatching macro character} pair is read.
@param{New-function} is installed as the dispatch function to be
called  when @param{readtable} is in use and when @param{disp-char} is followed by
@param{sub-char}.

For more information about how the @param{new-function} is invoked,
see @ref{Macro Characters}.

@symbolref{get-dispatch-macro-character, SYM} retrieves
the dispatch function associated with @param{disp-char} and @param{sub-char}
in @param{readtable}.

@symbolref{get-dispatch-macro-character, SYM} returns the macro-character function
for @param{sub-char} under @param{disp-char}, or @nil{}@spc{}if there is no
function associated with @param{sub-char}.
If @param{sub-char} is a decimal digit, @symbolref{get-dispatch-macro-character, SYM}
returns @nil{}.

@subsubheading Examples:

@lisp
 (get-dispatch-macro-character #@bsl{}# #@bsl{}@lcurly{}) @EV{} NIL
 (set-dispatch-macro-character #@bsl{}# #@bsl{}@lcurly{}        ;dispatch on #@lcurly{}
    #'(lambda(s c n)
        (let ((list (read s nil (values) t)))  ;list is object after #n@lcurly{}
          (when (consp list)                   ;return nth element of list
            (unless (and n (< 0 n (length list))) (setq n 0))
            (setq list (nth n list)))
         list))) @EV{} T
 #@lcurly{}(1 2 3 4) @EV{} 1
 #3@lcurly{}(0 1 2 3) @EV{} 3
 #@lcurly{}123 @EV{} 123
@end lisp

If it is desired that @f{#@dollar{}@i{foo}} :
as if it were @f{(dollars @i{foo})}.

@lisp
(defun |#$-reader| (stream subchar arg)
   (declare (ignore subchar arg))
   (list 'dollars (read stream t nil t))) @EV{} |#$-reader|
 (set-dispatch-macro-character #@bsl{}# #@bsl{}@dollar{} #'|#@dollar{}-reader|) @EV{} T
@end lisp


@subsubheading See Also:

@ref{Macro Characters}

@subsubheading Side Effects:

The @param{readtable} is modified.

@subsubheading Affected By:

@symbolref{*readtable*, SYM}.

@subsubheading Exceptional Situations:

For either function, an error is signaled if @param{disp-char} is not
a @term{dispatching macro character} in @param{readtable}.

@subsubheading See Also:

@ref{*readtable*}

@subsubheading Notes:
It is necessary
to use @symbolref{make-dispatch-macro-character, SYM} to set up the
dispatch character before specifying its sub-characters.

@node set-macro-character; get-macro-character
@subsection set-macro-character, get-macro-character (Function)
@syindexanchor{set-macro-character, SYM}
@cindex set-macro-character
@syindexanchor{get-macro-character, SYM}
@cindex get-macro-character
@anchor{set-macro-character}


@subsubheading Syntax:

@DefunWithValues{get-macro-character, char @opt{} readtable, function\, non-terminating-p}

@DefunWithValues{set-macro-character, char new-function @opt{} non-terminating-p readtable, @code{t}}

@subsubheading Arguments and Values:

@param{char}---a @term{character}.

@param{non-terminating-p}---a @term{generalized boolean}.
@Default{@term{false}}

@param{readtable}---a @term{readtable designator}.
@Default{the @term{current readtable}}

@param{function}---@nil{},
or a @term{designator} for a @term{function} of two @term{arguments}.

@param{new-function}---a @term{function designator}.

@subsubheading Description:

@symbolref{get-macro-character, SYM} returns as its @term{primary value}, @param{function},
the @term{reader macro function} associated with @param{char} in @param{readtable} (if any),
or else @nil{}@spc{}if @param{char} is not a @term{macro character} in @param{readtable}.
The @term{secondary value}, @param{non-terminating-p}, is @term{true}
if @param{char} is a @term{non-terminating} @term{macro character};
otherwise, it is @term{false}.

@symbolref{set-macro-character, SYM} causes @param{char} to be a @term{macro character}
associated with the @term{reader macro function} @param{new-function}
(or the @term{designator} for @param{new-function}) in @param{readtable}.
If @param{non-terminating-p} is @term{true},
@param{char} becomes a @term{non-terminating} @term{macro character};
otherwise it becomes a     @term{terminating} @term{macro character}.

@subsubheading Examples:

@lisp
 (get-macro-character #@bsl{}@lbr{}) @EV{} NIL, @term{false}
 (not (get-macro-character #@bsl{};)) @EV{} @term{false}
@end lisp


The following is a possible definition for the @term{single-quote} @term{reader macro}
in @term{standard syntax}:

@lisp
 (defun single-quote-reader (stream char)
   (declare (ignore char))
   (list 'quote (read stream t nil t))) @EV{} SINGLE-QUOTE-READER
 (set-macro-character #@bsl{}' #'single-quote-reader) @EV{} T
@end lisp


Here @f{single-quote-reader} reads an @term{object} following the @term{single-quote}
and returns a @term{list} of @symbolref{quote, SYM} and that @term{object}.
The @param{char} argument is ignored.

The following is a possible definition for the @term{semicolon} @term{reader macro}
in @term{standard syntax}:

@lisp
 (defun semicolon-reader (stream char)
   (declare (ignore char))
   ;; First swallow the rest of the current input line.
   ;; End-of-file is acceptable for terminating the comment.
   (do () ((char= (read-char stream nil #@bsl{}Newline t) #@bsl{}Newline)))
   ;; Return zero values.
   (values)) @EV{} SEMICOLON-READER
 (set-macro-character #@bsl{}; #'semicolon-reader) @EV{} T
@end lisp


@subsubheading Side Effects:

The @param{readtable} is modified.

@subsubheading See Also:

@ref{*readtable*}


@node set-syntax-from-char
@subsection set-syntax-from-char (Function)
@syindexanchor{set-syntax-from-char, SYM}
@cindex set-syntax-from-char


@subsubheading Syntax:

@DefunWithValues{set-syntax-from-char, to-char from-char @opt{} to-readtable from-readtable, @code{t}}

@subsubheading Arguments and Values:

@param{to-char}---a @term{character}.

@param{from-char}---a @term{character}.

@param{to-readtable}---a @term{readtable}.
@Default{the @term{current readtable}}

@param{from-readtable}---a @term{readtable designator}.
@Default{the @term{standard readtable}}

@subsubheading Description:

@symbolref{set-syntax-from-char, SYM} makes
the syntax of @param{to-char}   in @param{to-readtable}    be the same as
the syntax of @param{from-char} in @param{from-readtable}.

@symbolref{set-syntax-from-char, SYM} copies the @term{syntax types} of @param{from-char}.
If @param{from-char} is a @term{macro character},
its @term{reader macro function} is copied also.
If the character is a @term{dispatching macro character},
its entire dispatch table of @term{reader macro functions} is copied.
The @term{constituent traits} of @param{from-char} are not copied.

A macro definition from a character such as
@f{"} can be copied to another character; the standard definition for @f{"}
looks for another character that is the same as the character that
invoked it.  The definition of @f{(} can not be meaningfully copied
to @f{@lcurly{}}, on the other hand.
The result is that @term{lists} are of the form
@f{@lcurly{}a b c)}, not @f{@lcurly{}a b c@rcurly{}},
because the definition
always looks for a closing parenthesis, not a closing brace.

@subsubheading Examples:
@lisp
 (set-syntax-from-char #@bsl{}7 #@bsl{};) @EV{} T
 123579 @EV{} 1235
@end lisp


@subsubheading Side Effects:

The @param{to-readtable} is modified.

@subsubheading Affected By:

The existing values in the @param{from-readtable}.

@subsubheading See Also:

@ref{set-macro-character},
@ref{make-dispatch-macro-character},
@ref{Character Syntax Types}

@subsubheading Notes:

The @term{constituent traits} of a @term{character} are ``hard wired''
into the parser for extended @term{tokens}.  For example, if the definition
of @f{S} is copied to @f{*}, then @f{*} will become a @term{constituent}
that is @term{alphabetic}@sub{2} but that cannot be used as a
@term{short float} @term{exponent marker}.
For further information, see @ref{Constituent Traits}.


@node with-standard-io-syntax
@subsection with-standard-io-syntax (Macro)
@syindexanchor{with-standard-io-syntax, SYM}
@cindex with-standard-io-syntax


@subsubheading Syntax:

@DefmacWithValues{with-standard-io-syntax, @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{forms}---an @term{implicit progn}.

@param{results}---the @term{values} returned by the @term{forms}.

@subsubheading Description:

Within the dynamic extent of the body of @param{forms}, all reader/printer control
variables, including any @term{implementation-defined} ones not specified by
this standard, are bound to values that produce standard read/print
behavior.  The values for the variables specified by this standard are listed in
@thenextfigure{}.

@reviewer{Barrett: *print-pprint-dispatch* should probably be mentioned here, too.}


@float Figure,fig23.1
@cartouche
@multitable{@symbolref{*read-default-float-format*, SYM}}{The @term{standard pprint dispatch table}}
@headitem Variable @tab Value
@item @symbolref{*package*, SYM} @tab The @code{CL-USER} @term{package}
@item @symbolref{*print-array*, SYM} @tab @code{t}
@item @symbolref{*print-base*, SYM} @tab @f{10}
@item @symbolref{*print-case*, SYM} @tab @kwd{upcase}
@item @symbolref{*print-circle*, SYM} @tab @nil{}
@item @symbolref{*print-escape*, SYM} @tab @code{t}
@item @symbolref{*print-gensym*, SYM} @tab @code{t}
@item @symbolref{*print-length*, SYM} @tab @nil{}
@item @symbolref{*print-level*, SYM} @tab @nil{}
@item @symbolref{*print-lines*, SYM} @tab @nil{}
@item @symbolref{*print-miser-width*, SYM} @tab @nil{}
@item @symbolref{*print-pprint-dispatch*, SYM} @tab The @term{standard pprint dispatch table}
@item @symbolref{*print-pretty*, SYM} @tab @nil{}
@item @symbolref{*print-radix*, SYM} @tab @nil{}
@item @symbolref{*print-readably*, SYM} @tab @code{t}
@item @symbolref{*print-right-margin*, SYM} @tab @nil{}
@item @symbolref{*read-base*, SYM} @tab @f{10}
@item @symbolref{*read-default-float-format*, SYM} @tab @symbolref{single-float, SYM}
@item @symbolref{*read-eval*, SYM} @tab @code{t}
@item @symbolref{*read-suppress*, SYM} @tab @nil{}
@item @symbolref{*readtable*, SYM} @tab The @term{standard readtable}
@end multitable
@end cartouche
@caption{Values of standard control variables}
@end float


@subsubheading Examples:

@lisp
 (with-open-file (file pathname :direction :output)
   (with-standard-io-syntax
     (print data file)))

;;; ... Later, in another Lisp:

 (with-open-file (file pathname :direction :input)
   (with-standard-io-syntax
     (setq data (read file))))
@end lisp



@node *read-base*
@subsection *read-base* (Variable)
@syindexanchor{*read-base*, SYM}
@cindex *read-base*


@subsubheading Value Type:

a @term{radix}.

@subsubheading Initial Value:

@f{10}.

@subsubheading Description:

Controls the interpretation of tokens by @symbolref{read, SYM} as being
@term{integers} or @term{ratios}.

@Thevalueof{*read-base*}, called the @newterm{current input base},
is the radix in which @term{integers} and
@term{ratios} are to be read by the @term{Lisp reader}.
The parsing of other numeric @term{types} (@eg{} @term{floats}) is
not affected by this option.

The effect of @symbolref{*read-base*, SYM} on the reading of any particular
@term{rational} number can be locally overridden by explicit use of the
@f{#O}, @f{#X}, @f{#B}, or @tt{#@i{n}R} syntax
or by a trailing decimal point.

@subsubheading Examples:

@lisp
 (dotimes (i 6)
   (let ((*read-base* (+ 10. i)))
     (let ((object (read-from-string "(@bsl{}@bsl{}DAD DAD |BEE| BEE 123. 123)")))
       (print (list *read-base* object)))))
@OUT{} (10 (DAD DAD BEE BEE 123 123))
@OUT{} (11 (DAD DAD BEE BEE 123 146))
@OUT{} (12 (DAD DAD BEE BEE 123 171))
@OUT{} (13 (DAD DAD BEE BEE 123 198))
@OUT{} (14 (DAD 2701 BEE BEE 123 227))
@OUT{} (15 (DAD 3088 BEE 2699 123 258))
@EV{} NIL
@end lisp


@subsubheading Notes:

Altering the input radix can be useful when reading data files in special formats.


@node *read-default-float-format*
@subsection *read-default-float-format* (Variable)
@syindexanchor{*read-default-float-format*, SYM}
@cindex *read-default-float-format*


@subsubheading Value Type:

one of the @term{atomic type specifiers}
@symbolref{short-float, SYM},
@symbolref{single-float, SYM},
@symbolref{double-float, SYM},
or @symbolref{long-float, SYM},
or else some other @term{type specifier} defined
by the @term{implementation} to be acceptable.

@subsubheading Initial Value:

The @term{symbol} @symbolref{single-float, SYM}.

@subsubheading Description:

Controls the floating-point format that is to be used when reading a
floating-point number that has no @term{exponent marker} or that has
@f{e} or @f{E} for an @term{exponent marker}.  Other @term{exponent markers}
explicitly prescribe the floating-point format to be used.

The printer uses @symbolref{*read-default-float-format*, SYM} to guide the
choice of @term{exponent markers} when printing floating-point numbers.

@subsubheading Examples:

@lisp
 (let ((*read-default-float-format* 'double-float))
   (read-from-string "(1.0 1.0e0 1.0s0 1.0f0 1.0d0 1.0L0)"))
@EV{} (1.0   1.0   1.0   1.0 1.0   1.0)   ;Implementation has float format F.
@EV{} (1.0   1.0   1.0s0 1.0 1.0   1.0)   ;Implementation has float formats S and F.
@EV{} (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0d0) ;Implementation has float formats F and D.
@EV{} (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0d0) ;Implementation has float formats S, F, D.
@EV{} (1.0d0 1.0d0 1.0   1.0 1.0d0 1.0L0) ;Implementation has float formats F, D, L.
@EV{} (1.0d0 1.0d0 1.0s0 1.0 1.0d0 1.0L0) ;Implementation has formats S, F, D, L.
@end lisp



@node *read-eval*
@subsection *read-eval* (Variable)
@syindexanchor{*read-eval*, SYM}
@cindex *read-eval*



@subsubheading Value Type:

a @term{generalized boolean}.

@subsubheading Initial Value:

@term{true}.

@subsubheading Description:

If it is @term{true}, the @f{#.} @term{reader macro} has its normal effect.
Otherwise, that @term{reader macro} signals an error @oftype{reader-error}.

@subsubheading See Also:

@ref{*print-readably*}

@subsubheading Notes:

If @symbolref{*read-eval*, SYM} is @term{false} and @symbolref{*print-readably*, SYM} is @term{true},
any @term{method} for @symbolref{print-object, SYM} that would output a reference
to the @f{#.} @term{reader macro} either outputs something different
or signals an error @oftype{print-not-readable}.



@node *read-suppress*
@subsection *read-suppress* (Variable)
@syindexanchor{*read-suppress*, SYM}
@cindex *read-suppress*


@subsubheading Value Type:

a @term{generalized boolean}.

@subsubheading Initial Value:

@term{false}.

@subsubheading Description:

This variable is intended primarily to support the operation of the
read-time conditional notations @f{#+} and @f{#-}. It is important for the
@term{reader macros} which implement these notations
to be able to skip over the printed representation of an
@term{expression} despite the possibility that the syntax of the skipped
@term{expression} may not be entirely valid for the current implementation,
since @f{#+} and @f{#-} exist in order to allow the same program to be
shared among several @Lisp{}@spc{}implementations (including dialects other than @clisp{})
despite small incompatibilities of syntax.

If it is @term{false}, the @term{Lisp reader} operates normally.


If @thevalueof{*read-suppress*} is @term{true},
@symbolref{read, SYM},
@symbolref{read-preserving-whitespace, SYM},
@symbolref{read-delimited-list, SYM},
and @symbolref{read-from-string, SYM}
all return a @term{primary value} of @nil{}@spc{}when they complete successfully;
however, they continue to parse the representation of an @term{object}
in the normal way, in order to skip over the @term{object},
and continue to indicate @term{end of file} in the normal way.
Except as noted below,
any @term{standardized} @term{reader macro}@sub{2}
that is defined to @term{read}@sub{2}
a following @term{object} or @term{token}
will do so,
but not signal an error if the @term{object}
read is not of an appropriate type or syntax.
The @term{standard syntax} and its associated @term{reader macros}
will not construct any new @term{objects}
(@eg{} when reading the representation of a @term{symbol},
no @term{symbol} will be constructed or interned).


@table @asis

@item @id{Extended tokens}


All extended tokens are completely uninterpreted.
Errors such as those that might otherwise be signaled due to
detection of invalid @term{potential numbers},
invalid patterns of @term{package markers},
and invalid uses of the @term{dot} character are suppressed.

@item @id{Dispatching macro characters (including @term{sharpsign})}


@term{Dispatching macro characters} continue to parse an infix numerical
argument, and invoke the dispatch function.  The @term{standardized}
@term{sharpsign} @term{reader macros} do not enforce any constraints
on either the presence of or the value of the numerical argument.


@item @id{@tt{#=}}


The @f{#=} notation is totally ignored.  It does not read
a following @term{object}. It produces no @term{object},
but is treated as @term{whitespace}@sub{2}.

@item @id{@tt{##}}


The @f{##} notation always produces @nil{}.
@end table


No matter what @thevalueof{*read-suppress*},
parentheses still continue to delimit and construct @term{lists};
the @f{#(} notation continues to delimit @term{vectors};
and comments, @term{strings},
and the @term{single-quote} and @term{backquote} notations continue to be
interpreted properly.  Such situations as
@f{')},@f{#<},
@f{#)}, and @f{#@SpaceChar{}} continue to signal errors.

@subsubheading Examples:

@lisp
 (let ((*read-suppress* t))
   (mapcar #'read-from-string
           '("#(foo bar baz)" "#P(:type :lisp)" "#c1.2"
             "#.(PRINT 'FOO)" "#3AHELLO" "#S(INTEGER)"
             "#*ABC" "#@bsl{}GARBAGE" "#RALPHA" "#3R444")))
@EV{} (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)
@end lisp


@subsubheading See Also:

@ref{read},
@ref{Syntax, Chapter 2 (Syntax)}

@subsubheading Notes:

@term{Programmers} and @term{implementations} that define additional
@term{macro characters} are strongly encouraged to make them respect
@symbolref{*read-suppress*, SYM} just as @term{standardized} @term{macro characters} do.
That is, when @thevalueof{*read-suppress*} is @term{true},
they should ignore type errors when reading a following @term{object}
and the @term{functions} that implement @term{dispatching macro characters}
should tolerate @nil{}@spc{}as their infix @term{parameter} value even if a numeric
value would ordinarily be required.


@node *readtable*
@subsection *readtable* (Variable)
@syindexanchor{*readtable*, SYM}
@cindex *readtable*


@subsubheading Value Type:

a @term{readtable}.

@subsubheading Initial Value:

A @term{readtable} that conforms to the description of @clisp{}@spc{}syntax in @ref{Syntax, Chapter 2 (Syntax)}.

@subsubheading Description:

@Thevalueof{*readtable*} is called the @term{current readtable}.
It controls the parsing behavior of the @term{Lisp reader},
and can also influence the @term{Lisp printer} (@eg{} see the @term{function} @ref{readtable-case}).

@subsubheading Examples:

@lisp
 (readtablep *readtable*) @EV{} @term{true}
 (setq zvar 123) @EV{} 123
 (set-syntax-from-char #@bsl{}z #@bsl{}' (setq table2 (copy-readtable))) @EV{} T
 zvar @EV{} 123
 (setq *readtable* table2) @EV{} #<READTABLE>
 zvar @EV{} VAR
 (setq *readtable* (copy-readtable nil)) @EV{} #<READTABLE>
 zvar @EV{} 123
@end lisp


@subsubheading Affected By:

@symbolref{compile-file, SYM},
@symbolref{load, SYM}

@subsubheading See Also:

@ref{compile-file},
@ref{load},
@ref{readtable},
@ref{The Current Readtable}


@node reader-error
@subsection reader-error (Condition Type)
@syindexanchor{reader-error, SYM}
@cindex reader-error



@subsubheading Class Precedence List:
@symbolref{reader-error, SYM},
@symbolref{parse-error, SYM},
@symbolref{stream-error, SYM},
@code{error},
@symbolref{serious-condition, SYM},
@symbolref{condition, SYM},
@code{t}

@subsubheading Description:

@Thetype{reader-error} consists of
error conditions that are related to tokenization and parsing
done by the @term{Lisp reader}.

@subsubheading See Also:

@ref{read},
@ref{stream-error-stream},
@ref{Reader Concepts}
