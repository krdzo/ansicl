@node Conditions
@chapter Conditions
@menu
* Condition System Concepts::

Dictionary

* condition::
* warning::
* style-warning::
* serious-condition::
* error (Condition Type)::
* cell-error::
* cell-error-name::
* parse-error::
* storage-condition::
* assert::
* error (Function)::
* cerror::
* check-type::
* simple-error::
* invalid-method-error::
* method-combination-error::
* signal::
* simple-condition::
* simple-condition-format-control; simple-condition-format-arguments::
* warn::
* simple-warning::
* invoke-debugger::
* break::
* *debugger-hook*::
* *break-on-signals*::
* handler-bind::
* handler-case::
* ignore-errors::
* define-condition::
* make-condition::
* restart::
* compute-restarts::
* find-restart::
* invoke-restart::
* invoke-restart-interactively::
* restart-bind::
* restart-case::
* restart-name::
* with-condition-restarts::
* with-simple-restart::
* abort (Restart)::
* continue (Restart)::
* muffle-warning (Restart)::
* store-value (Restart)::
* use-value (Restart)::
* abort; continue; muffle-warning; store-value; use-value::
@end menu

@node Condition System Concepts
@section Condition System Concepts

Common Lisp constructs are described not only in terms of their
behavior in situations during which they are intended to be used (see
the ``Description'' part of each @term{operator} specification),
but in all other situations (see the ``Exceptional Situations''
part of each @term{operator} specification).

A situation is the evaluation of an expression in a specific context.
A @term{condition} is an @term{object} that
represents a specific situation that has been detected.
@term{Conditions} are @instancesofclasses{condition}.
A hierarchy of @term{condition} classes is defined in @clisp{}.
A @term{condition} has @term{slots} that contain data
relevant to the situation that the @term{condition} represents.

An error is a situation in which normal program execution cannot
continue correctly without some form of intervention (either
interactively by the user or under program control).  Not all errors
are detected.  When an error goes undetected, the effects can be
@term{implementation-dependent}, @term{implementation-defined}, unspecified, or
undefined. See @ref{Definitions, Section 1.4 (Definitions)}.  All detected errors can
be represented by @term{conditions}, but not all
@term{conditions} represent errors.

Signaling is the process by which a @term{condition} can alter
the flow of control in a program by raising the
@term{condition} which can then be @term{handled}.  The functions
@code{error}, @code{cerror}, @code{signal}, and
@code{warn} are used to signal @term{conditions}.

The process of signaling involves the selection and invocation of a
@term{handler} from a set of @term{active} @term{handlers}.
A @term{handler} is a @term{function} of one argument (the
@term{condition}) that is invoked to handle a @term{condition}.
Each @term{handler} is associated with a @term{condition} @term{type},
and a @term{handler} will be invoked only on a @term{condition} of the
@term{handler}'s associated @term{type}.

@term{Active} @term{handlers} are @term{established} dynamically
(see @code{handler-bind} or @code{handler-case}).
@term{Handlers} are invoked in a @term{dynamic environment}
equivalent to that of the signaler,
except that the set of @term{active} @term{handlers}
is bound in such a way as to include only those that were @term{active}
at the time the @term{handler} being invoked was @term{established}.
Signaling a @term{condition} has no side-effect on the @term{condition},
and there is no dynamic state contained in a @term{condition}.

If a @term{handler} is invoked, it can address the @term{situation}
in one of three ways:


@table @asis
@item @id{@b{Decline}}


It can decline to @term{handle} the @term{condition}.  It does this by
simply returning rather than transferring control.
When this happens, any values returned by the handler are
ignored and the next most recently established handler is invoked.
If there is no such handler and the signaling function is @code{error}
or @code{cerror}, the debugger is entered in the
@term{dynamic environment} of the signaler. If there is no such
handler and the signaling function is either @code{signal} or
@code{warn}, the signaling function simply returns@tie{}@nil{}.

@item @id{@b{Handle}}


It can @term{handle} the @term{condition} by performing a non-local
transfer of control.  This can be done either primitively by using
@code{go}, @code{return}, @code{throw} or more
abstractly by using a function such as @code{abort} or
@code{invoke-restart}.

@item @id{@b{Defer}}


It can put off a decision about whether to @term{handle} or @term{decline},
by any of a number of actions, but most commonly by
signaling another condition,
resignaling the same condition,
or forcing entry into the debugger.
@end table


@menu
* Condition Types::
* Creating Conditions::
* Printing Conditions::
* Signaling and Handling Conditions::
* Assertions::
* Notes about the Condition System's Background::
@end menu
@node Condition Types
@subsection Condition Types

@Thenextfigure{}@spc{}lists the @term{standardized} @term{condition} @term{types}.
Additional @term{condition} @term{types} can be defined by using @code{define-condition}.



@float Figure,StandardizedConditionTypes
@cartouche
@multitable{floating-point-invalid-operation}{floating-point-underflow}{undefined-function}

@item arithmetic-error @tab floating-point-overflow @tab simple-type-error
@item cell-error @tab floating-point-underflow @tab simple-warning
@item condition @tab package-error @tab storage-condition
@item control-error @tab parse-error @tab stream-error
@item division-by-zero @tab print-not-readable @tab style-warning
@item end-of-file @tab program-error @tab type-error
@item error @tab reader-error @tab unbound-slot
@item file-error @tab serious-condition @tab unbound-variable
@item floating-point-inexact @tab simple-condition @tab undefined-function
@item floating-point-invalid-operation @tab simple-error @tab warning
@end multitable
@end cartouche
@caption{Standardized Condition Types}
@end float


All @term{condition} types are @subtypesof{condition}.  That is,

@lisp
 (typep @param{c} 'condition) @EV{} @term{true}
@end lisp

if and only if @param{c} is a @term{condition}.

@term{Implementations} must define all specified @term{subtype} relationships.
Except where noted, all @term{subtype} relationships indicated in
this document are not mutually exclusive.
A @term{condition} inherits the structure of its @term{supertypes}.

The metaclass of @theclass{condition} is not specified.
@term{Names} of @term{condition} @term{types} may be used to specify
@term{supertype} relationships in @code{define-condition},
but the consequences are not specified if an attempt is made to use
a @term{condition} @term{type} as a @term{superclass} in a @code{defclass} @term{form}.

@Thenextfigure{}@spc{}shows @term{operators} that
define @term{condition} @term{types} and creating @term{conditions}.


@float Figure,fig9.2
@cartouche
@multitable{define-condition}{make-condition}{}

@item define-condition @tab make-condition @tab
@end multitable
@end cartouche
@caption{Operators that define and create conditions.}
@end float


@Thenextfigure{}@spc{}shows @term{operators} that @term{read}
the @term{value} of @term{condition} @term{slots}.


@float Figure,fig9.3
@cartouche
@multitable{arithmetic-error-operation}{simple-condition-format-arguments}

@item arithmetic-error-operands @tab simple-condition-format-arguments
@item arithmetic-error-operation @tab simple-condition-format-control
@item cell-error-name @tab stream-error-stream
@item file-error-pathname @tab type-error-datum
@item package-error-package @tab type-error-expected-type
@item print-not-readable-object @tab unbound-slot-instance
@end multitable
@end cartouche
@caption{Operators that read condition slots.}
@end float


@subsubsection Serious Conditions

A @term{serious condition} is a @term{condition} serious
enough to require interactive intervention if not handled.
@term{Serious conditions} are typically signaled with @code{error} or @code{cerror};
non-serious @term{conditions} are typically signaled with @code{signal} or @code{warn}.



@node Creating Conditions
@subsection Creating Conditions

The function @code{make-condition} can be used to construct
a @term{condition} @term{object} explicitly.  Functions such as @code{error},
@code{cerror}, @code{signal}, and @code{warn} operate on
@term{conditions} and might create @term{condition} @term{objects}
implicitly.  Macros such as @code{ccase}, @code{ctypecase},
@code{ecase}, @code{etypecase}, @code{check-type}, and
@code{assert} might also implicitly create (and @term{signal})
@term{conditions}.

@subsubsection Condition Designators
@anchor{ConditionDesignators}

A number of the functions in the condition system take arguments which
are identified as
@cindex condition designator
@dfn{condition designators}.
By convention, those arguments are notated as

@spc{}@param{datum} @rest{} @param{arguments}

Taken together, the @param{datum} and the @param{arguments} are
``@term{designators} for a @term{condition} of default type @param{default-type}.''
How the denoted @term{condition} is computed depends on the type of the @param{datum}:


@itemize @bullet{}

@item If the @param{datum} is a @term{symbol}
naming a @term{condition} @term{type} @mat{@ldots{}}

The denoted @term{condition} is the result of

@lisp
 (apply #'make-condition @param{datum} @param{arguments})
@end lisp


@item If the @param{datum} is a @term{format control} @mat{@ldots{}}

The denoted @term{condition} is the result of

@lisp
 (make-condition @param{defaulted-type}
                 :format-control @param{datum}
                 :format-arguments @param{arguments})
@end lisp


where the @param{defaulted-type} is a @term{subtype} of @param{default-type}.

@item If the @param{datum} is a @term{condition} @mat{@ldots{}}

The denoted @term{condition} is the @param{datum} itself.
In this case, unless otherwise specified by the description of the
@term{operator} in question, the @term{arguments} must be @term{null};
that is, the consequences are undefined if any @param{arguments} were supplied.
@end itemize


Note that the @param{default-type} gets used only in the case where
the @param{datum} @term{string} is supplied.  In the other situations,
the resulting condition is not necessarily of @term{type} @param{default-type}.

Here are some illustrations of how different @term{condition designators}
can denote equivalent @term{condition} @term{objects}:

@lisp
(let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))
  (error c))
@EQ{} (error 'arithmetic-error :operator '/ :operands '(7 0))

(error "Bad luck.")
@EQ{} (error 'simple-error :format-control "Bad luck." :format-arguments '())
@end lisp




@node Printing Conditions
@subsection Printing Conditions

If the @kwd{report} argument to @code{define-condition} is used,
a print function is defined that is called whenever
the defined @term{condition} is printed while @thevalueof{*print-escape*} is @term{false}.
This function is called the @newterm{condition reporter};
the text which it outputs is called a @newterm{report message}.

When a @term{condition} is printed and @code{*print-escape*}
is @term{false}, the @term{condition reporter} for the @term{condition} is invoked.
@term{Conditions} are printed automatically by functions such as
@code{invoke-debugger}, @code{break}, and @code{warn}.

When @code{*print-escape*} is @term{true}, the @term{object} should print in an
abbreviated fashion according to the style of the implementation
(@eg{} by @code{print-unreadable-object}).  It is not required that a
@term{condition} can be recreated by reading its printed representation.

No @term{function} is provided for directly @term{accessing}
or invoking @term{condition reporters}.

@subsubsection Recommended Style in Condition Reporting

In order to ensure a properly aesthetic result when presenting
@term{report messages} to the user, certain stylistic conventions are
recommended.

There are stylistic recommendations for the content of the messages
output by @term{condition reporters}, but there are no formal requirements
on those @term{programs}.
If a @term{program} violates the recommendations for some message, the
display of that message might be less aesthetic than if the guideline
had been observed, but the @term{program} is still considered a
@term{conforming program}.

The requirements on a @term{program} or @term{implementation} which
invokes a @term{condition reporter} are somewhat stronger.  A @term{conforming
program} must be permitted to assume that if these style guidelines are
followed, proper aesthetics will be maintained.  Where appropriate, any
specific requirements on such routines are explicitly mentioned below.

@subsubsection Capitalization and Punctuation in Condition Reports


It is recommended that a @term{report message} be a complete sentences, in the
proper case and correctly punctuated.  In English, for example, this
means the first letter should be uppercase, and there should be a
trailing period.

@lisp
 (error "This is a message")  ; Not recommended
 (error "this is a message.") ; Not recommended

 (error "This is a message.") ; Recommended instead
@end lisp



@subsubsection Leading and Trailing Newlines in Condition Reports


It is recommended that a @term{report message} not begin with any
introductory text, such as ``@f{Error: }'' or ``@f{Warning: }''
or even just @term{freshline} or @term{newline}.
Such text is added, if appropriate to the context,
by the routine invoking the @term{condition reporter}.

It is recommended that a @term{report message} not be followed
by a trailing @term{freshline} or @term{newline}.
Such text is added, if appropriate to the context,
by the routine invoking the @term{condition reporter}.

@lisp
 (error "This is a message.~%")   ; Not recommended
 (error "~&This is a message.")   ; Not recommended
 (error "~&This is a message.~%") ; Not recommended

 (error "This is a message.")     ; Recommended instead
@end lisp



@subsubsection Embedded Newlines in Condition Reports


Especially if it is long, it is permissible and appropriate for
a @term{report message} to contain one or more embedded @term{newlines}.

If the calling routine conventionally inserts some additional prefix
(such as ``@f{Error: }'' or ``@f{;; Error: }'') on the first line of
the message, it must also assure that an appropriate prefix will be
added to each subsequent line of the output, so that the left edge of
the message output by the @term{condition reporter} will still be properly
aligned.

@lisp
 (defun test ()
   (error "This is an error message.~@percent{}It has two lines."))

 ;; Implementation A
 (test)
 This is an error message.
 It has two lines.

 ;; Implementation B
 (test)
 ;; Error: This is an error message.
 ;;        It has two lines.

 ;; Implementation C
 (test)
 >> Error: This is an error message.
           It has two lines.
@end lisp



@subsubsection Note about Tabs in Condition Reports


Because the indentation of a @term{report message} might be shifted to the right or
left by an arbitrary amount, special care should be taken with the
semi-standard @term{character} @TabChar{}@spc{}
(in those @term{implementations} that support such a @term{character}).
Unless the @term{implementation} specifically defines its behavior
in this context, its use should be avoided.


@subsubsection Mentioning Containing Function in Condition Reports


The name of the containing function should generally not be mentioned in
@term{report messages}.  It is assumed that the @term{debugger} will make this
information accessible in situations where it is necessary and appropriate.



@goodbreak{}
@node Signaling and Handling Conditions
@subsection Signaling and Handling Conditions

The operation of the condition system depends on the ordering of
active @term{applicable handlers} from most recent to least recent.

Each @term{handler} is associated with a @term{type specifier}
that must designate a @subtypeof{condition}.  A @term{handler}
is said to be @term{applicable} to a @term{condition} if that
@term{condition} is of the @term{type} designated by the associated
@term{type specifier}.

@term{Active} @term{handlers} are @term{established} by using
@code{handler-bind} (or an abstraction based on @code{handler-bind},
such as @code{handler-case} or @code{ignore-errors}).

@term{Active} @term{handlers} can be @term{established} within the
dynamic scope of other @term{active} @term{handlers}.
At any point during program execution, there is a set of @term{active} @term{handlers}.
When a @term{condition} is signaled, the @term{most recent} active @term{applicable handler}
for that @term{condition} is selected from this set.
Given a @term{condition}, the order of recentness of
active @term{applicable handlers} is defined by the following two rules:


@enumerate 1

@item Each handler in a set of active handlers @mat{H@sub1{}} is
more recent than every handler in a set @mat{H@sub2{}} if the
handlers in @mat{H@sub2{}} were active when the handlers in @mat{H@sub1{}} were
established.

@item Let @mat{h@sub1{}} and @mat{h@sub2{}} be two applicable active
handlers established by the same @term{form}. Then @mat{h@sub1{}} is
more recent than @mat{h@sub2{}} if @mat{h@sub1{}} was defined to the left of
@mat{h@sub2{}} in the @term{form} that established them.
@end enumerate


Once a handler in a handler binding @term{form} (such as
@code{handler-bind} or @code{handler-case}) has been selected, all
handlers in that @term{form} become inactive for
the remainder of the signaling process.
While the selected @term{handler} runs, no other @term{handler} established
by that @term{form} is active. That is, if the @term{handler} declines,
no other handler established by that @term{form} will be considered for possible invocation.

@Thenextfigure{}@spc{}shows @term{operators} relating to
the @term{handling} of @term{conditions}.


@float Figure,fig9.4
@cartouche
@multitable{handler-bind}{handler-case}{ignore-errors}

@item handler-bind @tab handler-case @tab ignore-errors
@end multitable
@end cartouche
@caption{Operators relating to handling conditions.}
@end float


@subsubsection Signaling
@anchor{Signaling}

When a @term{condition} is signaled, the most recent
applicable @term{active} @term{handler} is invoked.
Sometimes a handler will decline by simply returning
without a transfer of control.
In such cases, the next most recent applicable active handler is
invoked.

If there are no applicable handlers for a @term{condition} that
has been signaled, or if all applicable handlers decline, the
@term{condition} is unhandled.

The functions @code{cerror} and @code{error} invoke the
interactive @term{condition} handler (the debugger) rather than
return if the @term{condition} being signaled, regardless of
its @term{type}, is unhandled.  In contrast, @code{signal}
returns @nil{}@spc{}if the @term{condition} being signaled,
regardless of its @term{type}, is unhandled.

@Thevariable{*break-on-signals*} can be used to cause the
debugger to be entered before the signaling process begins.

@Thenextfigure{}@spc{}shows @term{defined names} relating to
the @term{signaling} of @term{conditions}.


@float Figure,fig9.5
@cartouche
@multitable{*break-on-signals*}{signal}{warn}

@item *break-on-signals* @tab error @tab warn
@item cerror @tab signal @tab
@end multitable
@end cartouche
@caption{Defined names relating to signaling conditions.}
@end float


@subsubsection Resignaling a Condition


During the @term{dynamic extent} of the @term{signaling} process for
a particular @term{condition} @term{object},
@code{signaling} the same @term{condition} @term{object} again
is permitted if and only if the @term{situation} represented in both
cases are the same.

For example, a @term{handler} might legitimately @term{signal}
the @term{condition} @term{object} that is its @term{argument}
in order to allow outer @term{handlers} first opportunity to @term{handle}
the condition.  (Such a @term{handlers} is sometimes called a ``default handler.'')
This action is permitted because the @term{situation} which the second
@term{signaling} process is addressing is really the same @term{situation}.

On the other hand, in an @term{implementation} that implemented asynchronous
keyboard events by interrupting the user process with a call to @code{signal},
it would not be permissible for two distinct asynchronous keyboard events
to @term{signal} @term{identical} @term{condition} @term{objects}
at the same time for different
situations.


@subsubsection Restarts
@anchor{Restarts}

The interactive condition handler returns only through
non-local transfer of control to specially defined @term{restarts}
that can be set up either by the system or by user code.  Transferring
control to a restart is called ``invoking'' the restart.  Like
handlers, active @term{restarts} are @term{established}
dynamically, and
only active @term{restarts}
can be invoked.  An active
@term{restart} can be invoked by the user from
the debugger or by a program by using @code{invoke-restart}.

A @term{restart} contains a
@term{function} to be @term{called} when the @term{restart} is
invoked, an optional name that can be used to find or invoke the
@term{restart}, and
an optional set of interaction information for the debugger to use to
enable the user to manually invoke a @term{restart}.

The name of a @term{restart} is
used by @code{invoke-restart}. @term{Restarts} that can be invoked
only within the debugger do not need names.

@term{Restarts} can be established by using @code{restart-bind},
@code{restart-case}, and @code{with-simple-restart}.
A @term{restart} function can itself invoke any other @term{restart}
that was active at the time of establishment of the @term{restart}
of which the @term{function} is part.

The @term{restarts} @term{established} by
a @code{restart-bind} @term{form},
a @code{restart-case} @term{form},
or a @code{with-simple-restart} @term{form}
have @term{dynamic extent}
which extends for the duration of that @term{form}'s execution.

@term{Restarts} of the same name can be ordered from least recent to
most recent according to the following two rules:


@enumerate 1

@item Each @term{restart} in a set of active restarts
@mat{R@sub1{}} is more recent than every @term{restart} in a
set @mat{R@sub2{}} if the @term{restarts}
in @mat{R@sub2{}} were active when the  @term{restarts} in @mat{R@sub1{}} were
established.

@item Let @mat{r@sub1{}} and @mat{r@sub2{}} be two active @term{restarts} with
the same name established by the same @term{form}. Then @mat{r@sub1{}} is
more recent than @mat{r@sub2{}} if @mat{r@sub1{}} was defined to the
left of @mat{r@sub2{}} in the @term{form} that established them.
@end enumerate


If a @term{restart} is invoked but does not transfer control,
the values resulting from the @term{restart} function are
returned by the function that invoked the restart, either
@code{invoke-restart} or @code{invoke-restart-interactively}.

@subsubsection Interactive Use of Restarts



For interactive handling, two pieces of information are needed
from a @term{restart}: a report function and an interactive function.

The report function
is used by a program such as the debugger to
present a description of the action the @term{restart} will take.
The report function is specified and established by the
@kwd{report-function} keyword to
@code{restart-bind} or the
@kwd{report} keyword to @code{restart-case}.

The interactive function, which can be specified using the
@kwd{interactive-function} keyword to
@code{restart-bind} or @kwd{interactive} keyword
to @code{restart-case}, is used when the @term{restart}
is invoked
interactively, such as from the debugger, to produce a suitable
list of arguments.

@code{invoke-restart} invokes the most recently @term{established}
@term{restart} whose
name is the same as the first argument to @code{invoke-restart}.
If a @term{restart} is invoked interactively by the debugger and  does
not transfer control but rather returns values, the precise
action of the debugger on those values is @term{implementation-defined}.


@subsubsection Interfaces to Restarts

@anchor{InterfacesToRestarts}

Some @term{restarts} have functional interfaces,
such as @code{abort}, @code{continue},
@code{muffle-warning}, @code{store-value}, and
@code{use-value}.
They are ordinary functions that use
@code{find-restart} and @code{invoke-restart} internally,
that have the same name as the @term{restarts} they manipulate,
and that are provided simply for notational convenience.

@Thenextfigure{}@spc{}shows @term{defined names} relating to
@term{restarts}.


@float Figure,fig9.6
@cartouche
@multitable{compute-restarts}{invoke-restart-interactively}{with-simple-restart}

@item abort @tab invoke-restart-interactively @tab store-value
@item compute-restarts @tab muffle-warning @tab use-value
@item continue @tab restart-bind @tab with-simple-restart
@item find-restart @tab restart-case @tab
@item invoke-restart @tab restart-name @tab
@end multitable
@end cartouche
@caption{Defined names relating to restarts.}
@end float



@subsubsection Restart Tests



Each @term{restart} has an associated test, which is a function of one
argument (a @term{condition} or @nil{}) which returns @term{true} if the @term{restart}
should be visible in the current @term{situation}.  This test is created by
the @kwd{test-function} option to @code{restart-bind} or
the @kwd{test} option to @code{restart-case}.


@subsubsection Associating a Restart with a Condition

@anchor{AssocRestartWithCond}

A @term{restart} can be ``associated with'' a @term{condition} explicitly
by @code{with-condition-restarts}, or implicitly by @code{restart-case}.
Such an assocation has @term{dynamic extent}.

A single @term{restart} may be associated with several @term{conditions}
at the same time.
A single @term{condition} may have several associated @term{restarts}
at the same time.

Active restarts associated with a particular @term{condition} can be detected
by @term{calling} a @term{function} such as @code{find-restart}, supplying
that @term{condition} as the @param{condition} @term{argument}.
Active restarts can also be detected without regard to any associated
@term{condition} by calling such a function without a @param{condition} @term{argument},
or by supplying a value of @nil{}@spc{}for such an @term{argument}.


@goodbreak{}
@node Assertions
@subsection Assertions

Conditional signaling of @term{conditions}
based on such things as key match, form evaluation,
and @term{type} are handled by assertion @term{operators}.
@Thenextfigure{}@spc{}shows @term{operators} relating to assertions.


@float Figure,fig9.7
@cartouche
@multitable{assert}{check-type}{etypecase}

@item assert @tab check-type @tab ecase
@item ccase @tab ctypecase @tab etypecase
@end multitable
@end cartouche
@caption{Operators relating to assertions.}
@end float



@node Notes about the Condition System's Background
@subsection Notes about the Condition System's Background

For a background reference to the abstract concepts detailed in this
section, see @CondSysPaper{}.  The details of that paper are not binding on
this document, but may be helpful in establishing a conceptual basis for
understanding this material.


@node condition
@heading condition (Condition Type)
@syindex condition
@cindex condition


@reviewer{Barrett: I think CONDITION-RESTARTS is not fully integrated.}

@subsubheading Class Precedence List:
@code{condition},
@code{t}

@subsubheading Description:

All types of @term{conditions}, whether error or
non-error, must inherit from this @term{type}.

No additional @term{subtype} relationships among the specified @subtypesof{condition}
are allowed, except when explicitly mentioned in the text; however
implementations are permitted to introduce additional @term{types}
and one of these @term{types} can be a @term{subtype} of any
number of the @subtypesof{condition}.

Whether a user-defined @term{condition} @term{type} has @term{slots}
that are accessible by @term{with-slots} is @term{implementation-dependent}.
Furthermore, even in an @term{implementation}
in which user-defined @term{condition} @term{types} would have @term{slots},
it is @term{implementation-dependent} whether any @term{condition}
@term{types} defined in this document have such @term{slots} or,
if they do, what their @term{names} might be;
only the reader functions documented by this specification may be relied
upon by portable code.

@term{Conforming code} must observe the following restrictions related to
@term{conditions}:


@itemize @bullet{}
@item
@code{define-condition}, not @code{defclass}, must be used
to define new @term{condition} @term{types}.

@item
@code{make-condition}, not @code{make-instance}, must be used to
create @term{condition} @term{objects} explicitly.

@item
The @kwd{report} option of @code{define-condition}, not @code{defmethod}
for @code{print-object}, must be used to define a condition reporter.

@item
@code{slot-value}, @code{slot-boundp}, @code{slot-makunbound},
and @code{with-slots} must not be used on @term{condition} @term{objects}.
Instead, the appropriate accessor functions (defined by @code{define-condition})
should be used.
@end itemize



@node warning
@heading warning (Condition Type)
@syindex warning
@cindex warning


@subsubheading Class Precedence List:
@code{warning},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{warning} consists of all types of warnings.

@subsubheading See Also:

@ref{style-warning}


@node style-warning
@heading style-warning (Condition Type)
@syindex style-warning
@cindex style-warning


@subsubheading Class Precedence List:
@code{style-warning},
@code{warning},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{style-warning} includes those @term{conditions}
that represent @term{situations} involving @term{code}
that is @term{conforming code} but that is nevertheless
considered to be faulty or substandard.

@subsubheading See Also:

@ref{muffle-warning}

@subsubheading Notes:

An @term{implementation} might signal such a @term{condition}
if it encounters @term{code}
that uses deprecated features
or that appears unaesthetic or inefficient.

An `unused variable' warning must be @oftype{style-warning}.

In general, the question of whether @term{code} is faulty or substandard
is a subjective decision to be made by the facility processing that @term{code}.
The intent is that whenever such a facility wishes to complain about
@term{code} on such subjective grounds, it should use this
@term{condition} @term{type} so that any clients who wish to redirect or
muffle superfluous warnings can do so without risking that they will be
redirecting or muffling other, more serious warnings.


@node serious-condition
@heading serious-condition (Condition Type)
@syindex serious-condition
@cindex serious-condition


@subsubheading Class Precedence List:
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

All @term{conditions} serious enough to require interactive intervention
if not handled should inherit from @thetype{serious-condition}.
This condition type is provided
primarily so that it may be included as
a @term{superclass} of other @term{condition} @term{types};
it is not intended to be signaled directly.

@subsubheading Notes:

Signaling a @term{serious condition} does not itself force entry into
the debugger.   However, except in the unusual situation where the
programmer can assure that no harm will come from failing to
@term{handle} a @term{serious condition}, such a @term{condition} is
usually signaled with @code{error} rather than @code{signal} in
order to assure that the program does not continue without
@term{handling} the @term{condition}.  (And conversely, it is
conventional to use @code{signal} rather than @code{error} to signal
conditions which are not @term{serious conditions}, since normally the
failure to handle a non-serious condition is not reason enough for the
debugger to be entered.)


@node error (Condition Type)
@heading error (Condition Type)
@syindex error
@cindex error


@subsubheading Class Precedence List:
@code{error},
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{error} consists of all @term{conditions} that represent @term{errors}.


@node cell-error
@heading cell-error (Condition Type)
@syindex cell-error
@cindex cell-error


@subsubheading Class Precedence List:
@code{cell-error},
@code{error},
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{cell-error} consists of error conditions that occur during
a location @term{access}.   The name of the offending cell is initialized by
@theinitkeyarg{name} to @code{make-condition},
and is @term{accessed} by @thefunction{cell-error-name}.

@subsubheading See Also:

@ref{cell-error-name}


@node cell-error-name
@heading cell-error-name (Function)
@syindex cell-error-name
@cindex cell-error-name



@subsubheading Syntax:

@DefunWithValues{cell-error-name, condition, name}

@subsubheading Arguments and Values:

@param{condition}---a @term{condition} @oftype{cell-error}.

@param{name}---an @term{object}.

@subsubheading Description:

Returns the @term{name} of the offending cell involved in the @term{situation}
represented by @param{condition}.

The nature of the result depends on the specific @term{type} of @param{condition}.
For example,
if the @param{condition} is @oftype{unbound-variable}, the result is
the @term{name} of the @term{unbound variable} which was being @term{accessed},
if the @param{condition} is @oftype{undefined-function}, this is
the @term{name} of the @term{undefined function} which was being @term{accessed},
and if the @param{condition} is @oftype{unbound-slot}, this is
the @term{name} of the @term{slot} which was being @term{accessed}.

@subsubheading See Also:

@ref{cell-error},
@ref{unbound-slot},
@ref{unbound-variable},
@ref{undefined-function},
@ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}



@node parse-error
@heading parse-error (Condition Type)
@syindex parse-error
@cindex parse-error



@subsubheading Class Precedence List:

@code{parse-error},
@code{error},
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{parse-error} consists of
error conditions that are related to parsing.

@subsubheading See Also:

@ref{parse-namestring},
@ref{reader-error}



@node storage-condition
@heading storage-condition (Condition Type)
@syindex storage-condition
@cindex storage-condition


@subsubheading Class Precedence List:
@code{storage-condition},
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{storage-condition} consists of serious conditions that
relate to problems with memory management that are potentially due to
@term{implementation-dependent} limits rather than semantic errors
in @term{conforming programs}, and that typically warrant entry to the
debugger if not handled.  Depending on the details of the @term{implementation},
these might include such problems as
stack overflow,
memory region overflow,
and
storage exhausted.

@subsubheading Notes:

While some @clisp{}@spc{}operations might signal @term{storage-condition}
because they are defined to create @term{objects},
it is unspecified whether operations that are not defined to create
@term{objects} create them anyway
and so might also signal @code{storage-condition}.
Likewise, the evaluator itself might create @term{objects}
and so might signal @code{storage-condition}.
(The natural assumption might be that such
@term{object} creation is naturally inefficient,
but even that is @term{implementation-dependent}.)
In general, the entire question of how storage allocation is done is
@term{implementation-dependent},
and so any operation might signal @code{storage-condition} at any time.
Because such a @term{condition} is indicative of a limitation
of the @term{implementation}
or of the @term{image}
rather than an error in a @term{program},
@term{objects} @oftype{storage-condition} are not @oftype{error}.


@node assert
@heading assert (Macro)
@syindex assert
@cindex assert


@subsubheading Syntax:

@DefmacWithValuesNewline{assert, test-form @brac{@paren{@starparam{place}} @brac{datum-form @starparam{argument-form}}}, @nil{}}

@subsubheading Arguments and Values:

@param{test-form}---a @term{form}; always evaluated.

@param{place}---a @term{place}; evaluated if an error is signaled.

@param{datum-form}---a @term{form} that evaluates to a @param{datum}.
Evaluated each time an error is to be signaled,
or not at all if no error is to be signaled.

@param{argument-form}---a @term{form} that evaluates to an @param{argument}.
Evaluated each time an error is to be signaled,
or not at all if no error is to be signaled.

@param{datum}, @param{arguments}---@term{designators} for a @term{condition}
of default type @code{error}.  (These @term{designators} are the
result of evaluating @param{datum-form} and each of the @param{argument-forms}.)

@subsubheading Description:

@code{assert} assures that @param{test-form} evaluates to @term{true}.
If @param{test-form} evaluates to @term{false}, @code{assert} signals a
@term{correctable} @term{error} (denoted by @param{datum} and @param{arguments}).
Continuing from this error using @therestart{continue} makes it possible
for the user to alter the values of the @param{places} before
@code{assert} evaluates @param{test-form} again.
If the value of @param{test-form} is @term{non-nil},
@code{assert} returns @nil{}.

The @param{places} are @term{generalized references} to data
upon which @param{test-form} depends,
whose values can be changed by the user in attempting to correct the error.
@term{Subforms} of each @param{place} are only evaluated if an error is signaled,
and might be re-evaluated if the error is re-signaled (after continuing without
actually fixing the problem).
The order of evaluation of the @param{places} is not specified;
see @ref{GenRefSubFormEval, Section 5.1.1.1 (Evaluation of Subforms to Places)}.
@cindex order of evaluation
@cindex evaluation order
If a @param{place} @term{form} is supplied that produces more values than there
are store variables, the extra values are ignored. If the supplied
@term{form} produces fewer values than there are store variables,
the missing values are set to @nil{}.

@subsubheading Examples:
@lisp
 (setq x (make-array '(3 5) :initial-element 3))
@EV{} #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
 (setq y (make-array '(3 5) :initial-element 7))
@EV{} #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
 (defun matrix-multiply (a b)
   (let ((*print-array* nil))
     (assert (and (= (array-rank a) (array-rank b) 2)
                  (= (array-dimension a 1) (array-dimension b 0)))
             (a b)
             "Cannot multiply ~S by ~S." a b)
            (really-matrix-multiply a b))) @EV{} MATRIX-MULTIPLY
 (matrix-multiply x y)
@OUT{} Correctable error in MATRIX-MULTIPLY:
@OUT{} Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
@OUT{} Restart options:
@OUT{}  1: You will be prompted for one or more new values.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Value for A: @IN{x}
@OUT{} Value for B: @IN{(make-array '(5 3) :initial-element 6)}
@EV{} #2A((54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54))
@end lisp


@lisp
 (defun double-safely (x) (assert (numberp x) (x)) (+ x x))
 (double-safely 4)
@EV{} 8

 (double-safely t)
@OUT{} Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
@OUT{} Restart options:
@OUT{}  1: You will be prompted for one or more new values.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Value for X: @IN{7}
@EV{} 14
@end lisp


@subsubheading Affected By:

@code{*break-on-signals*}

The set of active @term{condition handlers}.

@subsubheading See Also:

@ref{check-type}, @ref{error (Function)}, @ref{Generalized Reference, Section 5.1 (Generalized Reference)}

@subsubheading Notes:

The debugger need not include the @param{test-form} in the error message,
and the @param{places} should not be included in the message, but they
should be made available for the user's perusal.  If the user gives the
``continue'' command, the values of any of the references can be altered.
The details of this depend on the implementation's style of user interface.

@node error (Function)
@heading error (Function)
@syindex error
@cindex error


@subsubheading Syntax:

@DefunNoReturn{error, datum @rest{} arguments}

@subsubheading Arguments and Values:

@param{datum}, @param{arguments}---@term{designators} for a @term{condition}
of default type @code{simple-error}.

@subsubheading Description:

@code{error} effectively invokes @code{signal} on the denoted @term{condition}.

If the @term{condition} is not handled, @f{(invoke-debugger @i{condition})} is done.
As a consequence of calling @code{invoke-debugger}, @code{error}
cannot directly return; the only exit from @code{error}
can come by non-local transfer of control in a handler or by use of
an interactive debugging command.

@subsubheading Examples:

@lisp
 (defun factorial (x)
   (cond ((or (not (typep x 'integer)) (minusp x))
          (error "~S is not a valid argument to FACTORIAL." x))
         ((zerop x) 1)
         (t (* x (factorial (- x 1))))))
@EV{} FACTORIAL
(factorial 20)
@EV{} 2432902008176640000
(factorial -1)
@OUT{} Error: -1 is not a valid argument to FACTORIAL.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return to Lisp Toplevel.
@OUT{} Debug>
@end lisp


@lisp
 (setq a 'fred)
@EV{} FRED
 (if (numberp a) (1+ a) (error "~S is not a number." A))
@OUT{} Error: FRED is not a number.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return to Lisp Toplevel.
@OUT{} Debug> @IN{:Continue 1}
@OUT{} Return to Lisp Toplevel.

 (define-condition not-a-number (error)
                   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))
@EV{} NOT-A-NUMBER

 (if (numberp a) (1+ a) (error 'not-a-number :argument a))
@OUT{} Error: FRED is not a number.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return to Lisp Toplevel.
@OUT{} Debug> @IN{:Continue 1}
@OUT{} Return to Lisp Toplevel.
@end lisp


@subsubheading Side Effects:

@term{Handlers} for the specified condition, if any, are invoked
and might have side effects.
Program execution might stop, and the debugger might be entered.

@subsubheading Affected By:

Existing handler bindings.

@code{*break-on-signals*}

@Checktypes{@param{datum} and @param{arguments}, @term{designators} for a @term{condition}}

@subsubheading See Also:

@ref{cerror}, @ref{signal}, @ref{format},
@ref{ignore-errors}, @ref{*break-on-signals*},
@ref{handler-bind}, @ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}

@subsubheading Notes:

Some implementations may provide debugger
commands for interactively returning from individual stack frames.
However, it should be possible for the programmer to feel confident
about writing code like:

@lisp
 (defun wargames:no-win-scenario ()
   (if (error "pushing the button would be stupid."))
   (push-the-button))
@end lisp

In this scenario, there should be no chance that
@code{error} will return
and the button will get pushed.

While the meaning of this program is clear and it might be proven `safe'
by a formal theorem prover, such a proof is no guarantee that the
program is safe to execute.  Compilers have been known to have bugs,
computers to have signal glitches, and human beings to manually
intervene in ways that are not always possible to predict.  Those kinds
of errors, while beyond the scope of the condition system to formally
model, are not beyond the scope of things that should seriously be
considered when writing code that could have the kinds of sweeping
effects hinted at by this example.


@node cerror
@heading cerror (Function)
@syindex cerror
@cindex cerror


@subsubheading Syntax:

@DefunWithValues{cerror, continue-format-control datum @rest{} arguments, @nil{}}

@subsubheading Arguments and Values:

@param{Continue-format-control}---a @term{format control}.

@reviewer{Barmar: What is continue-format-control used for??}

@param{datum}, @param{arguments}---@term{designators} for a @term{condition}
of default type @code{simple-error}.

@subsubheading Description:

@code{cerror} effectively invokes @code{error} on the
@term{condition} named by @param{datum}.  As with any function that
implicitly calls @code{error}, if the @term{condition} is not handled,
@f{(invoke-debugger @i{condition})} is executed.  While signaling is going on,
and while in the debugger if it is reached, it is possible to continue
code execution (@ie{} to return from @code{cerror}) using @therestart{continue}.

If @param{datum} is a @term{condition}, @param{arguments} can be supplied,
but are used only in conjunction with the @param{continue-format-control}.

@subsubheading Examples:

@lisp
 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4)
@EV{} 2.0

 (real-sqrt -9)
@OUT{} Correctable error in REAL-SQRT: Tried to take sqrt(-9).
@OUT{} Restart options:
@OUT{}  1: Return sqrt(9) instead.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@EV{} 3.0

 (define-condition not-a-number (error)
   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))

 (defun assure-number (n)
   (loop (when (numberp n) (return n))
         (cerror "Enter a number."
                 'not-a-number :argument n)
         (format t "~&Type a number: ")
         (setq n (read))
         (fresh-line)))

 (assure-number 'a)
@OUT{} Correctable error in ASSURE-NUMBER: A is not a number.
@OUT{} Restart options:
@OUT{}  1: Enter a number.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Type a number: @IN{1/2}
@EV{} 1/2

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~:[~; a bit larger than ~D~]."
                 "~*~A is not a large number."
                 (numberp n) n)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))

 (assure-large-number 10000)
@EV{} 10000

 (assure-large-number 'a)
@OUT{} Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
@OUT{} Restart options:
@OUT{}  1: Enter a number.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Type a large number: @IN{88}
@EV{} 88

 (assure-large-number 37)
@OUT{} Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
@OUT{} Restart options:
@OUT{}  1: Enter a number a bit larger than 37.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Type a large number: @IN{259}
@EV{} 259

 (define-condition not-a-large-number (error)
   ((argument :reader not-a-large-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a large number."
                      (not-a-large-number-argument condition)))))

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
                 'not-a-large-number
                 :argument n
                 :ignore (numberp n)
                 :ignore n
                 :allow-other-keys t)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))


 (assure-large-number 'a)
@OUT{} Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
@OUT{} Restart options:
@OUT{}  1: Enter a number.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Type a large number: @IN{88}
@EV{} 88

 (assure-large-number 37)
@OUT{} Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
@OUT{} Restart options:
@OUT{}  1: Enter a number a bit larger than 37.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Type a large number: @IN{259}
@EV{} 259
@end lisp


@subsubheading Affected By:

@code{*break-on-signals*}.

Existing handler bindings.

@subsubheading See Also:

@ref{error (Function)}, @ref{format}, @ref{handler-bind},
@ref{*break-on-signals*}, @ref{simple-type-error}

@subsubheading Notes:

If @param{datum} is a @term{condition} @term{type} rather than a
@term{string}, the @code{format} directive @tt{ @tild{}*} may be especially
useful in the @param{continue-format-control} in order to ignore the
@term{keywords} in the @term{initialization argument list}.  For example:

@lisp
(cerror "enter a new value to replace ~*~s"
        'not-a-number
        :argument a)
@end lisp



@node check-type
@heading check-type (Macro)
@syindex check-type
@cindex check-type


@subsubheading Syntax:

@DefmacWithValues{check-type, place typespec @brac{@param{string}}, @nil{}}

@subsubheading Arguments and Values:

@param{place}---a @term{place}.

@param{typespec}---a @term{type specifier}.

@param{string}---a @term{string}; @eval{}.

@subsubheading Description:

@code{check-type} signals a @term{correctable} @term{error}
@oftype{type-error} if the contents of @param{place} are not
of the type @param{typespec}.

@code{check-type} can return only if @therestart{store-value} is invoked,
either explicitly from a handler
or implicitly as one of the options offered by the debugger.
If @therestart{store-value} is invoked,
@code{check-type} stores the new value
that is the argument to the @term{restart} invocation
(or that is prompted for interactively by the debugger)
in @param{place} and starts over,
checking the type of the new value
and signaling another error if it is still not of the desired @term{type}.

The first time @param{place} is @term{evaluated},
it is @term{evaluated} by normal evaluation rules.
It is later @term{evaluated} as a @term{place}
if the type check fails and @therestart{store-value} is used;
see @ref{GenRefSubFormEval, Section 5.1.1.1 (Evaluation of Subforms to Places)}.

@term{string} should be an English description of the type,
starting with an indefinite article (``a'' or ``an'').
If @term{string} is not supplied,
it is computed automatically from @param{typespec}.
The automatically generated message mentions
@param{place},
its contents,
and the desired type.
An implementation may choose to generate
a somewhat differently worded error message
if it recognizes that @param{place} is of a particular form,
such as one of the arguments to the function that called @code{check-type}.
@term{string} is allowed because some applications of @code{check-type}
may require a more specific description of what is wanted
than can be generated automatically from @param{typespec}.

@subsubheading Examples:

@lisp
 (setq aardvarks '(sam harry fred))
@EV{} (SAM HARRY FRED)
 (check-type aardvarks (array * (3)))
@OUT{} Error: The value of AARDVARKS, (SAM HARRY FRED),
@OUT{}        is not a 3-long array.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a value to use instead.
@OUT{}  2: Return to Lisp Toplevel.
@OUT{} Debug> @IN{:CONTINUE 1}
@OUT{} Use Value: @IN{#(SAM FRED HARRY)}
@EV{} NIL
 aardvarks
@EV{} #<ARRAY-T-3 13571>
 (map 'list #'identity aardvarks)
@EV{} (SAM FRED HARRY)
 (setq aardvark-count 'foo)
@EV{} FOO
 (check-type aardvark-count (integer 0 *) "A positive integer")
@OUT{} Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a value to use instead.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:CONTINUE 2}
@end lisp


@lisp
 (defmacro define-adder (name amount)
   (check-type name (and symbol (not null)) "a name for an adder function")
   (check-type amount integer)
   `(defun ,name (x) (+ x ,amount)))

 (macroexpand '(define-adder add3 3))
@EV{} (defun add3 (x) (+ x 3))

 (macroexpand '(define-adder 7 7))
@OUT{} Error: The value of NAME, 7, is not a name for an adder function.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a value to use instead.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:Continue 1}
@OUT{} Specify a value to use instead.
@OUT{} Type a form to be evaluated and used instead: @IN{'ADD7}
@EV{} (defun add7 (x) (+ x 7))

 (macroexpand '(define-adder add5 something))
@OUT{} Error: The value of AMOUNT, SOMETHING, is not an integer.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a value to use instead.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:Continue 1}
@OUT{} Type a form to be evaluated and used instead: @IN{5}
@EV{} (defun add5 (x) (+ x 5))

@end lisp


Control is transferred to a handler.

@subsubheading Side Effects:

The debugger might be entered.

@subsubheading Affected By:

@code{*break-on-signals*}

The implementation.

@subsubheading See Also:

@ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}

@subsubheading Notes:

@lisp
 (check-type @param{place} @param{typespec})
 @EQ{} (assert (typep @param{place} '@param{typespec}) (@param{place})
            'type-error :datum @param{place} :expected-type '@param{typespec})
@end lisp



@node simple-error
@heading simple-error (Condition Type)
@syindex simple-error
@cindex simple-error


@subsubheading Class Precedence List:

@code{simple-error},
@code{simple-condition},
@code{error},
@code{serious-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{simple-error} consists of @term{conditions} that
are signaled by @code{error} or @code{cerror} when a
@term{format control}
is supplied as the function's first argument.


@node invalid-method-error
@heading invalid-method-error (Function)
@syindex invalid-method-error
@cindex invalid-method-error


@subsubheading Syntax:

@DefunWithValues{invalid-method-error, method format-control @rest{} args, @term{implementation-dependent}}

@subsubheading Arguments and Values:

@param{method}---a @term{method}.

@param{format-control}---a @term{format control}.

@param{args}---@term{format arguments} for the @param{format-control}.

@subsubheading Description:

@Thefunction{invalid-method-error} is used to signal an error @oftype{error}
when there is an applicable @term{method} whose @term{qualifiers} are not valid for
the method combination type.  The error message is constructed by
using the @param{format-control} suitable for @code{format}
and any @param{args} to it.  Because an
implementation may need to add additional contextual information to
the error message, @code{invalid-method-error} should be called only
within the dynamic extent of a method combination function.

@Thefunction{invalid-method-error} is called automatically when a
@term{method} fails to satisfy every @term{qualifier} pattern and predicate in a
@code{define-method-combination} @term{form}.  A method combination function
that imposes additional restrictions should call
@code{invalid-method-error} explicitly if it encounters a @term{method}
it cannot accept.

Whether @code{invalid-method-error} returns to its caller or exits via
@code{throw} is @term{implementation-dependent}.

@subsubheading Side Effects:

The debugger might be entered.

@subsubheading Affected By:

@code{*break-on-signals*}

@subsubheading See Also:

@ref{define-method-combination}


@node method-combination-error
@heading method-combination-error (Function)
@syindex method-combination-error
@cindex method-combination-error


@subsubheading Syntax:

@DefunWithValues{method-combination-error, format-control @rest{} args, @term{implementation-dependent}}

@subsubheading Arguments and Values:

@param{format-control}---a @term{format control}.

@param{args}---@term{format arguments} for @param{format-control}.

@subsubheading Description:

@Thefunction{method-combination-error} is used to signal an error
in method combination.

The error message is constructed by using a @param{format-control} suitable
for @code{format} and any @param{args} to it.  Because an implementation may
need to add additional contextual information to the error message,
@code{method-combination-error} should be called only within the
dynamic extent of a method combination function.

Whether @code{method-combination-error} returns to its caller or exits
via @code{throw} is @term{implementation-dependent}.

@subsubheading Side Effects:

The debugger might be entered.

@subsubheading Affected By:

@code{*break-on-signals*}

@subsubheading See Also:

@ref{define-method-combination}


@node signal
@heading signal (Function)
@syindex signal
@cindex signal


@subsubheading Syntax:

@DefunWithValues{signal, datum @rest{} arguments, @nil{}}

@subsubheading Arguments and Values:

@param{datum}, @param{arguments}---@term{designators} for a @term{condition}
of default type @code{simple-condition}.

@subsubheading Description:

@term{Signals} the @term{condition} denoted by the given @param{datum} and @param{arguments}.
If the @term{condition} is not handled, @code{signal} returns @nil{}.

@subsubheading Examples:

@lisp
 (defun handle-division-conditions (condition)
   (format t "Considering condition for division condition handling~%")
   (when (and (typep condition 'arithmetic-error)
              (eq '/ (arithmetic-error-operation condition)))
     (invoke-debugger condition)))
HANDLE-DIVISION-CONDITIONS
 (defun handle-other-arithmetic-errors (condition)
   (format t "Considering condition for arithmetic condition handling~%")
   (when (typep condition 'arithmetic-error)
     (abort)))
HANDLE-OTHER-ARITHMETIC-ERRORS
 (define-condition a-condition-with-no-handler (condition) ())
A-CONDITION-WITH-NO-HANDLER
 (signal 'a-condition-with-no-handler)
NIL
 (handler-bind ((condition #'handle-division-conditions)
                  (condition #'handle-other-arithmetic-errors))
   (signal 'a-condition-with-no-handler))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
NIL
 (handler-bind ((arithmetic-error #'handle-division-conditions)
                  (arithmetic-error #'handle-other-arithmetic-errors))
   (signal 'arithmetic-error :operation '* :operands '(1.2 b)))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
Back to Lisp Toplevel
@end lisp


@subsubheading Side Effects:

The debugger might be entered due to @code{*break-on-signals*}.

Handlers for the condition being signaled might transfer control.

@subsubheading Affected By:

Existing handler bindings.

@code{*break-on-signals*}

@subsubheading See Also:

@ref{*break-on-signals*},
@ref{error (Function)},
@ref{simple-condition},
@ref{Signaling and Handling Conditions, Section 9.1.4 (Signaling and Handling Conditions)}

@subsubheading Notes:

If @f{(typep @param{datum} *break-on-signals*)} @term{yields} @term{true},
the debugger is entered prior to beginning the signaling process.
@Therestart{continue} can be used to continue with the signaling process.
This is also true for all other @term{functions} and @term{macros} that
should, might, or must @term{signal} @term{conditions}.


@node simple-condition
@heading simple-condition (Condition Type)
@syindex simple-condition
@cindex simple-condition


@subsubheading Class Precedence List:
@code{simple-condition},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{simple-condition} represents @term{conditions} that are
signaled by @code{signal} whenever a @param{format-control} is
supplied as the function's first argument.
The @term{format control} and @term{format arguments} are initialized with
@theinitkeyargs{format-control}
and @kwd{format-arguments} to @code{make-condition}, and are
@term{accessed} by the @term{functions}
@code{simple-condition-format-control}
and @code{simple-condition-format-arguments}.
If format arguments are not supplied to @code{make-condition},
@nil{}@spc{}is used as a default.

@subsubheading See Also:

@ref{simple-condition-format-control},
@ref{simple-condition-format-arguments}


@node simple-condition-format-control; simple-condition-format-arguments
@heading simple-condition-format-control, simple-condition-format-arguments (Function)
@syindex simple-condition-format-control
@cindex simple-condition-format-control
@syindex simple-condition-format-arguments
@cindex simple-condition-format-arguments
@anchor{simple-condition-format-control}
@anchor{simple-condition-format-arguments}



@subsubheading Syntax:

@DefunWithValues{simple-condition-format-control, condition, format-control}
@DefunWithValues{simple-condition-format-arguments, condition, format-arguments}

@subsubheading Arguments and Values:

@param{condition}---a @term{condition} of @term{type} @code{simple-condition}.

@param{format-control}---a @term{format control}.

@param{format-arguments}---a @term{list}.

@subsubheading Description:

@code{simple-condition-format-control} returns the @term{format control} needed to
process the @param{condition}'s @term{format arguments}.

@code{simple-condition-format-arguments} returns a @term{list} of @term{format arguments}
needed to process the @param{condition}'s @term{format control}.

@subsubheading Examples:

@lisp
 (setq foo (make-condition 'simple-condition
                          :format-control "Hi ~S"
                          :format-arguments '(ho)))
@EV{} #<SIMPLE-CONDITION 26223553>
 (apply #'format nil (simple-condition-format-control foo)
                     (simple-condition-format-arguments foo))
@EV{} "Hi HO"
@end lisp


@subsubheading See Also:

@ref{simple-condition},
@ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}



@node warn
@heading warn (Function)
@syindex warn
@cindex warn


@subsubheading Syntax:

@DefunWithValues{warn, datum @rest{} arguments, @nil{}}

@subsubheading Arguments and Values:

@param{datum}, @param{arguments}---@term{designators} for a @term{condition}
of default type @code{simple-warning}.

@subsubheading Description:

@term{Signals} a @term{condition} @oftype{warning}.
If the @term{condition} is not @term{handled},
reports the @term{condition} to @term{error output}.

The precise mechanism for warning is as follows:



@table @asis

@item @id{@bf{The warning condition is signaled}}


While the @code{warning} @term{condition} is being signaled,
@therestart{muffle-warning} is established for use by a @term{handler}.
If invoked, this @term{restart} bypasses further action by @code{warn},
which in turn causes @code{warn} to immediately return @nil{}.

@item @id{@bf{If no handler for the warning condition is found}}


If no handlers for the warning condition are found,
or if all such handlers decline,
then the @term{condition} is reported to @term{error output}
by @code{warn} in an @term{implementation-dependent} format.

@item @id{@bf{@nil{}@spc{}is returned}}


The value returned by @code{warn} if it returns is @nil{}.
@end table


@subsubheading Examples:

@lisp
  (defun foo (x)
    (let ((result (* x 2)))
      (if (not (typep result 'fixnum))
          (warn "You're using very big numbers."))
      result))
@EV{} FOO

  (foo 3)
@EV{} 6

  (foo most-positive-fixnum)
@OUT{} Warning: You're using very big numbers.
@EV{} 4294967294

  (setq *break-on-signals* t)
@EV{} T

  (foo most-positive-fixnum)
@OUT{} Break: Caveat emptor.
@OUT{} To continue, type :CONTINUE followed by an option number.
@OUT{}  1: Return from Break.
@OUT{}  2: Abort to Lisp Toplevel.
@OUT{} Debug> :continue 1
@OUT{} Warning: You're using very big numbers.
@EV{} 4294967294
@end lisp


@subsubheading Side Effects:

A warning is issued.  The debugger might be entered.

@subsubheading Affected By:

Existing handler bindings.

@code{*break-on-signals*},
@code{*error-output*}.

@subsubheading Exceptional Situations:

If @param{datum} is a @term{condition}
and if the @term{condition} is not @oftype{warning},
or @param{arguments} is @term{non-nil}, an error @oftype{type-error} is signaled.

If @param{datum} is a condition type,
the result of @tt{(apply #'make-condition datum arguments)}
must be @oftype{warning} or an error @oftype{type-error} is signaled.

@subsubheading See Also:

@ref{*break-on-signals*},
@ref{muffle-warning},
@ref{signal}


@node simple-warning
@heading simple-warning (Condition Type)
@syindex simple-warning
@cindex simple-warning


@subsubheading Class Precedence List:

@code{simple-warning},
@code{simple-condition},
@code{warning},
@code{condition},
@code{t}

@subsubheading Description:

@Thetype{simple-warning} represents @term{conditions} that
are signaled by @code{warn} whenever a
@term{format control}
is supplied as the function's first argument.


@node invoke-debugger
@heading invoke-debugger (Function)
@syindex invoke-debugger
@cindex invoke-debugger


@subsubheading Syntax:

@DefunNoReturn{invoke-debugger, condition}

@subsubheading Arguments and Values:

@param{condition}---a @term{condition} @term{object}.

@subsubheading Description:

@code{invoke-debugger} attempts to enter the debugger with @param{condition}.

If @code{*debugger-hook*} is not @nil{}, it should be a @term{function}
(or the name of a @term{function}) to be called prior to entry to
the standard debugger.  The @term{function} is called with
@code{*debugger-hook*} bound to @nil{}, and the @term{function}
must accept two arguments: the @param{condition}
and @thevalueof{*debugger-hook*} prior to binding it to @nil{}.
If the @term{function} returns normally,
the standard debugger is entered.

The standard debugger never directly returns.  Return can occur only by a
non-local transfer of control, such as the use of a restart function.

@subsubheading Examples:

@lisp
 (ignore-errors ;Normally, this would suppress debugger entry
   (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry
     (error "Foo.")))
Debug: Foo.
To continue, type :CONTINUE followed by an option number:
 1: Return to Lisp Toplevel.
Debug>
@end lisp



@subsubheading Side Effects:

@code{*debugger-hook*} is bound to @nil{},
program execution is discontinued,
and the debugger is entered.

@subsubheading Affected By:

@code{*debug-io*} and @code{*debugger-hook*}.

@subsubheading See Also:

@ref{error (Function)}, @ref{break}


@node break
@heading break (Function)
@syindex break
@cindex break


@subsubheading Syntax:

@DefunWithValues{break, @opt{} format-control @rest{} format-arguments, @nil{}}

@subsubheading Arguments and Values:

@param{format-control}---a @term{format control}.
@Default{@term{implementation-dependent}}

@param{format-arguments}---@term{format arguments} for the @param{format-control}.

@subsubheading Description:

@code{break} @term{formats} @param{format-control} and @param{format-arguments}
and then goes directly into the debugger without allowing any possibility of
interception by programmed error-handling facilities.

If @therestart{continue} is used while in the debugger,
@code{break} immediately returns @nil{}@spc{}without taking any unusual recovery action.

@code{break} binds @code{*debugger-hook*} to @nil{}@spc{}
before attempting to enter the debugger.

@subsubheading Examples:

@lisp
 (break "You got here with arguments: ~:S." '(FOO 37 A))
@OUT{} BREAK: You got here with these arguments: FOO, 37, A.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return from BREAK.
@OUT{}  2: Top level.
@OUT{} Debug> :CONTINUE 1
@OUT{} Return from BREAK.
@EV{} NIL

@end lisp


@subsubheading Side Effects:

The debugger is entered.

@subsubheading Affected By:

@code{*debug-io*}.

@subsubheading See Also:

@ref{error (Function)}, @ref{invoke-debugger}.

@subsubheading Notes:

@code{break} is used as a way of inserting temporary debugging
``breakpoints'' in a program, not as a way of signaling errors.
For this reason, @code{break} does not take the @param{continue-format-control}
@term{argument} that @code{cerror} takes.
This and the lack of any possibility of interception by
@term{condition} @term{handling} are the only program-visible
differences between @code{break} and @code{cerror}.

The user interface aspects of @code{break} and @code{cerror} are
permitted to vary more widely, in order to accomodate the interface
needs of the @term{implementation}. For example, it is permissible for a
@term{Lisp read-eval-print loop} to be entered by @code{break} rather
than the conventional debugger.

@code{break} could be defined by:

@lisp
 (defun break (&optional (format-control "Break") &rest format-arguments)
   (with-simple-restart (continue "Return from BREAK.")
     (let ((*debugger-hook* nil))
       (invoke-debugger
           (make-condition 'simple-condition
                           :format-control format-control
                           :format-arguments format-arguments))))
   nil)
@end lisp



@node *debugger-hook*
@heading *debugger-hook* (Variable)
@syindex *debugger-hook*
@cindex *debugger-hook*


@subsubheading Value Type:

a @term{designator} for a @term{function} of two @term{arguments}
(a @term{condition} and @thevalueof{*debugger-hook*} at the time
the debugger was entered),
or @nil{}.

@subsubheading Initial Value:

@nil{}.

@subsubheading Description:

When @thevalueof{*debugger-hook*} is @term{non-nil}, it is called prior to
normal entry into the debugger, either due to a call to @code{invoke-debugger}
or due to automatic entry into the debugger from a call to @code{error}
or @code{cerror} with a condition that is not handled.
The @term{function} may either handle the @term{condition}
(transfer control) or return normally (allowing the standard debugger to run).
To minimize recursive errors while debugging,
@code{*debugger-hook*} is bound to @nil{}@spc{}by @code{invoke-debugger}
prior to calling the @term{function}.

@subsubheading Examples:

@lisp
 (defun one-of (choices &optional (prompt "Choice"))
   (let ((n (length choices)) (i))
     (do ((c choices (cdr c)) (i 1 (+ i 1)))
         ((null c))
       (format t "~&[~D] ~A~%" i (car c)))
     (do () ((typep i `(integer 1 ,n)))
       (format t "~&~A: " prompt)
       (setq i (read))
       (fresh-line))
     (nth (- i 1) choices)))

 (defun my-debugger (condition me-or-my-encapsulation)
   (format t "~&Fooey: ~A" condition)
   (let ((restart (one-of (compute-restarts))))
     (if (not restart) (error "My debugger got an error."))
     (let ((*debugger-hook* me-or-my-encapsulation))
       (invoke-restart-interactively restart))))

 (let ((*debugger-hook* #'my-debugger))
   (+ 3 'a))
@OUT{} Fooey: The argument to +, A, is not a number.
@OUT{}  [1] Supply a replacement for A.
@OUT{}  [2] Return to Cloe Toplevel.
@OUT{} Choice: 1
@OUT{}  Form to evaluate and use: (+ 5 'b)
@OUT{}  Fooey: The argument to +, B, is not a number.
@OUT{}  [1] Supply a replacement for B.
@OUT{}  [2] Supply a replacement for A.
@OUT{}  [3] Return to Cloe Toplevel.
@OUT{} Choice: 1
@OUT{}  Form to evaluate and use: 1
@EV{} 9
@end lisp


@subsubheading Affected By:

@code{invoke-debugger}

@subsubheading Notes:

When evaluating code typed in by the user interactively, it is sometimes
useful to have the hook function bind @code{*debugger-hook*} to the
@term{function} that was its second argument so that recursive errors
can be handled using the same interactive facility.


@node *break-on-signals*
@heading *break-on-signals* (Variable)
@syindex *break-on-signals*
@cindex *break-on-signals*


@subsubheading Value Type:

a @term{type specifier}.

@subsubheading Initial Value:

@nil{}.

@subsubheading Description:

When @f{(typep @i{condition} *break-on-signals*)} returns @term{true},
calls to @code{signal}, and to other @term{operators} such as @code{error}
that implicitly call @code{signal}, enter the debugger prior to
@term{signaling} the @term{condition}.

@Therestart{continue} can be used to continue with the normal
@term{signaling} process when a break occurs process due to
@code{*break-on-signals*}.

@subsubheading Examples:

@lisp
 *break-on-signals* @EV{} NIL
 (ignore-errors (error 'simple-error :format-control "Fooey!"))
@EV{} NIL, #<SIMPLE-ERROR 32207172>

 (let ((*break-on-signals* 'error))
   (ignore-errors (error 'simple-error :format-control "Fooey!")))
@OUT{} Break: Fooey!
@OUT{} BREAK entered because of *BREAK-ON-SIGNALS*.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Continue to signal.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:CONTINUE 1}
@OUT{} Continue to signal.
@EV{} NIL, #<SIMPLE-ERROR 32212257>

 (let ((*break-on-signals* 'error))
   (error 'simple-error :format-control "Fooey!"))
@OUT{} Break: Fooey!
@OUT{} BREAK entered because of *BREAK-ON-SIGNALS*.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Continue to signal.
@OUT{}  2: Top level.
@OUT{} Debug> @IN{:CONTINUE 1}
@OUT{} Continue to signal.
@OUT{} Error: Fooey!
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Top level.
@OUT{} Debug> @IN{:CONTINUE 1}
@OUT{} Top level.
@end lisp


@subsubheading See Also:

@ref{break},
@ref{signal}, @ref{warn}, @ref{error (Function)},
@ref{typep},
@ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}

@subsubheading Notes:

@code{*break-on-signals*} is intended primarily for use in debugging code that
does signaling.   When setting @code{*break-on-signals*}, the user is
encouraged to choose the most restrictive specification that suffices.
Setting @code{*break-on-signals*} effectively violates the modular handling of
@term{condition} signaling.  In practice, the complete effect of setting
@code{*break-on-signals*} might be unpredictable in some cases since the user
might not be aware of the variety or number of calls to @code{signal}
that are used in code called only incidentally.


@code{*break-on-signals*} enables an early entry to the debugger but such an
entry does not preclude an additional entry to the debugger in the case of
operations such as @code{error} and @code{cerror}.


@node handler-bind
@heading handler-bind (Macro)
@syindex handler-bind
@cindex handler-bind


@subsubheading Syntax:

@DefmacWithValues{handler-bind, @paren{@stardown{binding}}  @starparam{form}, @starparam{result}}

@auxbnf{binding, @paren{type handler}}

@subsubheading Arguments and Values:

@param{type}---a @term{type specifier}.

@param{handler}---a @term{form}; evaluated to produce a @param{handler-function}.

@param{handler-function}---a @term{designator} for a @term{function} of one @term{argument}.

@param{forms}---an @term{implicit progn}.

@param{results}---the @term{values} returned by the @term{forms}.

@subsubheading Description:

Executes @param{forms} in a @term{dynamic environment} where the indicated
@param{handler} @term{bindings} are in effect.

Each @param{handler} should evaluate to a @term{handler-function},
which is used to handle @term{conditions} of the given @param{type}
during execution of the @param{forms}.  This @term{function} should
take a single argument, the @term{condition} being signaled.

If more than one @param{handler} @term{binding} is supplied,
the @param{handler} @term{bindings} are searched sequentially from
top to bottom in search of a match (by visual analogy with @code{typecase}).
If an appropriate @term{type} is found,
the associated handler is run in a @term{dynamic environment} where none of these
@param{handler} bindings are visible (to avoid recursive errors).
If the @term{handler} @term{declines}, the search continues for another @term{handler}.

If no appropriate @term{handler} is found, other @term{handlers} are sought
from dynamically enclosing contours.  If no @term{handler} is found outside,
then @code{signal} returns or @code{error} enters the debugger.

@subsubheading Examples:


In the following code, if an unbound variable error is
signaled in the body (and not handled by an intervening handler),
the first function is called.

@lisp
 (handler-bind ((unbound-variable #'(lambda ...))
                (error #'(lambda ...)))
   ...)
@end lisp


If any other kind of error is signaled, the second function is called.
In either case, neither handler is active while executing the code
in the associated function.

@lisp
 (defun trap-error-handler (condition)
   (format *error-output* "~&~A~&" condition)
   (throw 'trap-errors nil))

 (defmacro trap-errors (&rest forms)
   `(catch 'trap-errors
      (handler-bind ((error #'trap-error-handler))
        ,@@forms)))

 (list (trap-errors (signal "Foo.") 1)
       (trap-errors (error  "Bar.") 2)
       (+ 1 2))
@OUT{} Bar.
@EV{} (1 NIL 3)
@end lisp


Note that ``Foo.'' is not printed because the condition made
by @code{signal} is a @term{simple condition}, which is not @oftype{error},
so it doesn't trigger the handler for @code{error} set up by @f{trap-errors}.

@subsubheading See Also:

@ref{handler-case}


@node handler-case
@heading handler-case (Macro)
@syindex handler-case
@cindex handler-case



@subsubheading Syntax:

@DefmacWithValues{handler-case, @param{expression} @interleave{@stardown{error-clause} | @down{no-error-clause}}, @starparam{result}}

@auxbnf{clause, @down{error-clause} | @down{no-error-clause}}
@auxbnf{error-clause, @paren{typespec @paren{@ttbrac{var}} @starparam{declaration} @starparam{form}}}
@auxbnf{no-error-clause, @paren{@kwd{no-error} @param{lambda-list} @starparam{declaration} @starparam{form}}}

@subsubheading Arguments and Values:

@param{expression}---a @term{form}.

@param{typespec}---a @term{type specifier}.

@param{var}---a @term{variable} @term{name}.

@param{lambda-list}---an @term{ordinary lambda list}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{form}---a @term{form}.

@param{results}---In the normal situation, the values returned are those that result from
the evaluation of @param{expression};
in the exceptional situation when control is transferred to a @param{clause},
the value of the last @param{form} in that @param{clause} is returned.

@subsubheading Description:

@code{handler-case} executes @param{expression} in a @term{dynamic environment} where
various handlers are active.  Each @i{error-clause} specifies how to
handle a @term{condition} matching the indicated @param{typespec}.
A @i{no-error-clause} allows the specification of a particular action
if control returns normally.

If a @term{condition} is signaled for which there is an appropriate
@i{error-clause} during the execution of @param{expression}
(@ie{} one for which @f{(typep @term{condition} '@param{typespec})}
returns @term{true}) and if there is no intervening handler for a
@term{condition} of that @term{type}, then control is transferred to
the body of the relevant @i{error-clause}.  In this case, the
dynamic state is unwound appropriately (so that the handlers established
around the @param{expression} are no longer active), and @param{var} is bound to
the @term{condition} that had been signaled.
If more than one case is provided, those cases are made accessible
in parallel.  That is, in

@lisp
  (handler-case @i{form}
    (@i{typespec1} (@i{var1}) @i{form1})
    (@i{typespec2} (@i{var2}) @i{form2}))
@end lisp


if the first @i{clause} (containing @i{form1}) has been selected,
the handler for the second is no longer visible (or vice versa).

The @i{clauses}
are searched sequentially from top to bottom. If there is @term{type}
overlap between @param{typespecs},
the earlier of the @i{clauses} is selected.

If @param{var}
is not needed, it can be omitted. That is, a @i{clause} such as:

@lisp
  (@param{typespec} (@param{var}) (declare (ignore @param{var})) @param{form})
@end lisp


can be written
@f{(@param{typespec} () @param{form})}.

If there are no @param{forms} in a selected @i{clause}, the case, and therefore
@code{handler-case}, returns @nil{}.
If execution of @param{expression}
returns normally and no @i{no-error-clause}
exists, the values returned by
@param{expression} are returned by @code{handler-case}.
If execution of
@param{expression} returns normally and a @i{no-error-clause}
does exist, the values returned are used as arguments to the function
described by constructing
@f{(lambda @param{lambda-list} @starparam{form})}
from the @i{no-error-clause}, and the @term{values} of that function call are
returned by @code{handler-case}.
The handlers which were established around the @param{expression} are no longer active at the time of this call.

@subsubheading Examples:

@lisp
 (defun assess-condition (condition)
   (handler-case (signal condition)
     (warning () "Lots of smoke, but no fire.")
     ((or arithmetic-error control-error cell-error stream-error)
        (condition)
       (format nil "~S looks especially bad." condition))
     (serious-condition (condition)
       (format nil "~S looks serious." condition))
     (condition () "Hardly worth mentioning.")))
@EV{} ASSESS-CONDITION
 (assess-condition (make-condition 'stream-error :stream *terminal-io*))
@EV{} "#<STREAM-ERROR 12352256> looks especially bad."
 (define-condition random-condition (condition) ()
   (:report (lambda (condition stream)
              (declare (ignore condition))
              (princ "Yow" stream))))
@EV{} RANDOM-CONDITION
 (assess-condition (make-condition 'random-condition))
@EV{} "Hardly worth mentioning."
@end lisp


@subsubheading See Also:

@ref{handler-bind},
@ref{ignore-errors},
@ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}

@subsubheading Notes:

@lisp
 (handler-case form
   (@i{type1} (@i{var1}) . @i{body1})
   (@i{type2} (@i{var2}) . @i{body2}) ...)
@end lisp

is approximately equivalent to:

@lisp
 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
     (tagbody
       (handler-bind ((@i{type1} #'(lambda (temp)
                                       (setq #1# temp)
                                       (go #3=#:g0003)))
                      (@i{type2} #'(lambda (temp)
                                       (setq #2# temp)
                                       (go #4=#:g0004))) ...)
       (return-from #1# form))
         #3# (return-from #1# (let ((@i{var1} #2#)) . @i{body1}))
         #4# (return-from #1# (let ((@i{var2} #2#)) . @i{body2})) ...)))
@end lisp


@lisp
 (handler-case form
   (@i{type1} @i{(var1)} . @i{body1})
   ...
   (:no-error (@i{varN-1} @i{varN-2} ...) . @i{bodyN}))
@end lisp

is approximately equivalent to:

@lisp

 (block #1=#:error-return
  (multiple-value-call #'(lambda (@i{varN-1} @i{varN-2} ...) . @i{bodyN})
     (block #2=#:normal-return
       (return-from #1#
         (handler-case (return-from #2# form)
           (@i{type1} (@i{var1}) . @i{body1}) ...)))))
@end lisp




@node ignore-errors
@heading ignore-errors (Macro)
@syindex ignore-errors
@cindex ignore-errors


@subsubheading Syntax:

@DefmacWithValues{ignore-errors, @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{forms}---an @term{implicit progn}.

@param{results}---In the normal situation,
the @term{values} of the @term{forms} are returned;
in the exceptional situation,
two values are returned: @nil{}@spc{}and the @term{condition}.

@subsubheading Description:

@code{ignore-errors} is used to prevent @term{conditions} @oftype{error}
from causing entry into the debugger.

Specifically, @code{ignore-errors} @term{executes} @term{forms}
in a @term{dynamic environment} where a @term{handler} for
@term{conditions} @oftype{error} has been established;
if invoked, it @term{handles} such @term{conditions} by
returning two @term{values}, @nil{}@spc{}and the @term{condition} that was @term{signaled},
from the @code{ignore-errors} @term{form}.

If a @term{normal return} from the @term{forms} occurs,
any @term{values} returned are returned by @code{ignore-errors}.

@subsubheading Examples:

@lisp
 (defun load-init-file (program)
   (let ((win nil))
     (ignore-errors ;if this fails, don't enter debugger
       (load (merge-pathnames (make-pathname :name program :type :lisp)
                              (user-homedir-pathname)))
       (setq win t))
     (unless win (format t "~&Init file failed to load.~%"))
     win))

 (load-init-file "no-such-program")
@OUT{} Init file failed to load.
NIL
@end lisp


@subsubheading See Also:

@ref{handler-case}, @ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}

@subsubheading Notes:

@lisp
 (ignore-errors . @i{forms})
@end lisp


is equivalent to:

@lisp
 (handler-case (progn . @i{forms})
   (error (condition) (values nil condition)))
@end lisp


Because the second return value is a @term{condition}
in the exceptional case, it is common (but not required) to arrange
for the second return value in the normal case to be missing or @nil{}@spc{}so
that the two situations can be distinguished.


@node define-condition
@heading define-condition (Macro)
@syindex define-condition
@cindex define-condition



@editornote{KMP: This syntax stuff is still very confused and needs lots of work.}

@subsubheading Syntax:

@DefmacWithValuesNewline{define-condition, name @paren{@starparam{parent-type}} @paren{@stardown{slot-spec}} @starparam{option}, name}

@auxbnf{slot-spec, slot-name | @paren{slot-name @down{slot-option}}}
@auxbnf{slot-option, @begininterleave{} @star{@curly{@kwd{reader} @term{symbol}}} | @CR{} @star{@curly{@kwd{writer} @down{function-name}}} | @CR{} @star{@curly{@kwd{accessor} @term{symbol}}} | @CR{} @curly{@kwd{allocation} @down{allocation-type}} | @CR{} @star{@curly{@kwd{initarg} @term{symbol}}} | @CR{} @curly{@kwd{initform} @term{form}} | @CR{} @curly{@kwd{type} @param{type-specifier}} @endinterleave{}}
@auxbnf{option, @begininterleave{} @paren{@kwd{default-initargs} @f{.} @param{initarg-list}} | @CR{} @paren{@kwd{documentation} @term{string}} | @CR{} @paren{@kwd{report} @i{report-name}} @endinterleave{}}
@auxbnf{function-name, @curly{@term{symbol} | @tt{(setf @term{symbol})}}}
@auxbnf{allocation-type, @kwd{instance} | @kwd{class}}
@auxbnf{report-name, @term{string} | @term{symbol} | @term{lambda expression}}

@subsubheading Arguments and Values:

@param{name}---a @term{symbol}.

@param{parent-type}---a @term{symbol} naming a @term{condition} @term{type}.
If no @param{parent-types} are supplied,
the @param{parent-types} default to @f{(condition)}.

@param{default-initargs}---a @term{list} of @term{keyword/value pairs}.

@editornote{KMP: This is all mixed up as to which is a slot option and which is
a main option.  I'll sort that out.  Also, some of this is implied
by the bnf and needn't be stated explicitly.}


@param{Slot-spec}---the @term{name} of a @term{slot} or a @term{list}
consisting of the @param{slot-name} followed by zero or more @param{slot-options}.

@param{Slot-name}---a slot name (a @term{symbol}),
the @term{list} of a slot name, or the
@term{list} of slot name/slot form pairs.

@param{Option}---Any of the following:


@table @asis

@item @id{@kwd{reader}}


@kwd{reader} can be supplied more than once for a given @term{slot}
and cannot be @nil{}.

@item @id{@kwd{writer}}


@kwd{writer} can be supplied more than once for a given @term{slot}
and must name a @term{generic function}.

@item @id{@kwd{accessor}}


@kwd{accessor} can be supplied more than once for a given @term{slot}
and cannot be @nil{}.

@item @id{@kwd{allocation}}


@kwd{allocation} can be supplied once at most for a given @term{slot}.
The default if @kwd{allocation} is not supplied is @kwd{instance}.

@item @id{@kwd{initarg}}


@kwd{initarg} can be supplied more than once for a given @term{slot}.

@item @id{@kwd{initform}}


@kwd{initform} can be supplied once at most for a given @term{slot}.

@item @id{@kwd{type}}


@kwd{type} can be supplied once at most for a given @term{slot}.

@item @id{@kwd{documentation}}


@kwd{documentation} can be supplied once at most for a given @term{slot}.

@item @id{@kwd{report}}


@kwd{report} can be supplied once at most.
@end table


@subsubheading Description:

@code{define-condition} defines a new condition type called @param{name},
which is a @term{subtype} of
the @term{type} or @term{types} named by
@param{parent-type}.
Each @param{parent-type} argument specifies a direct @term{supertype}
of the new @term{condition}. The new @term{condition}
inherits @term{slots} and @term{methods} from each of its direct
@term{supertypes}, and so on.

If a slot name/slot form pair is supplied,
the slot form is a @term{form} that
can be evaluated by @code{make-condition} to
produce a default value when an explicit value is not provided.  If no
slot form
is supplied, the contents of the @param{slot}
is initialized in an
@term{implementation-dependent} way.

If the @term{type} being defined and some other
@term{type} from which it inherits
have a slot by the same name, only one slot is allocated in the
@term{condition},
but the supplied slot form overrides any slot form
that might otherwise have been inherited from a @param{parent-type}.  If no
slot form is supplied, the inherited slot form (if any) is still visible.

Accessors are created according to the same rules as used by
@code{defclass}.

A description of @param{slot-options} follows:



@table @asis

@item @id{@kwd{reader}}


The @kwd{reader} slot option specifies that an @term{unqualified method} is
to be defined on the @term{generic function} named by the argument
to @kwd{reader} to read the value of the given @term{slot}.


@item @id{@bull{}}
 The @kwd{initform} slot option is used to provide a default
initial value form to be used in the initialization of the @term{slot}.  This
@term{form} is evaluated every time it is used to initialize the
@term{slot}.  The
@term{lexical environment}
in which this @term{form} is evaluated is the lexical
@term{environment} in which the @code{define-condition}
form was evaluated.
Note that the @term{lexical environment} refers both to variables and to
@term{functions}.
For @term{local slots}, the @term{dynamic environment} is the dynamic
@term{environment}
in which @code{make-condition} was called; for
@term{shared slots}, the @term{dynamic environment}
is the @term{dynamic environment} in which the
@code{define-condition} form was evaluated.

@reviewer{Barmar: Issue CLOS-CONDITIONS doesn't say this.}
No implementation is permitted to extend the syntax of @code{define-condition}
to allow @f{(@param{slot-name} @param{form})} as an abbreviation for
@f{(@param{slot-name} :initform @param{form})}.

@item @id{@kwd{initarg}}


The @kwd{initarg} slot option declares an initialization
argument named by its @term{symbol} argument
and specifies that this
initialization argument initializes the given @term{slot}.  If the
initialization argument has a value in the call to
@code{initialize-instance}, the value is stored into the given @term{slot},
and the slot's @kwd{initform} slot option, if any, is not
evaluated.  If none of the initialization arguments specified for a
given @term{slot} has a value, the @term{slot} is initialized according to the
@kwd{initform} slot option, if specified.

@item @id{@kwd{type}}


The @kwd{type} slot option specifies that the contents of the
@term{slot} is always of the specified @term{type}.  It effectively
declares the result type of the reader generic function when applied
to an @term{object} of this @term{condition} type.
The consequences of attempting to store in a
@term{slot} a value that
does not satisfy the type of the @term{slot} is undefined.

@item @id{@kwd{default-initargs}}


@editornote{KMP: This is an option, not a slot option.}

This option is treated the same as it would be @code{defclass}.

@item @id{@kwd{documentation}}


@editornote{KMP: This is both an option and a slot option.}

The @kwd{documentation} slot option provides a @term{documentation string}
for the @term{slot}.

@item @id{@kwd{report}}


@editornote{KMP: This is an option, not a slot option.}

@term{Condition} reporting is mediated through the @code{print-object}
method for the @term{condition} type in question, with @code{*print-escape*}
always being @nil{}. Specifying @f{(:report @param{report-name})}
in the definition of a condition type @f{C} is equivalent to:

@lisp
 (defmethod print-object ((x c) stream)
   (if *print-escape* (call-next-method) (@param{report-name} x stream)))
@end lisp


If the value supplied by the argument to @kwd{report} (@param{report-name})
is a @term{symbol} or a @term{lambda expression},
it must be acceptable to
@code{function}. @f{(function @param{report-name})}
is evaluated
in the current @term{lexical environment}.
It should return a @term{function}
of two
arguments, a @term{condition} and a @term{stream},
that prints on the @term{stream} a
description of the @term{condition}.
This @term{function} is called whenever the
@term{condition} is printed while @code{*print-escape*} is @nil{}.

If @param{report-name} is a @term{string}, it is a shorthand for

@lisp
 (lambda (condition stream)
   (declare (ignore condition))
   (write-string @param{report-name} stream))
@end lisp


This option is processed after the new @term{condition} type has been defined,
so use of the @param{slot} accessors within the @kwd{report} function is permitted.
If this option is not supplied, information about how to report this
type of @term{condition} is inherited from the @param{parent-type}.
@end table


The consequences are unspecifed if an attempt is made to @term{read} a
@param{slot} that has not been explicitly initialized and that has not
been given a default value.

The consequences are unspecified if an attempt is made to assign the
@param{slots} by using @code{setf}.

If a @code{define-condition} @term{form} appears as a @term{top level form},
the @term{compiler} must make @param{name} recognizable as a valid @term{type} name,
and it must be possible to reference the @term{condition} @term{type} as the
@param{parent-type} of another @term{condition} @term{type} in a subsequent
@code{define-condition} @term{form} in the @term{file} being compiled.

@subsubheading Examples:

The following form defines a condition of @term{type}
@f{peg/hole-mismatch} which inherits from a condition type
called @f{blocks-world-error}:

@lisp
(define-condition peg/hole-mismatch
                  (blocks-world-error)
                  ((peg-shape  :initarg :peg-shape
                               :reader peg/hole-mismatch-peg-shape)
                   (hole-shape :initarg :hole-shape
                               :reader peg/hole-mismatch-hole-shape))
  (:report (lambda (condition stream)
             (format stream "A ~A peg cannot go in a ~A hole."
                     (peg/hole-mismatch-peg-shape  condition)
                     (peg/hole-mismatch-hole-shape condition)))))
@end lisp


The new type has slots @f{peg-shape} and @f{hole-shape},
so @code{make-condition} accepts @f{:peg-shape} and @f{:hole-shape} keywords.
The @term{readers} @f{peg/hole-mismatch-peg-shape} and @f{peg/hole-mismatch-hole-shape}
apply to objects of this type, as illustrated in the @kwd{report} information.

The following form defines a @term{condition} @term{type} named @f{machine-error}
which inherits from @code{error}:

@lisp
(define-condition machine-error
                  (error)
                  ((machine-name :initarg :machine-name
                                 :reader machine-error-machine-name))
  (:report (lambda (condition stream)
             (format stream "There is a problem with ~A."
                     (machine-error-machine-name condition)))))
@end lisp


Building on this definition, a new error condition can be defined which
is a subtype of @f{machine-error} for use when machines are not available:

@lisp
(define-condition machine-not-available-error (machine-error) ()
  (:report (lambda (condition stream)
             (format stream "The machine ~A is not available."
                     (machine-error-machine-name condition)))))
@end lisp


This defines a still more specific condition, built upon
@f{machine-not-available-error}, which provides a slot initialization form
for @f{machine-name} but which does not provide any new slots or report
information.  It just gives the @f{machine-name} slot a default initialization:

@lisp
(define-condition my-favorite-machine-not-available-error
                  (machine-not-available-error)
  ((machine-name :initform "mc.lcs.mit.edu")))
@end lisp


Note that since no @kwd{report} clause was given, the information
inherited from @f{machine-not-available-error} is used to
report this type of condition.

@lisp
 (define-condition ate-too-much (error)
     ((person :initarg :person :reader ate-too-much-person)
      (weight :initarg :weight :reader ate-too-much-weight)
      (kind-of-food :initarg :kind-of-food
                    :reader :ate-too-much-kind-of-food)))
@EV{} ATE-TOO-MUCH
 (define-condition ate-too-much-ice-cream (ate-too-much)
   ((kind-of-food :initform 'ice-cream)
    (flavor       :initarg :flavor
                  :reader ate-too-much-ice-cream-flavor
                  :initform 'vanilla ))
   (:report (lambda (condition stream)
              (format stream "~A ate too much ~A ice-cream"
                      (ate-too-much-person condition)
                      (ate-too-much-ice-cream-flavor condition)))))
@EV{} ATE-TOO-MUCH-ICE-CREAM
 (make-condition 'ate-too-much-ice-cream
                 :person 'fred
                 :weight 300
                 :flavor 'chocolate)
@EV{} #<ATE-TOO-MUCH-ICE-CREAM 32236101>
 (format t "~A" *)
@OUT{} FRED ate too much CHOCOLATE ice-cream
@EV{} NIL
@end lisp


@subsubheading See Also:

@ref{make-condition}, @ref{defclass}, @ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}



@node make-condition
@heading make-condition (Function)
@syindex make-condition
@cindex make-condition


@subsubheading Syntax:

@DefunWithValues{make-condition, type @rest{} slot-initializations, condition}

@subsubheading Arguments and Values:

@param{type}---a @term{type specifier} (for a @term{subtype} of @code{condition}).

@param{slot-initializations}---an @term{initialization argument list}.

@param{condition}---a @term{condition}.

@subsubheading Description:

Constructs and returns a @term{condition} of type @param{type}
using @param{slot-initializations} for the initial values of the slots.
The newly created @term{condition} is returned.

@subsubheading Examples:
@lisp
 (defvar *oops-count* 0)

 (setq a (make-condition 'simple-error
                         :format-control "This is your ~:R error."
                         :format-arguments (list (incf *oops-count*))))
@EV{} #<SIMPLE-ERROR 32245104>

 (format t "~&~A~%" a)
@OUT{} This is your first error.
@EV{} NIL

 (error a)
@OUT{} Error: This is your first error.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return to Lisp Toplevel.
@OUT{} Debug>
@end lisp


@subsubheading Affected By:

The set of defined @term{condition} @term{types}.

@subsubheading See Also:

@ref{define-condition}, @ref{Condition System Concepts, Section 9.1 (Condition System Concepts)}


@node restart
@heading restart (System Class)
@syindex restart
@cindex restart


@subsubheading Class Precedence List:
@code{restart},
@code{t}

@subsubheading Description:

An @term{object} @oftype{restart} represents a @term{function} that can be
called to perform some form of recovery action, usually a transfer of control
to an outer point in the running program.

An @term{implementation} is free to implement a @term{restart} in whatever
manner is most convenient; a @term{restart} has only @term{dynamic extent}
relative to the scope of the binding @term{form} which @term{establishes} it.


@node compute-restarts
@heading compute-restarts (Function)
@syindex compute-restarts
@cindex compute-restarts


@subsubheading Syntax:

@DefunWithValues{compute-restarts, @opt{} condition, restarts}

@subsubheading Arguments and Values:

@param{condition}---a @term{condition} @term{object}, or @nil{}.

@param{restarts}---a @term{list} of @term{restarts}.

@subsubheading Description:

@code{compute-restarts} uses the dynamic state of the program to compute
a @term{list} of the @term{restarts} which are currently active.

The resulting @term{list} is ordered so that the innermost
(more-recently established) restarts are nearer the head of the @term{list}.

When @param{condition} is @term{non-nil}, only those @term{restarts}
are considered that are either explicitly associated with that @param{condition},
or not associated with any @term{condition}; that is, the excluded @term{restarts}
are those that are associated with a non-empty set of @term{conditions} of
which the given @param{condition} is not an @term{element}.
If @param{condition} is @nil{}, all @term{restarts} are considered.

@code{compute-restarts} returns all
@term{applicable restarts},
including anonymous ones, even if some of them have the same name as
others and would therefore not be found by @code{find-restart}
when given a @term{symbol} argument.

Implementations are permitted, but not required, to return @term{distinct}
@term{lists} from repeated calls to @code{compute-restarts} while in
the same dynamic environment.
The consequences are undefined if the @term{list} returned by
@code{compute-restarts} is every modified.

@subsubheading Examples:

@lisp
 ;; One possible way in which an interactive debugger might present
 ;; restarts to the user.
 (defun invoke-a-restart ()
   (let ((restarts (compute-restarts)))
     (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
       (format t "~&~D: ~A~%" i (car r)))
     (let ((n nil) (k (length restarts)))
       (loop (when (and (typep n 'integer) (>= n 0) (< n k))
               (return t))
             (format t "~&Option: ")
             (setq n (read))
             (fresh-line))
       (invoke-restart-interactively (nth n restarts)))))

 (restart-case (invoke-a-restart)
   (one () 1)
   (two () 2)
   (nil () :report "Who knows?" 'anonymous)
   (one () 'I)
   (two () 'II))
@OUT{} 0: ONE
@OUT{} 1: TWO
@OUT{} 2: Who knows?
@OUT{} 3: ONE
@OUT{} 4: TWO
@OUT{} 5: Return to Lisp Toplevel.
@OUT{} Option: @IN{4}
@EV{} II

 ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
 ;; also returns information about any system-supplied restarts, such as
 ;; the "Return to Lisp Toplevel" restart offered above.

@end lisp



@subsubheading Affected By:

Existing restarts.

@subsubheading See Also:

@ref{find-restart},
@ref{invoke-restart},
@ref{restart-bind}


@node find-restart
@heading find-restart (Function)
@syindex find-restart
@cindex find-restart


@subsubheading Syntax:

@DefunWithValues{find-restart, identifier @opt{} condition, restart}

@subsubheading Arguments and Values:

@param{identifier}---a @term{non-nil} @term{symbol}, or a @term{restart}.

@param{condition}---a @term{condition} @term{object}, or @nil{}.

@param{restart}---a @term{restart} or @nil{}.

@subsubheading Description:

@code{find-restart} searches for a particular @term{restart} in the
current @term{dynamic environment}.

When @param{condition} is @term{non-nil}, only those @term{restarts}
are considered that are either explicitly associated with that @param{condition},
or not associated with any @term{condition}; that is, the excluded @term{restarts}
are those that are associated with a non-empty set of @term{conditions} of
which the given @param{condition} is not an @term{element}.
If @param{condition} is @nil{}, all @term{restarts} are considered.

If @param{identifier} is a @term{symbol}, then the innermost
(most recently established) @term{applicable restart} with that @term{name} is returned.
@nil{}@spc{}is returned if no such restart is found.

If @param{identifier} is a currently active restart, then it is returned.
Otherwise, @nil{}@spc{}is returned.

@subsubheading Examples:

@lisp
 (restart-case
     (let ((r (find-restart 'my-restart)))
       (format t "~S is named ~S" r (restart-name r)))
   (my-restart () nil))
@OUT{} #<RESTART 32307325> is named MY-RESTART
@EV{} NIL
 (find-restart 'my-restart)
@EV{} NIL
@end lisp


@subsubheading Affected By:

Existing restarts.

@code{restart-case}, @code{restart-bind}, @code{with-condition-restarts}.

@subsubheading See Also:

@ref{compute-restarts}

@subsubheading Notes:

@lisp
 (find-restart @param{identifier})
 @EQ{} (find @param{identifier} (compute-restarts) :key :restart-name)
@end lisp


Although anonymous restarts have a name of @nil{},
the consequences are unspecified if @nil{}@spc{}is given as an @param{identifier}.
Occasionally, programmers lament that @nil{}@spc{}is not permissible as an
@param{identifier} argument.  In most such cases, @code{compute-restarts}
can probably be used to simulate the desired effect.


@node invoke-restart
@heading invoke-restart (Function)
@syindex invoke-restart
@cindex invoke-restart


@subsubheading Syntax:

@DefunWithValues{invoke-restart, restart @rest{} arguments, @starparam{result}}

@subsubheading Arguments and Values:

@param{restart}---a @term{restart designator}.

@param{argument}---an @term{object}.

@param{results}---the @term{values} returned by the @term{function}
associated with @param{restart}, if that @term{function} returns.

@subsubheading Description:

Calls the @term{function} associated with @param{restart},
passing @param{arguments} to it.
@param{Restart} must be valid in the current @term{dynamic environment}.

@subsubheading Examples:
@lisp
 (defun add3 (x) (check-type x number) (+ x 3))

 (foo 'seven)
@OUT{} Error: The value SEVEN was not of type NUMBER.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a different value to use.
@OUT{}  2: Return to Lisp Toplevel.
@OUT{} Debug> @IN{(invoke-restart 'store-value 7)}
@EV{} 10
@end lisp


@subsubheading Side Effects:

A non-local transfer of control might be done by the restart.

@subsubheading Affected By:

Existing restarts.

@subsubheading Exceptional Situations:

If @param{restart} is not valid, an error @oftype{control-error} is signaled.

@subsubheading See Also:

@ref{find-restart},
@ref{restart-bind},
@ref{restart-case},
@ref{invoke-restart-interactively}

@subsubheading Notes:

The most common use for @code{invoke-restart} is in a @term{handler}.
It might be used explicitly, or implicitly through @code{invoke-restart-interactively}
or a @term{restart function}.

@term{Restart functions} call @code{invoke-restart}, not vice versa.  That is,
@term{invoke-restart} provides primitive functionality, and @term{restart functions}
are non-essential ``syntactic sugar.''


@node invoke-restart-interactively
@heading invoke-restart-interactively (Function)
@syindex invoke-restart-interactively
@cindex invoke-restart-interactively


@subsubheading Syntax:

@DefunWithValues{invoke-restart-interactively, restart, @starparam{result}}

@subsubheading Arguments and Values:

@param{restart}---a @term{restart designator}.

@param{results}---the @term{values} returned by the @term{function}
associated with @param{restart}, if that @term{function} returns.

@subsubheading Description:

@code{invoke-restart-interactively} calls the @term{function} associated
with @param{restart}, prompting for any necessary arguments.
If @param{restart} is a name, it must be valid in the current @term{dynamic environment}.

@code{invoke-restart-interactively}
prompts for arguments by executing
the code provided in the @kwd{interactive} keyword to
@code{restart-case} or
@kwd{interactive-function} keyword to @code{restart-bind}.

If no such options have been supplied in the corresponding
@code{restart-bind} or @code{restart-case},
then the consequences are undefined if the @param{restart} takes
required arguments.  If the arguments are optional, an argument list of
@nil{}@spc{}is used.

Once the arguments have been determined,
@code{invoke-restart-interactively}
executes the following:

@lisp
 (apply #'invoke-restart @i{restart} @i{arguments})
@end lisp



@subsubheading Examples:

@lisp
 (defun add3 (x) (check-type x number) (+ x 3))

 (add3 'seven)
@OUT{} Error: The value SEVEN was not of type NUMBER.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a different value to use.
@OUT{}  2: Return to Lisp Toplevel.
@OUT{} Debug> @IN{(invoke-restart-interactively 'store-value)}
@OUT{} Type a form to evaluate and use: @IN{7}
@EV{} 10
@end lisp


@subsubheading Side Effects:

If prompting for arguments is necesary,
some typeout may occur (on @term{query I/O}).

A non-local transfer of control might be done by the restart.

@subsubheading Affected By:

@code{*query-io*}, active @term{restarts}

@subsubheading Exceptional Situations:

If @param{restart} is not valid, an error @oftype{control-error}
is signaled.

@subsubheading See Also:

@ref{find-restart},
@ref{invoke-restart},
@ref{restart-case},
@ref{restart-bind}

@subsubheading Notes:

@code{invoke-restart-interactively} is used internally by the debugger
and may also be useful in implementing other portable, interactive debugging
tools.


@node restart-bind
@heading restart-bind (Macro)
@syindex restart-bind
@cindex restart-bind


@subsubheading Syntax:

@DefmacWithValuesNewline{restart-bind, @paren{@curly{@paren{name function @stardown{key-val-pair}}}} @starparam{form}, @starparam{result}}

@auxbnf{key-val-pair, @kwd{interactive-function} interactive-function | @CR{} @kwd{report-function} report-function | @CR{} @kwd{test-function} test-function}

@subsubheading Arguments and Values:

@param{name}---a @term{symbol}; @noeval{}.

@param{function}---a @term{form}; @eval{}.

@param{forms}---an @term{implicit progn}.

@param{interactive-function}---a @term{form}; @eval{}.

@param{report-function}---a @term{form}; @eval{}.

@param{test-function}---a @term{form}; @eval{}.

@param{results}---the @term{values} returned by the @term{forms}.

@subsubheading Description:

@code{restart-bind} executes the body of @param{forms}
in a @term{dynamic environment} where @term{restarts} with the given @param{names} are in effect.

If a @param{name} is @nil{}, it indicates an anonymous restart;
if a @param{name} is a @term{non-nil} @term{symbol}, it indicates a named restart.

The @param{function}, @param{interactive-function}, and @param{report-function}
are unconditionally evaluated in the current lexical and dynamic environment
prior to evaluation of the body. Each of these @term{forms} must evaluate to
a @term{function}.

If @code{invoke-restart} is done on that restart,
the @term{function} which resulted from evaluating @param{function}
is called, in the @term{dynamic environment} of the @code{invoke-restart},
with the @term{arguments} given to @code{invoke-restart}.
The @term{function} may either perform a non-local transfer of control or may return normally.

If the restart is invoked interactively from the debugger
(using @code{invoke-restart-interactively}),
the arguments are defaulted by calling the @term{function}
which resulted from evaluating @param{interactive-function}.
That @term{function} may optionally prompt interactively on @term{query I/O},
and should return a @term{list} of arguments to be used by
@code{invoke-restart-interactively} when invoking the restart.

If a restart is invoked interactively but no @param{interactive-function} is used,
then an argument list of @nil{}@spc{}is used. In that case, the @term{function}
must be compatible with an empty argument list.

If the restart is presented interactively (@eg{} by the debugger),
the presentation is done by calling the @term{function} which resulted
from evaluating @param{report-function}.
This @term{function} must be a @term{function} of one argument, a @term{stream}.
It is expected to print a description of the action that the restart takes
to that @term{stream}.
This @term{function} is called any time the restart is printed
while @code{*print-escape*} is @nil{}.

In the case of interactive invocation,
the result is dependent on the value of @kwd{interactive-function}
as follows.


@table @asis
@item @id{@kwd{interactive-function}}


@param{Value} is evaluated in the current lexical environment and
should return a @term{function} of no arguments which constructs a
@term{list} of arguments to be used by @code{invoke-restart-interactively}
when invoking this restart.  The @term{function} may prompt interactively
using @term{query I/O} if necessary.

@item @id{@kwd{report-function}}


@param{Value} is evaluated in the current lexical environment and
should return a @term{function} of one argument, a @term{stream}, which
prints on the @term{stream} a summary of the action that this restart
takes.  This @term{function} is called whenever the restart is
reported (printed while @code{*print-escape*} is @nil{}).
If no @kwd{report-function} option is provided, the manner in which the
@term{restart} is reported is @term{implementation-dependent}.

@item @id{@kwd{test-function}}


@param{Value} is evaluated in the current lexical environment and
should return a @term{function} of one argument, a @term{condition}, which
returns @term{true} if the restart is to be considered visible.
@end table


@subsubheading Affected By:

@code{*query-io*}.

@subsubheading See Also:

@ref{restart-case}, @ref{with-simple-restart}

@subsubheading Notes:

@code{restart-bind} is primarily intended to be used to implement
@code{restart-case} and  might be useful in implementing other
macros. Programmers who are uncertain about whether to use @code{restart-case}
or @code{restart-bind} should prefer @code{restart-case} for the cases where
it is powerful enough, using @code{restart-bind} only in cases where its full
generality is really needed.


@node restart-case
@heading restart-case (Macro)
@syindex restart-case
@cindex restart-case



@subsubheading Syntax:

@DefmacWithValues{restart-case, restartable-form @curly{@down{clause}}, @starparam{result}}

@auxbnf{clause, @lparen{} case-name lambda-list @CR{} @spc{}@interleave{@kwd{interactive} interactive-expression | @kwd{report} report-expression | @kwd{test} test-expression} @CR{} @spc{}@starparam{declaration} @starparam{form}@rparen{}}

@subsubheading Arguments and Values:

@param{restartable-form}---a @term{form}.

@param{case-name}---a @term{symbol} or @nil{}.

@param{lambda-list}---an @term{ordinary lambda list}.

@param{interactive-expression}---a @term{symbol} or a @term{lambda expression}.

@param{report-expression}---a @term{string},
a @term{symbol},
or a @term{lambda expression}.

@param{test-expression}---a @term{symbol} or a @term{lambda expression}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{form}---a @term{form}.

@param{results}---the @term{values} resulting from the @term{evaluation}
of @param{restartable-form},
or the @term{values} returned by the last @param{form}
executed in a chosen @term{clause},
or @nil{}.

@subsubheading Description:

@code{restart-case} evaluates @param{restartable-form} in a @term{dynamic environment}
where the clauses have special meanings as points to which control may be transferred.
If @param{restartable-form} finishes executing and returns any values,
all values returned are returned by @code{restart-case} and
processing has completed. While @param{restartable-form} is executing, any code may
transfer control to one of the clauses (see @code{invoke-restart}).
If a transfer
occurs, the forms in the body of that clause is evaluated and any values
returned by the last such form are returned by
@code{restart-case}.
In this case, the
dynamic state is unwound appropriately (so that the restarts established
around the @param{restartable-form} are no longer active) prior to execution of the
clause.

If there are no @param{forms}
in a selected clause, @code{restart-case} returns @nil{}.

If @param{case-name} is a @term{symbol}, it names this restart.

It is possible to have more than one clause use the same @param{case-name}.
In this case, the first clause with that name is found by @code{find-restart}.
The other clauses are accessible using @code{compute-restarts}.

Each @param{arglist} is an @term{ordinary lambda list} to be bound during the
execution of its corresponding @param{forms}.  These parameters are used
by the @code{restart-case} clause to receive any necessary data from a call
to @code{invoke-restart}.

By default, @code{invoke-restart-interactively} passes no arguments and
all arguments must be optional in order to accomodate interactive
restarting.  However, the arguments need not be optional if the
@kwd{interactive}
keyword has been used to inform @code{invoke-restart-interactively}
about how to compute a proper argument list.

@param{Keyword} options have the following meaning.

@table @asis
@item @id{@kwd{interactive}}


The @param{value} supplied by @f{:interactive @param{value}}
must be a suitable argument to @code{function}.
@f{(function @param{value})} is evaluated in the current lexical
environment.  It should return a @term{function} of no arguments which
returns arguments to be used by
@code{invoke-restart-interactively} when it is invoked.
@code{invoke-restart-interactively}
is called in the dynamic
environment available prior to any restart attempt, and uses
@term{query I/O} for user interaction.

If a restart is invoked interactively but no @kwd{interactive} option
was supplied, the argument list used in the invocation is the empty
list.

@item @id{@kwd{report}}


If the @param{value} supplied by @f{:report @param{value}}
is a @term{lambda expression} or a @term{symbol}, it
must be acceptable to @code{function}.
@f{(function @param{value})} is evaluated in the current lexical
environment.  It should return a @term{function} of one
argument, a @term{stream}, which prints on the @term{stream} a
description of the restart.  This @term{function} is called
whenever the restart is printed while @code{*print-escape*} is @nil{}.

If @param{value} is a @term{string}, it is a shorthand for

@lisp
 (lambda (stream) (write-string value stream))
@end lisp


If a named restart is asked to report but no report information has been
supplied, the name of the restart is used in generating default report text.

When @code{*print-escape*} is @nil{}, the
printer uses the report information for
a restart.  For example, a debugger might announce the action of typing
a ``continue'' command by:

@lisp
 (format t "~&~S -- ~A~%" ':continue some-restart)
@end lisp

which might then display as something like:

@lisp
 :CONTINUE -- Return to command level
@end lisp


The consequences are unspecified if an unnamed restart is specified
but no @kwd{report} option is provided.

@item @id{@kwd{test}}


The @param{value} supplied by @f{:test @param{value}}
must be a suitable argument to @code{function}.
@f{(function @param{value})} is evaluated in the current lexical
environment.  It should return a @term{function} of one @term{argument}, the
@term{condition}, that
returns @term{true} if the restart is to be considered visible.

The default for this option is equivalent to @f{(lambda (c) (declare (ignore c)) t)}.
@end table


If the @param{restartable-form} is a @term{list} whose @term{car} is any of
the @term{symbols} @code{signal}, @code{error}, @code{cerror},
or @code{warn} (or is a @term{macro form} which macroexpands into such a
@term{list}), then @code{with-condition-restarts} is used implicitly
to associate the indicated @term{restarts} with the @term{condition} to be
signaled.

@subsubheading Examples:

@lisp
 (restart-case
     (handler-bind ((error #'(lambda (c)
                             (declare (ignore condition))
                             (invoke-restart 'my-restart 7))))
       (error "Foo."))
   (my-restart (&optional v) v))
@EV{} 7

 (define-condition food-error (error) ())
@EV{} FOOD-ERROR
 (define-condition bad-tasting-sundae (food-error)
   ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
    (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
    (topping :initarg :topping :reader bad-tasting-sundae-topping))
   (:report (lambda (condition stream)
              (format stream "Bad tasting sundae with ~S, ~S, and ~S"
                      (bad-tasting-sundae-ice-cream condition)
                      (bad-tasting-sundae-sauce condition)
                      (bad-tasting-sundae-topping condition)))))
@EV{} BAD-TASTING-SUNDAE
 (defun all-start-with-same-letter (symbol1 symbol2 symbol3)
   (let ((first-letter (char (symbol-name symbol1) 0)))
     (and (eql first-letter (char (symbol-name symbol2) 0))
          (eql first-letter (char (symbol-name symbol3) 0)))))
@EV{} ALL-START-WITH-SAME-LETTER
 (defun read-new-value ()
   (format t "Enter a new value: ")
   (multiple-value-list (eval (read))))
@EV{} READ-NEW-VALUE@eject{}
 (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
   (do ()
      ((all-start-with-same-letter ice-cream sauce topping))
     (restart-case
       (error 'bad-tasting-sundae
              :ice-cream ice-cream
              :sauce sauce
              :topping topping)
       (use-new-ice-cream (new-ice-cream)
         :report "Use a new ice cream."
         :interactive read-new-value
         (setq ice-cream new-ice-cream))
       (use-new-sauce (new-sauce)
         :report "Use a new sauce."
         :interactive read-new-value
         (setq sauce new-sauce))
       (use-new-topping (new-topping)
         :report "Use a new topping."
         :interactive read-new-value
         (setq topping new-topping))))
   (values ice-cream sauce topping))
@EV{} VERIFY-OR-FIX-PERFECT-SUNDAE
 (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)
@OUT{} Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Use a new ice cream.
@OUT{}  2: Use a new sauce.
@OUT{}  3: Use a new topping.
@OUT{}  4: Return to Lisp Toplevel.
@OUT{} Debug> @IN{:continue 1}
@OUT{} Use a new ice cream.
@OUT{} Enter a new ice cream: @IN{'chocolate}
@EV{} CHOCOLATE, CARAMEL, CHERRY
@end lisp


@subsubheading See Also:

@ref{restart-bind}, @ref{with-simple-restart}.

@subsubheading Notes:

@lisp
 (restart-case @i{expression}
    (@i{name1} @i{arglist1} ...@i{options1}... . @i{body1})
    (@i{name2} @i{arglist2} ...@i{options2}... . @i{body2}))
@end lisp

is essentially equivalent to

@lisp
 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
        (tagbody
        (restart-bind ((name1 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #3=#:g0003))
                          ...@i{slightly-transformed-options1}...)
                       (name2 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #4=#:g0004))
                          ...@i{slightly-transformed-options2}...))
        (return-from #1# @i{expression}))
          #3# (return-from #1#
                  (apply #'(lambda @i{arglist1} . @i{body1}) #2#))
          #4# (return-from #1#
                  (apply #'(lambda @i{arglist2} . @i{body2}) #2#)))))
@end lisp


Unnamed restarts are generally only useful interactively
and an interactive option which has no description is of little value.
Implementations are encouraged to warn if
an unnamed restart is used and no report information
is provided
at compilation    time.
At runtime, this error might be noticed when entering
the debugger.  Since signaling an error would probably cause recursive
entry into the debugger (causing yet another recursive error, etc.) it is
suggested that the debugger print some indication of such problems when
they occur but not actually signal errors.

@lisp
 (restart-case (signal fred)
   (a ...)
   (b ...))
 @EQ{}
 (restart-case
     (with-condition-restarts fred
                              (list (find-restart 'a)
                                    (find-restart 'b))
       (signal fred))
   (a ...)
   (b ...))
@end lisp




@node restart-name
@heading restart-name (Function)
@syindex restart-name
@cindex restart-name


@subsubheading Syntax:

@DefunWithValues{restart-name, restart, name}

@subsubheading Arguments and Values:

@param{restart}---a @term{restart}.

@param{name}---a @term{symbol}.

@subsubheading Description:

Returns the name of the @param{restart},
or @nil{}@spc{}if the @param{restart} is not named.

@subsubheading Examples:

@lisp
 (restart-case
     (loop for restart in (compute-restarts)
               collect (restart-name restart))
   (case1 () :report "Return 1." 1)
   (nil   () :report "Return 2." 2)
   (case3 () :report "Return 3." 3)
   (case1 () :report "Return 4." 4))
@EV{} (CASE1 NIL CASE3 CASE1 ABORT)
 ;; In the example above the restart named ABORT was not created
 ;; explicitly, but was implicitly supplied by the system.
@end lisp


@subsubheading See Also:

@ref{compute-restarts}
@ref{find-restart}


@node with-condition-restarts
@heading with-condition-restarts (Macro)
@syindex with-condition-restarts
@cindex with-condition-restarts



@subsubheading Syntax:

@DefmacWithValuesNewline{with-condition-restarts, condition-form restarts-form @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{condition-form}---a @term{form}; @term{evaluated} to produce a @param{condition}.

@param{condition}---a @term{condition} @term{object} resulting from the
@term{evaluation} of @param{condition-form}.

@param{restart-form}---a @term{form}; @term{evaluated} to produce a @param{restart-list}.

@param{restart-list}---a @term{list} of @term{restart} @term{objects} resulting
from the @term{evaluation} of @param{restart-form}.

@param{forms}---an @term{implicit progn}; @eval{}.

@param{results}---the @term{values} returned by @param{forms}.

@subsubheading Description:

First, the @param{condition-form} and @param{restarts-form} are @term{evaluated}
in normal left-to-right order; the @term{primary values} yielded by these
@term{evaluations} are respectively called the @param{condition}
and the @param{restart-list}.

Next, the @param{forms} are @term{evaluated} in a @term{dynamic environment}
in which each @term{restart} in @param{restart-list} is associated with
the @param{condition}.  See @ref{AssocRestartWithCond, Section 9.1.4.2.4 (Associating a Restart with a Condition)}.

@subsubheading See Also:

@ref{restart-case}

@subsubheading Notes:

Usually this @term{macro} is not used explicitly in code,
since @code{restart-case} handles most of the common cases
in a way that is syntactically more concise.



@node with-simple-restart
@heading with-simple-restart (Macro)
@syindex with-simple-restart
@cindex with-simple-restart


@subsubheading Syntax:

@DefmacWithValuesNewline{with-simple-restart, @paren{name format-control @starparam{format-argument}} @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{name}---a @term{symbol}.

@param{format-control}---a @term{format control}.

@param{format-argument}---an @term{object} (@ie{} a @term{format argument}).

@param{forms}---an @term{implicit progn}.

@param{results}---in the normal situation,
the @term{values} returned by the @param{forms};
in the exceptional situation where the @term{restart} named @param{name} is invoked,
two values---@nil{}@spc{}and @code{t}.

@subsubheading Description:

@code{with-simple-restart} establishes a restart.

If the restart designated by @param{name} is not invoked while executing @param{forms},
all values returned by the last of @param{forms} are returned.
If the restart designated by @param{name} is invoked,
control is transferred to @code{with-simple-restart},
which returns two values, @nil{}@spc{}and @code{t}.

If @param{name} is @nil{}, an anonymous restart is established.

The @param{format-control} and @param{format-arguments} are used
report the @term{restart}.

@subsubheading Examples:

@lisp
 (defun read-eval-print-loop (level)
   (with-simple-restart (abort "Exit command level ~D." level)
     (loop
       (with-simple-restart (abort "Return to command level ~D." level)
         (let ((form (prog2 (fresh-line) (read) (fresh-line))))
           (prin1 (eval form)))))))
@EV{} READ-EVAL-PRINT-LOOP
 (read-eval-print-loop 1)
 (+ 'a 3)
@OUT{} Error: The argument, A, to the function + was of the wrong type.
@OUT{}        The function expected a number.
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Specify a value to use this time.
@OUT{}  2: Return to command level 1.
@OUT{}  3: Exit command level 1.
@OUT{}  4: Return to Lisp Toplevel.
@end lisp


@lisp
 (defun compute-fixnum-power-of-2 (x)
   (with-simple-restart (nil "Give up on computing 2@hat{}~D." x)
     (let ((result 1))
       (dotimes (i x result)
         (setq result (* 2 result))
         (unless (fixnump result)
           (error "Power of 2 is too large."))))))
COMPUTE-FIXNUM-POWER-OF-2
 (defun compute-power-of-2 (x)
   (or (compute-fixnum-power-of-2 x) 'something big))
COMPUTE-POWER-OF-2
 (compute-power-of-2 10)
1024
 (compute-power-of-2 10000)
@OUT{} Error: Power of 2 is too large.
@OUT{} To continue, type :CONTINUE followed by an option number.
@OUT{}  1: Give up on computing 2@hat{}10000.
@OUT{}  2: Return to Lisp Toplevel
@OUT{} Debug> @IN{:continue 1}
@EV{} SOMETHING-BIG
@end lisp


@subsubheading See Also:

@ref{restart-case}

@subsubheading Notes:

@code{with-simple-restart} is shorthand for one of the most
common uses of @code{restart-case}.

@code{with-simple-restart} could be defined by:

@lisp
 (defmacro with-simple-restart ((restart-name format-control
                                              &rest format-arguments)
                                &body forms)
   `(restart-case (progn ,@@forms)
      (,restart-name ()
          :report (lambda (stream)
                    (format stream ,format-control ,@@format-arguments))
         (values nil t))))
@end lisp


Because the second return value is @code{t}@spc{}in the exceptional case,
it is common (but not required) to arrange for the second return value
in the normal case to be missing or @nil{}@spc{}so that the two situations
can be distinguished.


@node abort (Restart)
@heading abort (Restart)
@syindex abort
@cindex abort


@subsubheading Data Arguments Required:

None.

@subsubheading Description:

The intent of the @t{abort} restart is to allow return to the
innermost ``command level.''  Implementors are encouraged to make
sure that there is always a restart named @code{abort}
around any user code so that user code can call @code{abort}
at any time and expect something reasonable to happen;
exactly what the reasonable thing is may vary somewhat.  Typically,
in an interactive listener, the invocation of @code{abort}
returns to the @term{Lisp reader} phase of the @term{Lisp read-eval-print loop},
though in some batch or multi-processing
situations there may be situations in which having it kill the running
process is more appropriate.

@subsubheading See Also:

@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{invoke-restart},
@ref{abort} (@term{function})


@node continue (Restart)
@heading continue (Restart)
@syindex continue
@cindex continue


@subsubheading Data Arguments Required:

None.

@subsubheading Description:

@Therestart{continue} is generally part of protocols where there is
a single ``obvious'' way to continue, such as in
@code{break} and @code{cerror}.  Some
user-defined protocols may also wish to incorporate it for similar reasons.
In general, however, it is more reliable to design a special purpose restart
with a name that more directly suits the particular application.

@subsubheading Examples:

@lisp
 (let ((x 3))
   (handler-bind ((error #'(lambda (c)
                             (let ((r (find-restart 'continue c)))
                               (when r (invoke-restart r))))))
     (cond ((not (floatp x))
            (cerror "Try floating it." "~D is not a float." x)
            (float x))
           (t x)))) @EV{} 3.0
@end lisp


@subsubheading See Also:

@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{invoke-restart},
@ref{continue} (@term{function}),
@ref{assert},
@ref{cerror}


@node muffle-warning (Restart)
@heading muffle-warning (Restart)
@syindex muffle-warning
@cindex muffle-warning


@subsubheading Data Arguments Required:

None.

@subsubheading Description:

This @term{restart} is established by @code{warn} so that @term{handlers}
of @code{warning} @term{conditions} have a way to tell @code{warn}
that a warning has already been dealt with and that no further action is warranted.

@subsubheading Examples:

@lisp
 (defvar *all-quiet* nil) @EV{} *ALL-QUIET*
 (defvar *saved-warnings* '()) @EV{} *SAVED-WARNINGS*
 (defun quiet-warning-handler (c)
   (when *all-quiet*
     (let ((r (find-restart 'muffle-warning c)))
       (when r
         (push c *saved-warnings*)
         (invoke-restart r)))))
@EV{} CUSTOM-WARNING-HANDLER
 (defmacro with-quiet-warnings (&body forms)
   `(let ((*all-quiet* t)
          (*saved-warnings* '()))
      (handler-bind ((warning #'quiet-warning-handler))
        ,@@forms
        *saved-warnings*)))
@EV{} WITH-QUIET-WARNINGS
 (setq saved
   (with-quiet-warnings
     (warn "Situation #1.")
     (let ((*all-quiet* nil))
       (warn "Situation #2."))
     (warn "Situation #3.")))
@OUT{} Warning: Situation #2.
@EV{} (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
 (dolist (s saved) (format t "~&~A~%" s))
@OUT{} Situation #3.
@OUT{} Situation #1.
@EV{} NIL
@end lisp


@subsubheading See Also:

@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{invoke-restart},
@ref{muffle-warning} (@term{function}),
@ref{warn}


@node store-value (Restart)
@heading store-value (Restart)
@syindex store-value
@cindex store-value


@subsubheading Data Arguments Required:

a value to use instead (on an ongoing basis).

@subsubheading Description:

@Therestart{store-value} is generally used by @term{handlers}
trying to recover from errors of @term{types} such as @code{cell-error}
or @code{type-error}, which may wish to supply a replacement datum to
be stored permanently.

@subsubheading Examples:

@lisp
 (defun type-error-auto-coerce (c)
   (when (typep c 'type-error)
     (let ((r (find-restart 'store-value c)))
       (handler-case (let ((v (coerce (type-error-datum c)
                                      (type-error-expected-type c))))
                       (invoke-restart r v))
         (error ()))))) @EV{} TYPE-ERROR-AUTO-COERCE
 (let ((x 3))
   (handler-bind ((type-error #'type-error-auto-coerce))
     (check-type x float)
     x)) @EV{} 3.0
@end lisp


@subsubheading See Also:

@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{invoke-restart},
@ref{store-value} (@term{function}),
@ref{ccase},
@ref{check-type},
@ref{ctypecase},
@ref{use-value} (@term{function} and @term{restart})


@node use-value (Restart)
@heading use-value (Restart)
@syindex use-value
@cindex use-value


@subsubheading Data Arguments Required:

a value to use instead (once).

@subsubheading Description:

@Therestart{use-value} is generally used by @term{handlers} trying
to recover from errors of @term{types} such as @code{cell-error},
where the handler may wish to supply a replacement datum for one-time use.

@subsubheading See Also:

@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{invoke-restart},
@ref{use-value} (@term{function}),
@ref{store-value} (@term{function} and @term{restart})


@node abort; continue; muffle-warning; store-value; use-value
@heading abort, continue, muffle-warning, store-value, use-value (Function)
@syindex abort
@cindex abort
@syindex continue
@cindex continue
@syindex muffle-warning
@cindex muffle-warning
@syindex store-value
@cindex store-value
@syindex use-value
@cindex use-value
@anchor{abort}
@anchor{continue}
@anchor{muffle-warning}
@anchor{store-value}
@anchor{use-value}

@cindex abort
@cindex continue
@cindex muffle-warning
@cindex store-value
@cindex use-value

@subsubheading Syntax:

@DefunNoReturn{abort, @opt{} condition}
@DefunWithValues{continue, @opt{} condition, @nil{}}
@DefunNoReturn{muffle-warning, @opt{} condition}
@DefunWithValues{store-value, value @opt{} condition, @nil{}}
@DefunWithValues{use-value, value @opt{} condition, @nil{}}

@subsubheading Arguments and Values:

@param{value}---an @term{object}.

@param{condition}---a @term{condition} @term{object}, or @nil{}.

@subsubheading Description:

Transfers control to the most recently established @term{applicable restart}
having the same name as the function.  That is,
@thefunction{abort}    searches for an @term{applicable} @t{abort}    @term{restart},
@thefunction{continue} searches for an @term{applicable} @t{continue} @term{restart},
and so on.

If no such @term{restart} exists,
the functions
@code{continue},
@code{store-value},
and @code{use-value}
return @nil{}, and
the functions
@code{abort}
and @code{muffle-warning}
signal an error @oftype{control-error}.

When @param{condition} is @term{non-nil},
only those @term{restarts} are considered that are
either explicitly associated with that @param{condition},
or not associated with any @term{condition};
that is, the excluded @term{restarts} are
those that are associated with a non-empty set of @term{conditions}
of which the given @param{condition} is not an @term{element}.
If @param{condition} is @nil{}, all @term{restarts} are considered.

@subsubheading Examples:

@lisp
;;; Example of the ABORT retart

 (defmacro abort-on-error (&body forms)
   `(handler-bind ((error #'abort))
      ,@@forms)) @EV{} ABORT-ON-ERROR
 (abort-on-error (+ 3 5)) @EV{} 8
 (abort-on-error (error "You lose."))
@OUT{} Returned to Lisp Top Level.

;;; Example of the CONTINUE restart

 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4) @EV{} 2
 (real-sqrt -9)
@OUT{} Error: Tried to take sqrt(-9).
@OUT{} To continue, type :CONTINUE followed by an option number:
@OUT{}  1: Return sqrt(9) instead.
@OUT{}  2: Return to Lisp Toplevel.
@OUT{} Debug> @IN{(continue)}
@OUT{} Return sqrt(9) instead.
@EV{} 3

 (handler-bind ((error #'(lambda (c) (continue))))
   (real-sqrt -9)) @EV{} 3

;;; Example of the MUFFLE-WARNING restart

 (defun count-down (x)
   (do ((counter x (1- counter)))
       ((= counter 0) 'done)
     (when (= counter 1)
       (warn "Almost done"))
     (format t "~&~D~%" counter)))
@EV{} COUNT-DOWN
 (count-down 3)
@OUT{} 3
@OUT{} 2
@OUT{} Warning: Almost done
@OUT{} 1
@EV{} DONE
 (defun ignore-warnings-while-counting (x)
   (handler-bind ((warning #'ignore-warning))
     (count-down x)))
@EV{} IGNORE-WARNINGS-WHILE-COUNTING
 (defun ignore-warning (condition)
   (declare (ignore condition))
   (muffle-warning))
@EV{} IGNORE-WARNING
 (ignore-warnings-while-counting 3)
@OUT{} 3
@OUT{} 2
@OUT{} 1
@EV{} DONE

;;; Example of the STORE-VALUE and USE-VALUE restarts

 (defun careful-symbol-value (symbol)
   (check-type symbol symbol)
   (restart-case (if (boundp symbol)
                     (return-from careful-symbol-value
                                  (symbol-value symbol))
                     (error 'unbound-variable
                            :name symbol))
     (use-value (value)
       :report "Specify a value to use this time."
       value)
     (store-value (value)
       :report "Specify a value to store and use in the future."
       (setf (symbol-value symbol) value))))
 (setq a 1234) @EV{} 1234
 (careful-symbol-value 'a) @EV{} 1234
 (makunbound 'a) @EV{} A
 (careful-symbol-value 'a)
@OUT{} Error: A is not bound.
@OUT{} To continue, type :CONTINUE followed by an option number.
@OUT{}  1: Specify a value to use this time.
@OUT{}  2: Specify a value to store and use in the future.
@OUT{}  3: Return to Lisp Toplevel.
@OUT{} Debug> @IN{(use-value 12)}
@EV{} 12
 (careful-symbol-value 'a)
@OUT{} Error: A is not bound.
@OUT{} To continue, type :CONTINUE followed by an option number.
@OUT{}   1: Specify a value to use this time.
@OUT{}   2: Specify a value to store and use in the future.
@OUT{}   3: Return to Lisp Toplevel.
@OUT{} Debug> @IN{(store-value 24)}
@EV{} 24
 (careful-symbol-value 'a)
@EV{} 24

;;; Example of the USE-VALUE restart

 (defun add-symbols-with-default (default &rest symbols)
   (handler-bind ((sys:unbound-symbol
                    #'(lambda (c)
                        (declare (ignore c))
                        (use-value default))))
     (apply #'+ (mapcar #'careful-symbol-value symbols))))
@EV{} ADD-SYMBOLS-WITH-DEFAULT
 (setq x 1 y 2) @EV{} 2
 (add-symbols-with-default 3 'x 'y 'z) @EV{} 6


@end lisp


@subsubheading Side Effects:

A transfer of control may occur if an appropriate @term{restart} is available,
or (in the case of @thefunction{abort} or @thefunction{muffle-warning})
execution may be stopped.

@subsubheading Affected By:

Each of these functions can be affected by
the presence of a @term{restart} having the same name.

@subsubheading Exceptional Situations:

If an appropriate @t{abort} @term{restart}
is not available for @thefunction{abort},
or an appropriate @t{muffle-warning} @term{restart}
is not available for @thefunction{muffle-warning},
an error @oftype{control-error} is signaled.

@subsubheading See Also:

@ref{invoke-restart},
@ref{Restarts, Section 9.1.4.2 (Restarts)},
@ref{InterfacesToRestarts, Section 9.1.4.2.2 (Interfaces to Restarts)},
@ref{assert},
@ref{ccase},
@ref{cerror},
@ref{check-type},
@ref{ctypecase},
@ref{use-value},
@ref{warn}

@subsubheading Notes:

@lisp
 (abort condition) @EQ{} (invoke-restart 'abort)
 (muffle-warning)  @EQ{} (invoke-restart 'muffle-warning)
 (continue)        @EQ{} (let ((r (find-restart 'continue))) (if r (invoke-restart r)))
 (use-value @param{x}) @EQ{} (let ((r (find-restart 'use-value))) (if r (invoke-restart r @param{x})))
 (store-value x) @EQ{} (let ((r (find-restart 'store-value))) (if r (invoke-restart r @param{x})))
@end lisp


No functions defined in this specification are required to provide
a @t{use-value} @term{restart}.
