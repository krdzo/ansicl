@node Evaluation and Compilation
@chapter Evaluation and Compilation
@menu
* Evaluation::
* Compilation::
* Declarations::
* Lambda Lists::
* Error Checking in Function Calls::
* Traversal Rules and Side Effects::
* Destructive Operations::
* Evaluation and Compilation Dictionary::
@end menu

@node Evaluation
@section Evaluation


@term{Execution} of @term{code} can be accomplished by a variety of means ranging
from direct interpretation of a @term{form} representing a @term{program}
to invocation of @term{compiled code} produced by a @term{compiler}.

@cindex evaluation
@dfn{Evaluation} is the process by which a @term{program} is @term{executed} in @clisp{}.
The mechanism of @term{evaluation} is manifested
both implicitly through the effect of the @term{Lisp read-eval-print loop},
and  explicitly through the presence of the @term{functions}
@code{eval},
@code{compile},
@code{compile-file},
and @code{load}.
Any of these facilities might share the same execution strategy,
or each might use a different one.

The behavior of a @term{conforming program} processed by @code{eval}
and by @code{compile-file} might differ; see @ref{Semantic Constraints}.

@term{Evaluation} can be understood in terms of a model in which an
interpreter recursively traverses a @term{form} performing each
step of the computation as it goes.
This model, which describes the semantics of @clisp{}@spc{}@term{programs},
is described in @ref{The Evaluation Model}.

@menu
* Introduction to Environments::
* The Evaluation Model::
* Lambda Expressions::
* Closures and Lexical Binding::
* Shadowing::
* Extent::
* Return Values::
@end menu
@node Introduction to Environments
@subsection Introduction to Environments

A @newterm{binding} is an association between a @term{name} and
that which the name denotes.  @term{Bindings} are @term{established}
in a @term{lexical environment} or a @term{dynamic environment}
by particular @term{special operators}.

An @newterm{environment} is a set of @term{bindings} and other information
used during evaluation (@eg{} to associate meanings with names).

@term{Bindings} in an @term{environment} are partitioned into
@cindex namespace
@dfn{namespaces}.
A single @term{name} can simultaneously have more than one
associated @term{binding} per @term{environment},
but can have only one associated @term{binding} per @term{namespace}.

@node The Global Environment
@subsubsection The Global Environment

The @newterm{global environment} is that part of an @term{environment}
that contains @term{bindings} with both @term{indefinite scope}
and @term{indefinite extent}.
The @term{global environment} contains, among other things, the following:


@itemize @bullet{}
@item @term{bindings} of @term{dynamic variables} and @term{constant variables}.
@item @term{bindings} of @term{functions}, @term{macros}, and @term{special operators}.
@item
@term{bindings} of @term{compiler macros}.
@item @term{bindings} of @term{type} and @term{class} @term{names}
@item information about @term{proclamations}.
@end itemize



@node Dynamic Environments
@subsubsection Dynamic Environments

A @newterm{dynamic environment} for @term{evaluation} is that part of an
@term{environment} that contains @term{bindings} whose duration
is bounded by points of @term{establishment} and @term{disestablishment}
within the execution of the @term{form} that
established the @term{binding}.
A @term{dynamic environment} contains, among other things, the following:


@itemize @bullet{}
@item @term{bindings} for @term{dynamic variables}.
@item information about @term{active} @term{catch tags}.
@item information about @term{exit points} established by @code{unwind-protect}.
@item information about @term{active} @term{handlers} and @term{restarts}.
@end itemize


The @term{dynamic environment} that is active at any given point
in the @term{execution} of a @term{program} is referred to by
definite reference as ``the current @term{dynamic environment},''
or sometimes as just ``the @term{dynamic environment}.''

Within a given @term{namespace},
a @term{name} is said to be @term{bound}
in a @term{dynamic environment} if there is a @term{binding}
associated with its @term{name} in the @term{dynamic environment}
or, if not, there is a @term{binding}
associated with its name in the @term{global environment}.


@node Lexical Environments
@subsubsection Lexical Environments

A @newterm{lexical environment} for @term{evaluation} at some position in a @term{program}
is that part of the @term{environment} that contains information having
@term{lexical scope} within the @term{forms} containing that position.
A @term{lexical environment} contains, among other things, the following:


@itemize @bullet{}
@item @term{bindings} of @term{lexical variables} and @term{symbol macros}.
@item @term{bindings} of @term{functions} and @term{macros}.
(Implicit in this is information about those @term{compiler macros}
that are locally disabled.)
@item @term{bindings} of @term{block tags}.
@item @term{bindings} of @term{go tags}.
@item information about @term{declarations}.
@end itemize


The @term{lexical environment} that is active at any given position
in a @term{program} being semantically processed is referred to by
definite reference as ``the current @term{lexical environment},''
or sometimes as just ``the @term{lexical environment}.''

Within a given @term{namespace},
a @term{name} is said to be @term{bound} in a @term{lexical environment}
if there is a @term{binding}
associated with its @term{name}
in the @term{lexical environment} or, if not, there is a @term{binding}
associated with its name in the @term{global environment}.

@node The Null Lexical Environment
@subsubsection The Null Lexical Environment

@anchor{NullLexicalEnv}

The @newterm{null lexical environment} is equivalent to the @term{global environment}.

Although in general the representation of an @term{environment} @term{object}
is @term{implementation-dependent}, @nil{}@spc{}can be used in any situation where an
@term{environment} @term{object} is called for in order to denote
the @term{null lexical environment}.



@node Environment Objects
@subsubsection Environment Objects
@anchor{EnvObjs}

Some @term{operators} make use of an @term{object},
called an @newterm{environment object},
that represents the set of @term{lexical bindings} needed to perform
semantic analysis on a @term{form} in a given @term{lexical environment}.
The set of @term{bindings} in an @term{environment object}
may be a subset of the @term{bindings} that would be needed to actually
perform an @term{evaluation}; for example, @term{values} associated with
@term{variable} @term{names} and @term{function names} in the corresponding
@term{lexical environment} might not be available in an @term{environment object}.

The @term{type} and nature of an @term{environment object} is @term{implementation-dependent}.
The @term{values} of @term{environment parameters} to @term{macro functions}
are examples of @term{environment objects}.

The @term{object} @nil{}@spc{}when used as an @term{environment object}
denotes the @term{null lexical environment};
see @ref{The Null Lexical Environment}.



@node The Evaluation Model
@subsection The Evaluation Model

A @clisp{}@spc{}system evaluates @term{forms} with respect to lexical,
dynamic, and global @term{environments}.  The following sections
describe the components of the @clisp{}@spc{}evaluation model.

@node Form Evaluation
@subsubsection Form Evaluation

@term{Forms} fall into three categories:
@term{symbols}, @term{conses}, and @term{self-evaluating objects}.
The following sections explain these categories.

@node Symbols as Forms
@subsubsection Symbols as Forms

@anchor{SymbolsAsForms}

If a @term{form} is a @term{symbol},
then it is either a @term{symbol macro} or a @term{variable}.

The @term{symbol} names a @term{symbol macro}
if there is a @term{binding} of the @term{symbol} as a @term{symbol macro}
in the current @term{lexical environment}
(see @code{define-symbol-macro} and @code{symbol-macrolet}).
If the @term{symbol} is a @term{symbol macro},
its expansion function is obtained.
The expansion function is a function of two arguments, and is invoked
by calling the @term{macroexpand hook} with
the expansion function as its first argument,
the @term{symbol} as its second argument,
and an @term{environment object} (corresponding to the current @term{lexical environment})
as its third argument.
The @term{macroexpand hook}, in turn, calls the expansion function with the
@term{form} as its first argument and the @term{environment} as its second argument.
The @term{value} of the expansion function, which is passed through
by the @term{macroexpand hook}, is a @term{form}.
This resulting @term{form} is processed in place of the original @term{symbol}.

If a @term{form} is a @term{symbol} that is not a @term{symbol macro},
then it is the @term{name} of a @term{variable}, and the @term{value} of that
@term{variable} is returned. There are three kinds of variables:
@term{lexical variables},
@term{dynamic variables},
and
@term{constant variables}.
A @term{variable} can store one @term{object}.
The main operations on a @term{variable} are
to @term{read}@sub{1} and
to @term{write}@sub{1}
its @term{value}.

An error @oftype{unbound-variable} should be signaled if
an @term{unbound variable} is referenced.

@term{Non-constant variables} can be @term{assigned} by using @code{setq}
or @term{bound}@sub{3} by using @code{let}.
@Thenextfigure{}@spc{}lists some @term{defined names} that
are applicable to assigning, binding, and defining @term{variables}.


@float Figure,fig3.1
@cartouche
@multitable{defparameter}{multiple-value-bind}{symbol-value}

@item boundp @tab let @tab progv
@item defconstant @tab let* @tab psetq
@item defparameter @tab makunbound @tab set
@item defvar @tab multiple-value-bind @tab setq
@item lambda @tab multiple-value-setq @tab symbol-value
@end multitable
@end cartouche
@caption{Some Defined Names Applicable to Variables}
@end float


The following is a description of each kind of variable.

@node Lexical Variables
@subsubsection Lexical Variables


A @term{lexical variable} is a @term{variable} that can be referenced only within
the @term{lexical scope} of the @term{form} that establishes that @term{variable};
@term{lexical variables} have @term{lexical scope}.
Each time a @term{form} creates a @term{lexical binding} of a @term{variable},
a @term{fresh} @term{binding} is @term{established}.

Within the @term{scope} of a @term{binding} for a @term{lexical variable} @term{name},
uses of that @term{name} as a @term{variable} are considered to be references
to that @term{binding} except where the @term{variable} is @term{shadowed}@sub{2}
by a @term{form} that @term{establishes} a @term{fresh} @term{binding} for that
@term{variable} @term{name},
or by a @term{form} that locally @term{declares} the @term{name} @code{special}.

A @term{lexical variable} always has a @term{value}.
There is no @term{operator} that introduces a @term{binding} for a
@term{lexical variable} without giving it an initial @term{value}, nor
is there any @term{operator} that can make a @term{lexical variable} be @term{unbound}.

@term{Bindings} of @term{lexical variables} are found in the @term{lexical environment}.


@node Dynamic Variables
@subsubsection Dynamic Variables


A @term{variable} is a @term{dynamic variable} if one of the following
conditions hold:


@itemize @bullet{}

@item It is locally declared or globally proclaimed @code{special}.

@item It occurs textually within a @term{form} that
creates a @term{dynamic binding} for a @term{variable} of the @term{same} @term{name},
and the @term{binding} is not @term{shadowed}@sub{2} by a @term{form}
that creates a @term{lexical binding} of the same @term{variable} @term{name}.
@end itemize


A @term{dynamic variable} can be referenced at any time in any @term{program};
there is no textual limitation on references to @term{dynamic variables}.
At any given time, all @term{dynamic variables} with a given name refer to
exactly one @term{binding}, either in the @term{dynamic environment}
or in the @term{global environment}.

The @term{value} part of the @term{binding} for a @term{dynamic variable} might
be empty; in this case, the @term{dynamic variable} is said to have no @term{value},
or to be @term{unbound}.  A @term{dynamic variable} can be made @term{unbound}
by using @code{makunbound}.

The effect of @term{binding} a @term{dynamic variable} is to create
a new @term{binding} to which all references to that @term{dynamic variable}
in any @term{program} refer for the duration of the @term{evaluation} of the @term{form}
that creates the @term{dynamic binding}.

A @term{dynamic variable} can be referenced outside the @term{dynamic extent} of
a @term{form} that @term{binds} it.  Such a @term{variable} is sometimes called
a ``global variable'' but is still in all respects just a @term{dynamic variable}
whose @term{binding} happens to exist in the @term{global environment} rather than in some
@term{dynamic environment}.

A @term{dynamic variable} is @term{unbound}
unless and until explicitly assigned a value, except for
those variables whose initial value is
defined in this specification or by an @term{implementation}.


@node Constant Variables
@subsubsection Constant Variables

@anchor{ConstantVars}

Certain variables, called @term{constant variables}, are reserved as ``named constants.''
The consequences are undefined if an attempt is made to
assign a value to,
or create
a @term{binding} for a @term{constant variable},
except that a `compatible' redefinition of a @term{constant variable}
using @code{defconstant} is permitted; see the @term{macro} @ref{defconstant}.

@term{Keywords},
@term{symbols} defined by @clisp{}@spc{}or the @term{implementation}
as constant (such as @nil{}, @code{t}, and @code{pi}),
and @term{symbols} declared as constant using @code{defconstant}
are @term{constant variables}.


@node Symbols Naming Both Lexical and Dynamic Variables
@subsubsection Symbols Naming Both Lexical and Dynamic Variables


The same @term{symbol} can name both
a @term{lexical variable}
and a @term{dynamic variable},
but never in the same @term{lexical environment}.

In the following example, the @term{symbol} @f{x} is used,
at different times,
as the @term{name} of a @term{lexical variable}
and as the @term{name} of a @term{dynamic variable}.

@lisp
 (let ((x 1))            ;Binds a special variable X
   (declare (special x))
   (let ((x 2))          ;Binds a lexical variable X
     (+ x                ;Reads a lexical variable X
        (locally (declare (special x))
                 x))))   ;Reads a special variable X
@EV{} 3
@end lisp




@node Conses as Forms
@subsubsection Conses as Forms


A @term{cons} that is used as a @term{form} is called a @term{compound form}.

If the @term{car} of that @term{compound form} is a @term{symbol},
that @term{symbol} is the @term{name} of an @term{operator},
and the @term{form} is either a @term{special form}, a @term{macro form},
or a @term{function form}, depending on the @term{function} @term{binding}
of the @term{operator} in the current @term{lexical environment}.
If the @term{operator} is neither a @term{special operator}
nor a @term{macro name}, it is assumed to be a @term{function name}
(even if there is no definition for such a @term{function}).

If the @term{car} of the @term{compound form} is not a @term{symbol},
then that @term{car} must be a @term{lambda expression},
in which case the @term{compound form} is a @term{lambda form}.

How a @term{compound form} is processed depends on whether it is
classified as a @term{special form}, a @term{macro form},
a @term{function form}, or a @term{lambda form}.

@node Special Forms
@subsubsection Special Forms


A @term{special form} is a @term{form} with special syntax,
special evaluation rules, or both, possibly manipulating the
evaluation environment, control flow, or both.
A @term{special operator} has access to
the current @term{lexical environment}
and the current @term{dynamic environment}.
Each @term{special operator} defines the manner in which its @term{subexpressions}
are treated---which are @term{forms}, which are special syntax, @etc{}.

Some @term{special operators} create new
lexical or dynamic @term{environments} for use during the
@term{evaluation} of @term{subforms}
of the @term{special form}.  For example, @code{block} creates a
new @term{lexical environment} that is the same as the one in force
at the point of evaluation of the @code{block} @term{form}
with the addition of a @term{binding} of the @code{block} name
to an @term{exit point} from the @code{block}.

The set of @term{special operator} @term{names} is fixed in @clisp{};
no way is provided for the user to define a @term{special operator}.
@Thenextfigure{}@spc{}lists all of the @clisp{}@spc{}@term{symbols}
that have definitions as @term{special operators}.



@float Figure,CLSpecialOps
@cartouche
@multitable{eval-when}{multiple-value-prog1}{symbol-macrolet}

@item block @tab let* @tab return-from
@item catch @tab load-time-value @tab setq
@item eval-when @tab locally @tab symbol-macrolet
@item flet @tab macrolet @tab tagbody
@item function @tab multiple-value-call @tab the
@item go @tab multiple-value-prog1 @tab throw
@item if @tab progn @tab unwind-protect
@item labels @tab progv @tab
@item let @tab quote @tab
@end multitable
@end cartouche
@caption{Common Lisp Special Operators}
@end float



@node Macro Forms
@subsubsection Macro Forms


If the @term{operator} names a @term{macro},
its associated @term{macro function} is applied
to the entire @term{form} and the result of that application is
used in place of the original @term{form}.

Specifically, a @term{symbol} names a @term{macro} in a given @term{lexical environment} if
@code{macro-function} is @term{true} of the
@term{symbol} and that @term{environment}.
The @term{function} returned by @code{macro-function}
is a @term{function} of two arguments, called the
expansion function.
The expansion function is invoked by calling the @term{macroexpand hook} with
the expansion function as its first argument,
the entire @term{macro form} as its second argument,
and an @term{environment object} (corresponding to the current @term{lexical environment})
as its third argument.
The @term{macroexpand hook}, in turn, calls the expansion function with the
@term{form} as its first argument and the @term{environment} as its second argument.
The @term{value} of the expansion function, which is passed through
by the @term{macroexpand hook}, is a @term{form}.
The returned @term{form} is @term{evaluated} in place of the original @term{form}.

The consequences are undefined if a @term{macro function} destructively modifies
any part of its @term{form} argument.

A @term{macro name} is not a @term{function designator},
and cannot be used as the @param{function} argument to @term{functions}
such as @code{apply}, @code{funcall}, or @code{map}.

An @term{implementation} is free to implement a @clisp{}@spc{}@term{special operator}
as a @term{macro}.  An @term{implementation} is free to implement any
@term{macro} @term{operator} as a @term{special operator}, but only
if an equivalent definition of the @term{macro} is also provided.

@Thenextfigure{}@spc{}lists some @term{defined names} that are applicable
to @term{macros}.


@float Figure,fig3.3
@cartouche
@multitable{*macroexpand-hook*}{macro-function}{macroexpand-1}

@item *macroexpand-hook* @tab macro-function @tab macroexpand-1
@item defmacro @tab macroexpand @tab macrolet
@end multitable
@end cartouche
@caption{Defined names applicable to macros}
@end float



@node Function Forms
@subsubsection Function Forms

@anchor{FunctionForms}

If the @term{operator} is a @term{symbol} naming a @term{function},
the @term{form} represents a @term{function form},
and the @term{cdr} of the list contains the @term{forms}
which when evaluated will supply the arguments passed to the @term{function}.

When a @term{function name} is not defined,
an error @oftype{undefined-function} should be signaled at run time;
see @ref{Semantic Constraints}.

A @term{function form} is evaluated as follows:

The @term{subforms} in the @term{cdr} of the original @term{form}
are evaluated in left-to-right order in the current lexical and
dynamic @term{environments}.  The @term{primary value} of each
such @term{evaluation} becomes an @term{argument} to the named @term{function};
any additional @term{values} returned by the @term{subforms} are discarded.

The @term{functional value} of the @term{operator}
is retrieved from the @term{lexical environment},
and that @term{function} is invoked with the indicated arguments.

Although the order of @term{evaluation} of
the @term{argument} @term{subforms} themselves is
strictly left-to-right, it is not specified whether
the definition of the @term{operator} in a @term{function form} is looked up
before the @term{evaluation} of the @term{argument} @term{subforms},
after the @term{evaluation} of the @term{argument} @term{subforms},
or between the @term{evaluation} of any two @term{argument} @term{subforms}
if there is more than one such @term{argument} @term{subform}.
For example, the following might return 23 or@tie{}24.

@lisp
 (defun foo (x) (+ x 3))
 (defun bar () (setf (symbol-function 'foo) #'(lambda (x) (+ x 4))))
 (foo (progn (bar) 20))
@end lisp


A @term{binding} for a @term{function name} can be @term{established} in
one of several ways.  A @term{binding} for a @term{function name} in
the @term{global environment} can be @term{established} by
@code{defun},
@SETFof{fdefinition},
@SETFof{symbol-function},
@code{ensure-generic-function},
@code{defmethod} (implicitly, due to @code{ensure-generic-function}),
or
@code{defgeneric}.
A @term{binding} for a @term{function name} in the @term{lexical environment}
can be @term{established} by
@code{flet}
or @code{labels}.

@Thenextfigure{}@spc{}lists some @term{defined names} that are applicable to @term{functions}.


@float Figure,fig3.4
@cartouche
@multitable{call-arguments-limit}{fdefinition}{multiple-value-call}

@item apply @tab fdefinition @tab mapcan
@item call-arguments-limit @tab flet @tab mapcar
@item complement @tab fmakunbound @tab mapcon
@item constantly @tab funcall @tab mapl
@item defgeneric @tab function @tab maplist
@item defmethod @tab functionp @tab multiple-value-call
@item defun @tab labels @tab reduce
@item fboundp @tab map @tab symbol-function
@end multitable
@end cartouche
@caption{Some function-related defined names}
@end float



@node Lambda Forms
@subsubsection Lambda Forms

@anchor{LambdaForms}

A @term{lambda form} is similar to a @term{function form}, except that
the @term{function name} is replaced by a @term{lambda expression}.

A @term{lambda form} is equivalent to using @term{funcall} of a
@term{lexical closure} of the @term{lambda expression} on the given @term{arguments}.
(In practice, some compilers are more likely to produce inline code
for a @term{lambda form} than for an arbitrary named function
that has been declared @code{inline}; however, such a difference
is not semantic.)

For further information, see @ref{Lambda Expressions}.



@node Self-Evaluating Objects
@subsubsection Self-Evaluating Objects


A @term{form} that is neither a @term{symbol} nor a @term{cons} is
defined to be a @term{self-evaluating object}.  @term{Evaluating}
such an @term{object} @term{yields} the @term{same} @term{object}
as a result.

Certain specific @term{symbols} and @term{conses} might also happen
to be ``self-evaluating'' but only as a special case of a more
general set of rules for the @term{evaluation} of @term{symbols} and
@term{conses}; such @term{objects} are not considered to be
@term{self-evaluating objects}.

The consequences are undefined if @term{literal objects} (including
@term{self-evaluating objects}) are destructively modified.

@node Examples of Self-Evaluating Objects
@subsubsection Examples of Self-Evaluating Objects


@term{Numbers}, @term{pathnames}, and @term{arrays} are examples of
@term{self-evaluating objects}.

@lisp
 3 @EV{} 3
 #c(2/3 5/8) @EV{} #C(2/3 5/8)
 #p"S:[BILL]OTHELLO.TXT" @EV{} #P"S:[BILL]OTHELLO.TXT"
 #(a b c) @EV{} #(A B C)
 "fred smith" @EV{} "fred smith"
@end lisp






@node Lambda Expressions
@subsection Lambda Expressions

In a @term{lambda expression},
the body is evaluated in a lexical @term{environment} that is formed by
adding the @term{binding} of
each @term{parameter} in the @term{lambda list}
with the corresponding @term{value} from the @term{arguments}
to the current lexical @term{environment}.

For further discussion of how @term{bindings} are @term{established}
based on the @term{lambda list}, see @ref{Lambda Lists}.

The body of a @term{lambda expression} is an @term{implicit progn};
the @term{values} it returns are returned by the @term{lambda expression}.


@node Closures and Lexical Binding
@subsection Closures and Lexical Binding

A @term{lexical closure} is a @term{function} that can refer to and alter
the values of @term{lexical bindings} @term{established} by @term{binding} @term{forms}
that textually include the function definition.

Consider this code, where @f{x} is not declared @code{special}:

@lisp
 (defun two-funs (x)
   (list (function (lambda () x))
         (function (lambda (y) (setq x y)))))
 (setq funs (two-funs 6))
 (funcall (car funs)) @EV{} 6
 (funcall (cadr funs) 43) @EV{} 43
 (funcall (car funs)) @EV{} 43
@end lisp


@Thespecform{function} coerces a
@term{lambda expression} into a @term{closure} in which the
@term{lexical environment} in effect when the @term{special form} is
evaluated is captured along with the @term{lambda expression}.

The function @f{two-funs} returns a @term{list} of two
@term{functions}, each of which refers to the @term{binding} of the
variable @f{x} created on entry to the function @f{two-funs} when it
was called.
This variable has the value @f{6}
initially, but @code{setq} can alter this @term{binding}.
The @term{lexical closure} created for the first
@term{lambda expression} does not ``snapshot'' the @term{value} @f{6} for @f{x}
when the @term{closure} is created; rather it captures the @term{binding} of @f{x}.
The second @term{function} can be used to alter the @term{value} in the same (captured)
@term{binding} (to @f{43}, in the example), and
this altered variable binding then affects the value returned by the first @term{function}.


In situations where a @term{closure} of a
@term{lambda expression} over the same set of @term{bindings} may be
produced more than once, the various resulting @term{closures} may
or may not be @term{identical}, at the discretion of the @term{implementation}.
That is, two @term{functions} that are behaviorally
indistinguishable might or might not be @term{identical}.
Two @term{functions} that are behaviorally distinguishable are @term{distinct}.
For example:

@lisp
 (let ((x 5) (funs '()))
   (dotimes (j 10)
     (push #'(lambda (z)
               (if (null z) (setq x 0) (+ x z)))
           funs))
   funs)
@end lisp

The result of the above @term{form} is a @term{list} of ten @term{closures}.
Each requires only the @term{binding} of @f{x}.
It is the same @term{binding} in each case,
but the ten @term{closure} @term{objects} might or might not be @term{identical}.
On the other hand, the result of the @term{form}

@lisp
 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z)
                        (if (null z) (setq x 0) (+ x z))))
             funs)))
  funs)
@end lisp

is also a @term{list} of ten @term{closures}.
However, in this case no two of the @term{closure} @term{objects} can
be @term{identical} because each @term{closure} is closed over a distinct
@term{binding} of @f{x}, and these @term{bindings} can be behaviorally
distinguished because of the use of @code{setq}.

The result of the @term{form}

@lisp
 (let ((funs '()))
   (dotimes (j 10)
     (let ((x 5))
       (push (function (lambda (z) (+ x z)))
            funs)))
   funs)
@end lisp

is a @term{list} of ten @term{closure} @term{objects} that
might or might not be @term{identical}.
A different @term{binding} of @f{x} is involved for
each @term{closure}, but the @term{bindings} cannot be distinguished
because their values are the @term{same} and immutable (there being no occurrence
of @code{setq} on @f{x}).  A compiler could internally
transform the @term{form} to

@lisp
 (let ((funs '()))
   (dotimes (j 10)
     (push (function (lambda (z) (+ 5 z)))
           funs))
  funs)
@end lisp

where the @term{closures} may be @term{identical}.

It is possible that a @term{closure} does not
close over any variable bindings.
In the code fragment

@lisp
 (mapcar (function (lambda (x) (+ x 2))) y)
@end lisp

the function @f{(lambda (x) (+ x 2))} contains no references to any outside
object. In this case, the same @term{closure} might be returned
for all evaluations of the @code{function} @term{form}.


@node Shadowing
@subsection Shadowing


If two @term{forms} that @term{establish} @term{lexical bindings} with
the same @term{name} @mat{N} are textually nested, then references to @mat{N}
within the inner @term{form} refer to the @term{binding} established by
the inner @term{form}; the inner @term{binding} for @mat{N}
@cindex shadow
@dfn{shadows} the outer @term{binding} for @mat{N}.  Outside the inner
@term{form} but inside the outer one, references to @mat{N} refer to the
@term{binding} established by the outer @term{form}.  For example:

@lisp
 (defun test (x z)
   (let ((z (* x 2)))
     (print z))
   z)
@end lisp

The @term{binding} of the variable @f{z} by
@code{let} shadows
the @term{parameter} binding for the function @f{test}.  The reference to the
variable @f{z} in the @code{print} @term{form} refers to the @code{let} binding.
The reference to @f{z} at the end of the function @f{test}
refers to the @term{parameter} named @f{z}.

Constructs that are lexically scoped act as if new names were
generated for each @term{object} on each execution.  Therefore,
dynamic shadowing cannot occur.  For example:

@lisp
 (defun contorted-example (f g x)
   (if (= x 0)
       (funcall f)
       (block here
          (+ 5 (contorted-example g
                                  #'(lambda () (return-from here 4))
                                  (- x 1))))))
@end lisp

Consider the call @f{(contorted-example nil nil 2)}.  This produces
@f{4}.  During the course of execution, there are three
calls to @f{contorted-example}, interleaved with two
blocks:

@lisp
 (contorted-example nil nil 2)
   (block here@ssso{} ...)
     (contorted-example nil #'(lambda () (return-from here@ssso{} 4)) 1)
       (block here@ssst{} ...)
         (contorted-example #'(lambda () (return-from here@ssso{} 4))
                            #'(lambda () (return-from here@ssst{} 4))
                            0)
             (funcall f)
                    where f @EV{} #'(lambda () (return-from here@ssso{} 4))
                 (return-from here@ssso{} 4)
@end lisp

At the time the @f{funcall} is executed
there are two @code{block} @term{exit points} outstanding, each apparently
named @f{here}.
The @code{return-from} @term{form} executed as a result of the @f{funcall}
operation
refers to the outer outstanding @term{exit point}
(here@ssso{}), not the
inner one (here@ssst{}).
It
refers to that @term{exit point} textually visible at the point of
execution of @code{function}
(here abbreviated by the @f{#'} syntax) that resulted
in creation of the @term{function} @term{object} actually invoked by
@code{funcall}.

If, in this example, one were to change the @f{(funcall f)} to
@f{(funcall g)}, then the value of the call @f{(contorted-example nil nil 2)}
would be @f{9}.  The value would change because
@code{funcall} would cause the
execution of @f{(return-from here@ssst{}@spc{}4)}, thereby causing
a return from the inner @term{exit point} (here@ssst{}).
When that occurs, the value @f{4} is returned from the
middle invocation of @f{contorted-example}, @f{5} is added to that
to get @f{9}, and that value is returned from the outer block
and the outermost call to @f{contorted-example}.  The point
is that the choice of @term{exit point}
returned from has nothing to do with its
being innermost or outermost; rather,
it depends on the lexical environment
that is packaged up with a @term{lambda expression} when
@code{function} is executed.


@node Extent
@subsection Extent
@f{Contorted-example} works only because the
@term{function} named by @f{f} is invoked during the @term{extent} of the
@term{exit point}.
Once the flow of execution has left the block,
the @term{exit point} is @term{disestablished}.  For example:

@lisp
 (defun invalid-example ()
   (let ((y (block here #'(lambda (z) (return-from here z)))))
     (if (numberp y) y (funcall y 5))))
@end lisp

One might expect the call @f{(invalid-example)} to produce @f{5}
by the following incorrect reasoning:
@code{let} binds @f{y} to the
value of @code{block}; this value is a @term{function} resulting
from the @term{lambda expression}.  Because @f{y} is not a number, it is
invoked on the value @f{5}.  The @code{return-from} should then
return this value from the
@term{exit point} named @f{here}, thereby
exiting from the block again and giving @f{y} the value @f{5}
which, being a number, is then returned as the value of the call
to @f{invalid-example}.

The argument fails only because @term{exit points} have
@term{dynamic extent}.  The argument is correct up to the execution of
@code{return-from}.  The execution of @code{return-from}
should signal an error @oftype{control-error}, however, not
because it cannot refer to the @term{exit point}, but because it
does correctly refer to an @term{exit point} and that
@term{exit point} has been @term{disestablished}.

A reference by name to a dynamic @term{exit point} binding such as
a @term{catch tag} refers to the most recently
@term{established} @term{binding} of that name that has not been
@term{disestablished}.  For example:

@lisp
 (defun fun1 (x)
   (catch 'trap (+ 3 (fun2 x))))
 (defun fun2 (y)
   (catch 'trap (* 5 (fun3 y))))
 (defun fun3 (z)
   (throw 'trap z))
@end lisp

Consider the call @f{(fun1 7)}.  The result is @f{10}.  At the time
the @code{throw} is executed, there are two outstanding catchers with the
name @f{trap}: one established within procedure @f{fun1}, and the other
within procedure @f{fun2}.  The latter is the more recent, and so the
value @f{7} is returned from @code{catch} in @f{fun2}.
Viewed from within @f{fun3}, the @code{catch}
in @f{fun2} shadows the one in @f{fun1}.
Had @f{fun2} been defined as

@lisp
 (defun fun2 (y)
   (catch 'snare (* 5 (fun3 y))))
@end lisp

then the two @term{exit points}
would have different @term{names}, and therefore the one
in @f{fun1} would not be shadowed.  The result would then have been @f{7}.


@node Return Values
@subsection Return Values

Ordinarily the result of calling a @term{function} is a single @term{object}.
Sometimes, however, it is convenient for a function to compute several
@term{objects} and return them.

In order to receive other than exactly one value from a @term{form},
one of several @term{special forms} or @term{macros} must be used to request those
values.  If a @term{form} produces @term{multiple values} which were not
requested in this way, then the first value is given to the caller and
all others are discarded; if the @term{form} produces zero values,
then the caller receives @nil{}@spc{}as a value.

@Thenextfigure{}@spc{}lists
some @term{operators} for receiving @term{multiple values}@sub{2}.
These @term{operators} can be used to specify
one or more @term{forms} to @term{evaluate}
and where to put the @term{values} returned by those @term{forms}.


@float Figure,fig3.5
@cartouche
@multitable{multiple-value-bind}{multiple-value-prog1}{return-from}

@item multiple-value-bind @tab multiple-value-prog1 @tab return-from
@item multiple-value-call @tab multiple-value-setq @tab throw
@item multiple-value-list @tab return @tab
@end multitable
@end cartouche
@caption{Some operators applicable to receiving multiple values}
@end float


@Thefunction{values} can produce @term{multiple values}@sub{2}.
@f{(values)} returns zero values;
@f{(values @param{form})} returns the @term{primary value} returned by @param{form};
@f{(values @param{form1} @param{form2})} returns two values,
the @term{primary value} of @param{form1}
and the @term{primary value} of @param{form2};
and so on.

See @code{multiple-values-limit} and @code{values-list}.



@node Compilation
@section Compilation


@menu
* Compiler Terminology::
* Compilation Semantics::
* File Compilation::
* Literal Objects in Compiled Files::
* Exceptional Situations in the Compiler::
@end menu
@node Compiler Terminology
@subsection Compiler Terminology


The following terminology is used in this section.

The @newterm{compiler} is a utility that translates code into an
@term{implementation-dependent} form that might be represented or
executed efficiently.
The term @newterm{compiler} refers to both of the @term{functions}
@code{compile} and @code{compile-file}.

The term @newterm{compiled code} refers to
@term{objects} representing compiled programs, such as @term{objects} constructed
by @code{compile} or by @code{load} when @term{loading} a @term{compiled file}.

The term @newterm{implicit compilation} refers to @term{compilation}
performed during @term{evaluation}.

The term @newterm{literal object} refers to
a quoted @term{object}
or a @term{self-evaluating object}
or an @term{object} that is a substructure of such an @term{object}.
A @term{constant variable} is not itself a @term{literal object}.

The term @newterm{coalesce} is defined as follows.
Suppose @f{A} and @f{B} are two @term{literal constants} in the @term{source code},
and that @f{A'} and @f{B'} are the corresponding @term{objects} in the @term{compiled code}.
If @f{A'} and @f{B'} are @code{eql} but
@f{A} and @f{B} are not @code{eql}, then it is said
that @f{A} and @f{B} have been coalesced by the compiler.

The term @newterm{minimal compilation} refers to actions the compiler
must take at @term{compile time}. These actions are specified in
@ref{Compilation Semantics}.

The verb @newterm{process} refers to performing @term{minimal compilation},
determining the time of evaluation for a @term{form},
and possibly @term{evaluating} that @term{form} (if required).

The term @newterm{further compilation} refers to
@term{implementation-dependent} compilation beyond @term{minimal compilation}.
That is, @term{processing} does not imply complete compilation.
Block compilation and generation of machine-specific instructions are
examples of further compilation.
Further compilation is permitted to take place at @term{run time}.

Four different @term{environments} relevant to compilation are
distinguished:
the @term{startup environment},
the @term{compilation environment},
the @term{evaluation environment}, and
the @term{run-time environment}.

The @newterm{startup environment} is
the @term{environment} of the @term{Lisp image}
from which the @term{compiler} was invoked.

The @newterm{compilation environment} is maintained by the compiler
and is used to hold definitions and declarations to be used internally
by the compiler.  Only those parts of a definition needed for correct
compilation are saved. The @term{compilation environment} is used
as the @term{environment} @term{argument} to macro expanders called by
the compiler. It is unspecified whether a definition available in the
@term{compilation environment} can be used in an @term{evaluation}
initiated in the @term{startup environment} or @term{evaluation environment}.

The @newterm{evaluation environment} is a @term{run-time environment}
in which macro expanders and code specified by @code{eval-when}
to be evaluated are evaluated.  All evaluations initiated by the
@term{compiler} take place in the @term{evaluation environment}.

The @newterm{run-time environment} is the
@term{environment} in which the program being compiled will be executed.

The @term{compilation environment} inherits from
the @term{evaluation environment},
and the @term{compilation environment} and @term{evaluation environment}
might be @term{identical}.
The @term{evaluation environment} inherits from
the @term{startup environment},
and the @term{startup environment} and @term{evaluation environment}
might be @term{identical}.

The term @newterm{compile time} refers to the duration of time that
the compiler is processing @term{source code}.
At @term{compile time},
only the @term{compilation environment}
and  the @term{evaluation environment}
are available.

The term @newterm{compile-time definition} refers to a definition in
the @term{compilation environment}.
For example, when compiling a file,
the definition of a function might be retained in the @term{compilation environment}
if it is declared @code{inline}.
This definition might not be available in the @term{evaluation environment}.

The term @newterm{run time} refers to the duration of time that the
loader is loading compiled code or compiled code is being executed.
At run time, only the @term{run-time environment} is available.

The term @newterm{run-time definition} refers to a definition in the
@term{run-time environment}.

The term @newterm{run-time compiler} refers to @thefunction{compile}
or @term{implicit compilation}, for which the compilation and run-time
@term{environments} are maintained in the same @term{Lisp image}.
Note that when the @term{run-time compiler} is used,
the @term{run-time environment}
and @term{startup environment}
are the same.


@node Compilation Semantics
@subsection Compilation Semantics

Conceptually, compilation is a process that traverses code, performs
certain kinds of syntactic and semantic analyses using information
(such as proclamations and @term{macro} definitions) present in the
@term{compilation environment}, and produces equivalent, possibly
more efficient code.


@node Compiler Macros
@subsubsection Compiler Macros
@anchor{CompilerMacros}

A @term{compiler macro} can be defined for a @term{name}
that also names a @term{function} or @term{macro}.
That is, it is possible for a
@term{function name} to name both a @term{function} and a @term{compiler macro}.

A @term{function name} names a @term{compiler macro} if @code{compiler-macro-function}
is @term{true} of the @term{function name} in the @term{lexical environment} in which
it appears.  Creating a @term{lexical binding} for the @term{function name}
not only creates a new local @term{function} or
@term{macro} definition, but also @term{shadows}@sub{2} the @term{compiler macro}.

The @term{function} returned by @code{compiler-macro-function}
is a @term{function} of two arguments, called the
expansion function.  To expand a @term{compiler macro},
the expansion function is invoked by calling the @term{macroexpand hook} with
the expansion function as its first argument,
the entire compiler macro @term{form} as its second argument,
and the current compilation @term{environment}
(or with the current lexical @term{environment},
if the @term{form} is being processed by something
other than @code{compile-file})
as its third argument.
The @term{macroexpand hook}, in turn, calls the expansion function with the
@term{form} as its first argument and the @term{environment} as its second argument.
The return value from the expansion function, which is passed through
by the @term{macroexpand hook}, might either be the @term{same} @term{form},
or else a form that can, at the discretion of the @term{code} doing the expansion,
be used in place of the original @term{form}.


@float Figure,fig3.6
@cartouche
@multitable{*macroexpand-hook*}{compiler-macro-function}{define-compiler-macro}

@item *macroexpand-hook* @tab compiler-macro-function @tab define-compiler-macro
@end multitable
@end cartouche
@caption{Defined names applicable to compiler macros}
@end float


@node Purpose of Compiler Macros
@subsubsection Purpose of Compiler Macros


The purpose of the @term{compiler macro} facility is to permit
selective source code transformations as optimization advice
to the @term{compiler}.  When a @term{compound form} is being
processed (as by the compiler), if the @term{operator} names a
@term{compiler macro} then the @term{compiler macro function} may be
invoked on the form, and the resulting expansion recursively processed
in preference to performing the usual processing on the original @term{form}
according to its normal interpretation as a @term{function form} or
@term{macro form}.

A @term{compiler macro function}, like a @term{macro function},
is a @term{function} of two @term{arguments}: the entire call @term{form}
and the @term{environment}. Unlike an ordinary @term{macro function}, a
@term{compiler macro function} can decline to provide an expansion merely by
returning a value that is the @term{same} as the original @term{form}.
The consequences are undefined if a @term{compiler macro function}
destructively modifies any part of its @term{form} argument.

The @term{form} passed to the compiler macro function can either be a @term{list}
whose @term{car} is the function name, or a @term{list} whose @term{car} is
@code{funcall} and whose @term{cadr} is a list @f{(function @param{name})};
note that this affects destructuring of the form argument by the
@term{compiler macro function}.
@code{define-compiler-macro} arranges for destructuring of arguments to be
performed correctly for both possible formats.

When @code{compile-file} chooses to expand a @term{top level form} that is
a @term{compiler macro} @term{form}, the expansion is also treated as a @term{top level form}
for the purposes of @code{eval-when} processing; see @ref{Processing of Top Level Forms}.


@node Naming of Compiler Macros
@subsubsection Naming of Compiler Macros


@term{Compiler macros} may be defined for @term{function names} that name
@term{macros} as well as @term{functions}.

@term{Compiler macro} definitions are strictly global.  There is no provision
for defining local @term{compiler macros} in the way that @code{macrolet}
defines local @term{macros}.  Lexical bindings of a function name shadow any
compiler macro definition associated with the name as well as its
global @term{function} or @term{macro} definition.

Note that the presence of a compiler macro definition does not affect
the values returned by
functions that access @term{function} definitions (@eg{} @code{fboundp})
or @term{macro} definitions (@eg{} @code{macroexpand}).
Compiler macros are global, and the function
@code{compiler-macro-function} is sufficient to resolve their interaction
with other lexical and global definitions.


@node When Compiler Macros Are Used
@subsubsection When Compiler Macros Are Used


The presence of a @term{compiler macro} definition for a @term{function} or @term{macro}
indicates that it is desirable for the @term{compiler} to use the expansion
of the @term{compiler macro} instead of the original @term{function form} or
@term{macro form}.  However, no language processor
(compiler, evaluator, or other code walker) is ever required to actually
invoke @term{compiler macro functions}, or to
make use of the resulting expansion if it does invoke
a @term{compiler macro function}.

When the @term{compiler} encounters a @term{form} during processing that represents
a call to a @term{compiler macro} @term{name} (that is not declared @code{notinline}),
the @term{compiler} might expand the @term{compiler macro},
and might use the expansion in place of the original @term{form}.

When @code{eval} encounters a @term{form} during processing that represents
a call to a @term{compiler macro} @term{name} (that is not declared @code{notinline}),
@code{eval} might expand the @term{compiler macro},
and might use the expansion in place of the original @term{form}.

There are two situations in which a @term{compiler macro} definition must not be
applied by any language processor:


@itemize @bullet{}
@item
The global function name binding associated with the compiler
macro is shadowed by a lexical binding of the function name.

@item
The function name has been declared or proclaimed @code{notinline} and
the call form appears within the scope of the declaration.
@end itemize


It is unspecified whether @term{compiler macros} are expanded or used in any other
situations.

@node Notes about the Implementation of Compiler Macros
@subsubsection Notes about the Implementation of Compiler Macros


Although it is technically permissible, as described above,
for @code{eval} to treat @term{compiler macros} in the same situations
as @term{compiler} might, this is not necessarily a good idea in
@term{interpreted implementations}.

@term{Compiler macros} exist for the purpose of trading compile-time speed
for run-time speed.  Programmers who write @term{compiler macros} tend to
assume that the @term{compiler macros} can take more time than normal @term{functions}
and @term{macros} in order to produce code which is especially optimal for use
at run time.  Since @code{eval} in an @term{interpreted implementation}
might perform semantic analysis of the same form multiple times, it might be
inefficient in general for the @term{implementation} to choose to call
@term{compiler macros} on every such @term{evaluation}.

Nevertheless, the decision about what to do in these situations is left to
each @term{implementation}.





@node Minimal Compilation
@subsubsection Minimal Compilation
@anchor{MinimalCompilation}

@term{Minimal compilation} is defined as follows:


@itemize @bullet{}
@item All @term{compiler macro}
@cindex compiler macro
calls appearing in the
@term{source code} being compiled are expanded, if at all, at compile time;
they will not be expanded at run time.

@item All @term{macro}
@cindex macro
and
@term{symbol macro}
@cindex symbol macro
calls
appearing in the source code being compiled are expanded at compile time
in such a way that they will not be expanded again at run time.
@code{macrolet}
@cindex macrolet
and
@code{symbol-macrolet}
@cindex symbol-macrolet
are effectively replaced by
@term{forms} corresponding to their bodies in which calls to
@term{macros} are replaced by their expansions.

@item
The first @term{argument} in a @code{load-time-value}
@cindex load-time-value
@term{form}
in @term{source code} processed by @code{compile}
@cindex compile
is @term{evaluated} at @term{compile time};
in @term{source code} processed by @code{compile-file}
@cindex compile-file
,
the compiler arranges for it to be @term{evaluated} at @term{load time}.
In either case, the result of the @term{evaluation}
is remembered and used later as the value of the
@code{load-time-value} @term{form} at @term{execution time}.
@end itemize



@node Semantic Constraints
@subsubsection Semantic Constraints
@anchor{SemanticConstraints}

All @term{conforming programs} must obey the following constraints,
which are designed to minimize the observable differences
between compiled and interpreted programs:


@itemize @bullet{}
@item Definitions of any referenced @term{macros}
must be present in the @term{compilation environment}.
Any @term{form} that is a @term{list}
beginning with a @term{symbol} that does not name a
@term{special operator} or a @term{macro} defined in the
@term{compilation environment} is treated by the compiler as a
function call.

@item @code{Special} proclamations for @term{dynamic variables}
must be made in the @term{compilation environment}.  Any @term{binding}
for which there is no @code{special} declaration or proclamation in
the @term{compilation environment} is treated by the compiler as
a @term{lexical binding}.

@item The definition of a function that is defined and
declared @code{inline} in the @term{compilation environment} must be
the same at run time.


@item Within a @term{function} named @mat{F}, the compiler may
(but is not required to)
assume that an apparent recursive call to a @term{function} named @mat{F}
refers to the same definition of @mat{F},
unless that function has been declared @code{notinline}.
The consequences of redefining such a recursively defined @term{function} @mat{F}
while it is executing are undefined.

@item A call within a file to a named function that is
defined in the same file refers to that function, unless that function
has been declared @code{notinline}.  The consequences are unspecified
if functions are redefined individually at run time or multiply
defined in the same file.


@item The argument syntax and number of return values for
all functions whose @code{ftype} is declared at compile time must
remain the same at run time.

@item @term{Constant variables} defined in
the @term{compilation environment} must have a @term{similar} value at
run time.  A reference to
a @term{constant variable}
in @term{source code} is equivalent to a reference to
a @term{literal} @term{object} that is the @term{value} of the @term{constant variable}.

@item Type definitions made with @code{deftype} or
@code{defstruct} in the @term{compilation environment} must
retain the same definition at run time.  Classes defined by @code{defclass}
in the @term{compilation environment} must be defined
at run time to have the same @term{superclasses} and same
@term{metaclass}.

This implies that @term{subtype}/@term{supertype} relationships of
@term{type specifiers} must not change between @term{compile time} and @term{run time}.

@item Type declarations present in the compilation
@term{environment} must accurately describe the corresponding values at run time;
otherwise, the consequences are undefined.  It is permissible
for an unknown @term{type} to appear in a declaration at
compile time, though a warning might be signaled in such a case.

@item Except in the situations explicitly listed above, a
@term{function} defined in the @term{evaluation environment}
is permitted to have a different definition or a different @term{signature}
at run time, and the run-time definition prevails.
@end itemize


@term{Conforming programs} should not be written using any additional
assumptions about consistency between the run-time
@term{environment} and the startup, evaluation, and compilation
@term{environments}.

Except where noted, when a compile-time and a run-time definition are
different, one of the following occurs at run time:


@itemize @bullet{}

@item an error @oftype{error} is signaled
@item the compile-time definition prevails
@item the run-time definition prevails
@end itemize


If the @term{compiler} processes a @term{function form} whose @term{operator}
is not defined at compile time, no error is signaled at compile time.

@node File Compilation
@subsection File Compilation

@Thefunction{compile-file} performs compilation of
@term{forms} in a file following the rules specified in @ref{Compilation Semantics},
and produces an output file that can be loaded by using @code{load}.

Normally, the @term{top level forms} appearing in a file compiled with
@code{compile-file} are evaluated only when the resulting
compiled file is loaded, and not when the file is compiled.  However,
it is typically the case that some forms in the file need to be evaluated
at compile time so the
remainder of the file can be read and compiled correctly.

@Thespecform{eval-when} can be used to control
whether a @term{top level form} is evaluated at compile time, load
time, or both.  It is possible to specify any of three situations with
@code{eval-when}, denoted by the symbols @kwd{compile-toplevel},
@kwd{load-toplevel}, and @kwd{execute}.  For top level
@code{eval-when} forms, @kwd{compile-toplevel} specifies that the
compiler must evaluate the body at compile time, and @tt{
:load-toplevel} specifies that the compiler must arrange to evaluate
the body at load time. For non-top level @code{eval-when} forms,
@kwd{execute} specifies that the body must be executed in the run-time
@term{environment}.

The behavior of this @term{form} can be more precisely understood in
terms of a model of how @code{compile-file} processes forms in
a file to be compiled. There are two processing modes, called
``not-compile-time'' and ``compile-time-too''.

Successive forms are read from the file by @code{compile-file}
and processed in not-compile-time mode; in this mode,
@code{compile-file} arranges for forms to be evaluated only at load time
and not at compile time.  When @code{compile-file} is in
compile-time-too mode, forms are evaluated both at compile time and
load time.

@node Processing of Top Level Forms
@subsubsection Processing of Top Level Forms
@anchor{TopLevelForms}

Processing of @term{top level forms} in the file compiler is defined
as follows:


@enumerate 1
@item If the @term{form} is a @term{compiler macro form}
(not disabled by a @code{notinline} @term{declaration}),
the @term{implementation} might or might not choose to compute
the @term{compiler macro expansion} of the @term{form} and,
having performed the expansion, might or might not choose to process the result
as a @term{top level form} in the same processing mode
(compile-time-too or not-compile-time).
If it declines to obtain or use the expansion, it must process the original @term{form}.

@item If the form is a @term{macro form},
its @term{macro expansion} is computed and processed as a
@term{top level form} in
the same processing mode (compile-time-too or not-compile-time).

@item If the form is a @code{progn} form, each of its
body @term{forms} is sequentially processed as a
@term{top level form} in the same processing mode.

@item If the form is a @code{locally},
@code{macrolet}, or @code{symbol-macrolet},
@code{compile-file} establishes the appropriate bindings and processes the
body forms as @term{top level forms} with those bindings in effect
in the same processing mode.  (Note that this implies that the lexical
@term{environment} in which @term{top level forms} are processed
is not necessarily the @term{null lexical environment}.)

@item If the form is an @code{eval-when}
@cindex eval-when
form, it is
handled according to @thenextfigure{}.


@float Figure,fig3.7
@cartouche
@multitable{@b{CT}}{@b{LT}}{@hfil{}---}{@hfil{} CTT}{@b{Action}}{compile-time-too}
@headitem @b{CT} @tab @b{LT} @tab @b{E} @tab @b{Mode} @tab @b{Action} @tab @b{New Mode}
@item Yes @tab Yes @tab @hfil{}--- @tab @hfil{}--- @tab Process @tab compile-time-too
@item No @tab Yes @tab Yes @tab @hfil{} CTT @tab Process @tab compile-time-too
@item No @tab Yes @tab Yes @tab @hfil{} NCT @tab Process @tab not-compile-time
@item No @tab Yes @tab No @tab @hfil{}--- @tab Process @tab not-compile-time
@item Yes @tab No @tab @hfil{}--- @tab @hfil{}--- @tab Evaluate @tab @hfil{}---
@item No @tab No @tab Yes @tab @hfil{} CTT @tab Evaluate @tab @hfil{}---
@item No @tab No @tab Yes @tab @hfil{} NCT @tab Discard @tab @hfil{}---
@item No @tab No @tab No @tab @hfil{}--- @tab Discard @tab @hfil{}---
@end multitable
@end cartouche
@caption{EVAL-WHEN processing}
@end float

Column @b{CT}   indicates whether @kwd{compile-toplevel} is specified.
Column @b{LT}   indicates whether @kwd{load-toplevel} is specified.
Column @b{E}    indicates whether @kwd{execute} is specified.
Column @b{Mode} indicates the processing mode;
a dash (---) indicates that the processing mode is not relevant.

The @b{Action} column specifies one of three actions:


@table @asis

@item @id{@t{}}
@b{Process:} process the body as @term{top level forms} in the
specified mode.

@item @id{@t{}}
@b{Evaluate:} evaluate the body in the dynamic execution
context of the compiler, using the @term{evaluation environment} as
the global environment and the @term{lexical environment} in which
the @code{eval-when} appears.

@item @id{@t{}}
@b{Discard:} ignore the @term{form}.
@end table


The @b{New Mode} column indicates the new processing mode.
A dash (---) indicates the compiler remains in its current mode.

@item Otherwise, the form is a @term{top level form} that
is not one of the special cases.  In compile-time-too mode, the
compiler first evaluates the form in the evaluation
@term{environment} and then minimally compiles it.  In not-compile-time
mode, the @term{form} is simply minimally compiled.  All @term{subforms}
are treated as @term{non-top-level forms}.

Note that @term{top level forms} are processed in the order in
which they textually appear in the file and that each
@term{top level form} read by the compiler is processed before the next is
read.  However, the order of processing (including macro expansion) of
@term{subforms} that are not @term{top level forms} and the order of
further compilation is unspecified as long as Common Lisp semantics
are preserved.
@end enumerate


@code{eval-when} forms cause compile-time evaluation only at
top level.  Both @kwd{compile-toplevel} and @kwd{load-toplevel} situation specifications
are ignored for @term{non-top-level forms}. For @term{non-top-level forms},
an @code{eval-when}
specifying the @kwd{execute} situation is treated as an @term{implicit progn}
including the @term{forms} in the body of the @code{eval-when} @term{form};
otherwise, the @term{forms} in the body are ignored.

@node Processing of Defining Macros
@subsubsection Processing of Defining Macros



Defining @term{macros} (such as @code{defmacro} or @code{defvar})
appearing within a file being processed by @code{compile-file}
normally have compile-time side effects which affect how subsequent @term{forms}
in the same @term{file} are compiled.  A convenient model for explaining how these
side effects happen is that the defining macro expands into one or
more @code{eval-when} @term{forms}, and that the calls which cause the compile-time
side effects to happen appear
in the body of an @f{(eval-when (:compile-toplevel) ...)} @term{form}.

The compile-time side effects may cause information about the definition to
be stored differently than if the defining macro had been processed in the
`normal' way (either interpretively or by loading the compiled file).

In particular, the information stored by the defining @term{macros} at compile time
might or might not be available to the interpreter (either during or after compilation),
or during subsequent calls to the @term{compiler}.  For example,
the following code is nonportable because it assumes that the @term{compiler}
stores the macro definition of @f{foo} where it is available to the interpreter:

@lisp
 (defmacro foo (x) `(car ,x))
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (print (foo '(a b c))))
@end lisp


A portable way to do the same thing would be to include the macro
definition inside the @code{eval-when} @term{form}, as in:

@lisp
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (defmacro foo (x) `(car ,x))
   (print (foo '(a b c))))
@end lisp



@Thenextfigure{}@spc{}lists macros that make definitions
available both in the compilation and run-time @term{environments}.
It is not specified whether definitions made available in the
@term{compilation environment} are available in the evaluation
@term{environment}, nor is it specified whether they are available
in subsequent compilation units or subsequent invocations of the
compiler.  As with @code{eval-when}, these compile-time side
effects happen only when the defining macros appear at
top level.


@float Figure,fig3.8
@cartouche
@multitable{define-compiler-macro}{define-setf-expander}{defstruct}

@item declaim @tab define-modify-macro @tab defsetf
@item defclass @tab define-setf-expander @tab defstruct
@item defconstant @tab defmacro @tab deftype
@item define-compiler-macro @tab defpackage @tab defvar
@item define-condition @tab defparameter @tab
@end multitable
@end cartouche
@caption{Defining Macros That Affect the Compile-Time Environment}
@end float




@node Constraints on Macros and Compiler Macros
@subsubsection Constraints on Macros and Compiler Macros



Except where explicitly stated otherwise, no @term{macro} defined in
the @clisp{}@spc{}standard produces an expansion that could cause any of the
@term{subforms} of the @term{macro form} to be treated as
@term{top level forms}.  If an @term{implementation} also provides a
@term{special operator} definition of a @clisp{}@spc{}@term{macro},
the @term{special operator} definition must be semantically equivalent
in this respect.

@term{Compiler macro} expansions must also have the same
top level evaluation semantics as the @term{form} which they replace.
This is of concern both to @term{conforming implementations} and to
@term{conforming programs}.




@node Literal Objects in Compiled Files
@subsection Literal Objects in Compiled Files

The functions @code{eval} and @code{compile} are
required to ensure that @term{literal objects} referenced within the resulting
interpreted or compiled code objects are the @term{same} as the
corresponding @term{objects} in the @term{source code}.
@code{compile-file}, on the other hand,
must produce a @term{compiled file} that, when loaded with
@code{load}, constructs the @term{objects} defined by the
@term{source code} and produces references to them.

In the case of @code{compile-file}, @term{objects}
constructed by @code{load} of the @term{compiled file} cannot be spoken
of as being the @term{same} as the @term{objects} constructed at
compile time, because the @term{compiled file} may be loaded into a different
@term{Lisp image} than the one in which it was compiled.  This section
defines the concept of @term{similarity} which relates
@term{objects} in the @term{evaluation environment} to the
corresponding @term{objects} in the @term{run-time environment}.

The constraints on @term{literal objects} described in this section
apply only to @code{compile-file};
@code{eval} and @code{compile} do not copy or coalesce constants.

@node Externalizable Objects
@subsubsection Externalizable Objects

The fact that the @term{file compiler} represents @term{literal} @term{objects}
externally in a @term{compiled file} and must later reconstruct suitable
equivalents of those @term{objects} when that @term{file} is loaded
imposes a need for constraints on the nature of the @term{objects} that can be
used as @term{literal} @term{objects} in @term{code} to be processed
by the @term{file compiler}.

An @term{object} that can be used as a @term{literal} @term{object}
in @term{code} to be processed by the @term{file compiler} is called an
@newterm{externalizable object}.

We define that two @term{objects} are @newterm{similar} if they satisfy
a two-place conceptual equivalence predicate (defined below), which is
independent of the @term{Lisp image} so that the two @term{objects} in
different @term{Lisp images} can be understood to be equivalent under
this predicate.  Further, by inspecting the definition of this conceptual
predicate, the programmer can anticipate what aspects of an @term{object}
are reliably preserved by @term{file compilation}.

The @term{file compiler} must cooperate with the @term{loader} in order to
assure that in each case where an @term{externalizable object} is processed
as a @term{literal object}, the @term{loader} will construct a @term{similar}
@term{object}.

The set of @term{objects} that are
@cindex externalizable object
@dfn{externalizable objects} are those
for which the new conceptual term ``@term{similar}'' is defined, such that
when a @term{compiled file} is @term{loaded}, an @term{object} can be constructed
which can be shown to be @term{similar} to the original @term{object} which
existed at the time the @term{file compiler} was operating.


@node Similarity of Literal Objects
@subsubsection Similarity of Literal Objects
@anchor{Similarity}

@node Similarity of Aggregate Objects
@subsubsection Similarity of Aggregate Objects


Of the @term{types} over which @term{similarity} is defined,
some are treated as aggregate objects.  For these types,
@term{similarity} is defined recursively.
We say that an @term{object} of these types has certain ``basic qualities''
and to satisfy the @term{similarity} relationship, the values of the
corresponding qualities of the two @term{objects} must also be similar.


@node Definition of Similarity
@subsubsection Definition of Similarity


Two @term{objects} @mat{S} (in @term{source code}) and @mat{C} (in @term{compiled code})
are defined to be @term{similar} if and only if
they are both of one of the @term{types} listed here
(or defined by the @term{implementation})
and they both satisfy all additional requirements of @term{similarity}
indicated for that @term{type}.


@table @asis

@item @id{@code{number}}


Two @term{numbers} @mat{S} and @mat{C} are @term{similar} if they are of the same @term{type}
and represent the same mathematical value.

@item @id{@code{character}}



Two @term{simple} @term{characters} @mat{S} and @mat{C} are @term{similar}
if they have @term{similar} @term{code} @term{attributes}.

@term{Implementations} providing additional, @term{implementation-defined}
@term{attributes} must define whether and how @term{non-simple} @term{characters}
can be regarded as @term{similar}.

@item @id{@code{symbol}}


Two @term{apparently uninterned} @term{symbols} @mat{S} and @mat{C} are @term{similar}
if their
@term{names}
are @term{similar}.

Two @term{interned} symbols @mat{S} and @mat{C} are @term{similar}
if their @term{names} are @term{similar},
and if either @mat{S} is accessible in the @term{current package} at compile time
and @mat{C} is accessible in the @term{current package} at load time,
or @mat{C} is accessible in the @term{package} that is @term{similar} to
the @term{home package} of @mat{S}.

(Note that @term{similarity} of
@term{symbols} is dependent
on neither the @term{current readtable} nor how @thefunction{read} would
parse the @term{characters} in the @term{name} of the @term{symbol}.)

@item @id{@code{package}}


Two @term{packages} @mat{S} and @mat{C} are @term{similar} if their @term{names} are @term{similar}.

Note that although a @term{package} @term{object} is an @term{externalizable object},
the programmer is responsible for ensuring that the corresponding @term{package} is
already in existence when code referencing it as a @term{literal} @term{object}
is @term{loaded}.  The @term{loader} finds the corresponding @term{package} @term{object}
as if by calling @code{find-package} with that @term{name} as an @term{argument}.
An error is signaled by the @term{loader} if no @term{package} exists at load time.

@item @id{@code{random-state}}


Two @term{random states} @mat{S} and @mat{C} are @term{similar} if @mat{S}
would always produce the same sequence of pseudo-random numbers
as a @term{copy}@sub{5} of @mat{C}
when given as the @param{random-state} @term{argument} to @thefunction{random},
assuming equivalent @param{limit} @term{arguments} in each case.

(Note that since @mat{C} has been processed by the @term{file compiler},
it cannot be used directly as an @term{argument} to @code{random}
because @code{random} would perform a side effect.)

@item @id{@code{cons}}


Two @term{conses}, @mat{S} and @mat{C}, are @term{similar} if
the @term{car}@sub{2} of @mat{S} is @term{similar} to the @term{car}@sub{2} of @mat{C},
and the @term{cdr}@sub{2} of @mat{S} is @term{similar} to the @term{cdr}@sub{2} of @mat{C}.

@item @id{@code{array}}


Two one-dimensional @term{arrays}, @mat{S} and @mat{C}, are @term{similar} if
the @term{length} of @mat{S} is @term{similar} to the @term{length} of @mat{C},
the @term{actual array element type} of @mat{S} is @term{similar} to
the @term{actual array element type} of @mat{C},
and each @term{active} @term{element} of @mat{S} is @term{similar} to
the corresponding @term{element} of @mat{C}.

Two @term{arrays} of @term{rank} other than one, @mat{S} and @mat{C}, are @term{similar} if
the @term{rank} of @mat{S} is @term{similar} to the @term{rank} of @mat{C},
each @term{dimension}@sub{1} of @mat{S} is @term{similar} to
the corresponding @term{dimension}@sub{1} of @mat{C},
the @term{actual array element type} of @mat{S} is @term{similar} to
the @term{actual array element type} of @mat{C},
and each @term{element} of @mat{S} is @term{similar} to
the corresponding @term{element} of @mat{C}.

In addition,
if @mat{S} is a @term{simple array}, then @mat{C} must also be a @term{simple array}.
If @mat{S} is a @term{displaced array},
has a @term{fill pointer},
or is @term{actually adjustable},
@mat{C} is permitted to lack any or all of these qualities.

@item @id{@code{hash-table}}


Two @term{hash tables} @mat{S} and @mat{C} are @term{similar} if they meet the following
three requirements:


@enumerate 1
@item  They both have the same test
(@eg{} they are both @code{eql} @term{hash tables}).

@item  There is a unique one-to-one correspondence between the keys of
the two @term{hash tables}, such that the corresponding keys are
@term{similar}.

@item  For all keys, the values associated with two corresponding keys
are @term{similar}.
@end enumerate


If there is more than one possible one-to-one correspondence between
the keys of @mat{S} and @mat{C}, the consequences are unspecified.
A @term{conforming program} cannot use a table such as @mat{S} as an
@term{externalizable constant}.

@item @id{@code{pathname}}


Two @term{pathnames} @mat{S} and @mat{C} are @term{similar} if all corresponding
@term{pathname components} are @term{similar}.

@item @id{@code{function}}


@term{Functions} are not @term{externalizable objects}.

@item @id{@code{structure-object} and @code{standard-object}}


A general-purpose concept of @term{similarity} does not exist for @term{structures}
and @term{standard objects}.
However, a @term{conforming program} is permitted to define a @code{make-load-form}
@term{method} for any @term{class} @mat{K} defined by that @term{program} that is
a @term{subclass} of either @code{structure-object} or @code{standard-object}.
The effect of such a @term{method} is to define that an @term{object} @mat{S} of @term{type} @mat{K}
in @term{source code} is @term{similar} to an @term{object} @mat{C} of @term{type} @mat{K}
in @term{compiled code} if @mat{C} was constructed from @term{code} produced by
calling @code{make-load-form} on @mat{S}.
@end table



@node Extensions to Similarity Rules
@subsubsection Extensions to Similarity Rules

Some @term{objects}, such as @term{streams}, @code{readtables}, and @code{methods}
are not @term{externalizable objects} under the definition of similarity given above.
That is, such @term{objects} may not portably appear as @term{literal} @term{objects}
in @term{code} to be processed by the @term{file compiler}.

An @term{implementation} is permitted to extend the rules of similarity,
so that other kinds of @term{objects} are @term{externalizable objects}
for that @term{implementation}.

If for some kind of @term{object}, @term{similarity} is
neither defined by this specification
nor by the @term{implementation},
then the @term{file compiler} must signal an error upon encountering such
an @term{object} as a @term{literal constant}.


@node Additional Constraints on Externalizable Objects
@subsubsection Additional Constraints on Externalizable Objects

If two @term{literal objects} appearing in the source code for a single file
processed with
the @term{file compiler}
are the @term{identical},
the corresponding @term{objects} in the @term{compiled code}
must also be the @term{identical}.
With the exception of @term{symbols} and @term{packages}, any two
@term{literal objects}
in @term{code} being processed by
the @term{file compiler}
may be @term{coalesced}
if and only if they are @term{similar};
if they are either both @term{symbols} or both @term{packages},
they may only be @term{coalesced} if and only if they are @term{identical}.

@term{Objects} containing circular references can
be @term{externalizable objects}.
The @term{file compiler} is required to preserve @code{eql}ness of
substructures within a @term{file}.
Preserving @code{eql}ness means that subobjects that are
the @term{same}
in the @term{source code} must
be
the @term{same}
in the corresponding @term{compiled code}.

In addition, the following are constraints on the handling of
@term{literal objects} by the @term{file compiler}:


@table @asis

@item @id{@t{}}
@b{array:} If an @term{array} in the source code is a
@term{simple array}, then the corresponding @term{array}
in the compiled code will also be a @term{simple array}.  If
an @term{array} in the source code is displaced, has a
@term{fill pointer}, or is @term{actually adjustable}, the corresponding
@term{array} in the compiled code might lack any or all of these
qualities. If an @term{array} in the source code has a fill
pointer, then the corresponding @term{array} in the compiled
code might be only the size implied by the fill pointer.

@item @id{@t{}}
@b{packages:} The loader is required to find the
corresponding @term{package} @term{object} as if by calling
@code{find-package} with the package name as an argument.
An error @oftype{package-error} is signaled if no
@term{package} of that name exists at load time.

@item @id{@t{}}
@b{random-state:} A constant @term{random state}
object cannot be used as the state argument
to @thefunction{random} because @code{random} modifies this data structure.

@item @id{@t{}}
@b{structure, standard-object:}
@term{Objects} of @term{type} @code{structure-object} and @code{standard-object}
may appear in compiled constants if there is an
appropriate @code{make-load-form} method defined for that
@term{type}.

@anchor{CallingMakeLoadForm}
The @term{file compiler} calls @code{make-load-form} on any @term{object}
that is referenced as a @term{literal object} if the @term{object} is a
@term{generalized instance} of @code{standard-object},
@code{structure-object}, @code{condition}, or any of a
(possibly empty) @term{implementation-dependent} set of other @term{classes}.
The @term{file compiler} only calls @code{make-load-form} once for
any given @term{object} within a single @term{file}.

@item @id{@t{}}
@b{symbol:} In order to guarantee that @term{compiled files} can be @term{loaded}
correctly, users must ensure that the @term{packages} referenced in those @term{files}
are defined consistently at compile time and load time.  @term{Conforming programs}
must satisfy the following requirements:


@enumerate 1
@item The @term{current package} when a @term{top level form} in the @term{file}
is processed by @code{compile-file} must be the same as the @term{current package}
when the @term{code} corresponding to that @term{top level form} in the
@term{compiled file} is executed by @code{load}.  In particular:


@enumerate a

@item Any @term{top level form} in a @term{file} that alters
the @term{current package} must change it to a @term{package}
of the same @term{name} both at compile time and at load time.

@item If the first @term{non-atomic} @term{top level form} in the @term{file}
is not an @code{in-package} @term{form}, then the @term{current package}
at the time @code{load} is called must be a @term{package} with the
same @term{name} as the package that was the @term{current package}
at the time @code{compile-file} was called.
@end enumerate


@item For all @term{symbols}
appearing lexically within a @term{top level form} that
were @term{accessible} in the @term{package} that was the @term{current package}
during processing of that @term{top level form} at compile time, but
whose @term{home package} was another @term{package}, at load time there must
be a @term{symbol} with the same @term{name} that is @term{accessible} in both the
load-time @term{current package} and in the @term{package}
with the same @term{name} as the
compile-time @term{home package}.

@item For all @term{symbols} represented in the @term{compiled file}
that were @term{external symbols} in
their @term{home package} at compile time, there must be a @term{symbol} with the
same @term{name} that is an @term{external symbol} in the @term{package}
with the same @term{name} at load time.
@end enumerate


If any of these conditions do not hold, the @term{package} in which the @term{loader} looks
for the affected @term{symbols} is unspecified.  @term{Implementations} are permitted
to signal an error or to define this behavior.
@end table




@node Exceptional Situations in the Compiler
@subsection Exceptional Situations in the Compiler



@code{compile} and @code{compile-file} are permitted to
signal errors and warnings, including errors due to compile-time
processing of @f{(eval-when (:compile-toplevel) ...)} forms,
macro expansion, and conditions signaled by the compiler itself.

@term{Conditions} @oftype{error} might be signaled by the compiler
in situations where the compilation cannot proceed without intervention.

In addition to situations for which the standard specifies that
@term{conditions} @oftype{warning} must or might be signaled,
warnings might be signaled in situations where the compiler can
determine that the consequences are undefined or that a run-time
error will be signaled.  Examples of this situation are as follows:
violating type declarations,
altering or assigning the value of a constant defined with @code{defconstant},
calling built-in Lisp functions with a wrong number of arguments or malformed keyword
argument lists,
and using unrecognized declaration specifiers.

The compiler is permitted to issue warnings about matters of
programming style as conditions @oftype{style-warning}.
Examples of this situation are as follows:
redefining a function using a different argument list,
calling a function with a wrong number of arguments,
not declaring @code{ignore} of a local variable that is not referenced,
and referencing a variable declared @code{ignore}.

Both @code{compile} and @code{compile-file} are permitted
(but not required) to @term{establish} a @term{handler}
for @term{conditions} @oftype{error}.  For example, they
might signal a warning, and restart compilation from some
@term{implementation-dependent} point in order to let the
compilation proceed without manual intervention.

Both @code{compile} and @code{compile-file} return three
values, the second two indicating whether the source code being compiled
contained errors and whether style warnings were issued.


Some warnings might be deferred until the end of compilation.
See @code{with-compilation-unit}.



@node Declarations
@section Declarations


@cindex declaration
@dfn{Declarations} provide a way of specifying information for use by
program processors, such as the evaluator or the compiler.

@cindex local declaration
@dfn{Local declarations}
can be embedded in executable code using @t{declare}.
@cindex global declaration
@dfn{Global declarations},
or
@cindex proclamation
@dfn{proclamations},
are established by @code{proclaim} or @code{declaim}.

@Thespecform{the} provides a shorthand notation for
making a @term{local declaration} about the @term{type} of the
@term{value} of a given @term{form}.

The consequences are undefined if a program violates a @term{declaration}
or a @term{proclamation}.

@menu
* Minimal Declaration Processing Requirements::
* Declaration Specifiers::
* Declaration Identifiers::
* Declaration Scope::
@end menu
@node Minimal Declaration Processing Requirements
@subsection Minimal Declaration Processing Requirements

In general, an @term{implementation} is free to ignore
@term{declaration specifiers} except for the
@code{declaration}
@cindex declaration
,
@code{notinline}
@cindex notinline
,
@code{safety}
@cindex safety
,
and @code{special}
@cindex special
@term{declaration specifiers}.

A @code{declaration} @term{declaration} must suppress warnings
about unrecognized @term{declarations} of the kind that it declares.
If an @term{implementation} does not produce warnings about
unrecognized declarations, it may safely ignore this @term{declaration}.

A @code{notinline} @term{declaration} must be recognized by any @term{implementation}
that supports inline functions or @term{compiler macros} in order to disable those facilities.
An @term{implementation} that does not use inline functions or @term{compiler macros}
may safely ignore this @term{declaration}.

A @code{safety} @term{declaration} that increases the current safety level
must always be recognized.  An @term{implementation} that always processes
code as if safety were high may safely ignore this @term{declaration}.

A @code{special} @term{declaration} must be processed by all @term{implementations}.


@node Declaration Specifiers
@subsection Declaration Specifiers

A @newterm{declaration specifier} is an @term{expression} that can appear at
top level of a @t{declare} expression or a @code{declaim} form, or as
the argument to @code{proclaim}.
It is a @term{list} whose @term{car} is a @term{declaration identifier},
and whose @term{cdr} is data interpreted according to rules specific to
the @term{declaration identifier}.


@node Declaration Identifiers
@subsection Declaration Identifiers

@Thenextfigure{}@spc{}shows a list of all
@term{declaration identifiers}
@cindex declaration identifier

defined by this standard.


@float Figure,fig3.9
@cartouche
@multitable{dynamic-extent}{notinline}{special}

@item declaration @tab ignore @tab special
@item dynamic-extent @tab inline @tab type
@item ftype @tab notinline @tab
@item ignorable @tab optimize @tab
@end multitable
@end cartouche
@caption{Common Lisp Declaration Identifiers}
@end float


An implementation is free to support other (@term{implementation-defined})
@term{declaration identifiers} as well.
A warning might be issued
if a @term{declaration identifier}
is not among those defined above,
is not defined by the @term{implementation},
is not a @term{type} @term{name},
and has not been declared in a @code{declaration} @term{proclamation}.

@node Shorthand notation for Type Declarations
@subsubsection Shorthand notation for Type Declarations

A @term{type specifier} can be used as a @term{declaration identifier}.
@f{(@param{type-specifier} @starparam{var})} is taken as shorthand for
@f{(type @param{type-specifier} @starparam{var})}.



@node Declaration Scope
@subsection Declaration Scope

@term{Declarations} can be divided into two kinds: those that apply to the
@term{bindings} of @term{variables} or @term{functions}; and those that
do not apply to @term{bindings}.

A @term{declaration} that appears at the head of a binding @term{form}
and applies to a @term{variable} or @term{function} @term{binding}
made by that @term{form} is called a @newterm{bound declaration};
such a @term{declaration} affects both the @term{binding} and
any references within the @term{scope} of the @term{declaration}.

@term{Declarations} that are not @term{bound declarations} are called
@cindex free declaration
@dfn{free declarations}.

A @term{free declaration} in a @term{form} @mat{F1} that applies to a @term{binding}
for a @term{name} @mat{N} @term{established} by some @term{form} @mat{F2}
of which @mat{F1} is a @term{subform}
affects only references to @mat{N} within @mat{F1}; it does not to apply to
other references to @mat{N} outside of @mat{F1}, nor does it affect the manner
in which the @term{binding} of @mat{N} by @mat{F2} is @term{established}.

@term{Declarations} that do not apply to @term{bindings} can only appear
as @term{free declarations}.

The @term{scope} of a @term{bound declaration} is the same as the
@term{lexical scope}
of the @term{binding} to which it applies;
for @term{special variables},
this means the @term{scope} that the @term{binding}
would have had had it been a @term{lexical binding}.

Unless explicitly stated otherwise, the @term{scope} of a
@term{free declaration} includes only the body @term{subforms} of
the @term{form} at whose head it appears, and no other @term{subforms}.
The @term{scope} of @term{free declarations} specifically does not
include @term{initialization forms} for @term{bindings} established
by the @term{form} containing the @term{declarations}.

Some @term{iteration forms} include step, end-test, or result
@term{subforms} that are also included in the @term{scope}
of @term{declarations} that appear in the @term{iteration form}.
Specifically, the @term{iteration forms} and @term{subforms} involved
are:


@itemize @bullet{}
@item @code{do}, @code{do*}:
@param{step-forms}, @param{end-test-form}, and @param{result-forms}.
@item @code{dolist}, @code{dotimes}:
@param{result-form}
@item @code{do-all-symbols}, @code{do-external-symbols}, @code{do-symbols}:
@param{result-form}
@end itemize


@node Examples of Declaration Scope
@subsubsection Examples of Declaration Scope

Here is an example illustrating the @term{scope} of @term{bound declarations}.

@lisp
 (let ((x 1))                ;[1] 1st occurrence of x
   (declare (special x))     ;[2] 2nd occurrence of x
   (let ((x 2))              ;[3] 3rd occurrence of x
     (let ((old-x x)         ;[4] 4th occurrence of x
           (x 3))            ;[5] 5th occurrence of x
       (declare (special x)) ;[6] 6th occurrence of x
       (list old-x x))))     ;[7] 7th occurrence of x
@EV{} (2 3)
@end lisp


The first occurrence of @f{x} @term{establishes} a @term{dynamic binding}
of @f{x} because of the @code{special} @term{declaration} for @f{x}
in the second line.  The third occurrence of @f{x} @term{establishes} a
@term{lexical binding} of @f{x} (because there is no @code{special}
@term{declaration} in the corresponding @code{let} @term{form}).
The fourth occurrence of @f{x} @term{x} is a reference to the
@term{lexical binding} of @f{x} established in the third line.
The fifth occurrence of @f{x} @term{establishes} a @term{dynamic binding}
of @term{x} for the body of the @code{let} @term{form} that begins on
that line because of the @code{special} @term{declaration} for @f{x}
in the sixth line. The reference to @f{x} in the fourth line is not
affected by the @code{special} @term{declaration} in the sixth line
because that reference is not within the ``would-be @term{lexical scope}''
of the @term{variable} @f{x} in the fifth line.  The reference to @f{x}
in the seventh line is a reference to the @term{dynamic binding} of @term{x}
@term{established} in the fifth line.

Here is another example, to illustrate the @term{scope} of a
@term{free declaration}.  In the following:

@lisp
 (lambda (&optional (x (foo 1))) ;[1]
   (declare (notinline foo))     ;[2]
   (foo x))                      ;[3]
@end lisp


the @term{call} to @f{foo} in the first line might be
compiled inline even though the @term{call} to @f{foo} in
the third line must not be.  This is because
the @code{notinline} @term{declaration}
for @f{foo} in the second line applies only to the body on the
third line.  In order to suppress inlining for both @term{calls},
one might write:

@lisp
 (locally (declare (notinline foo)) ;[1]
   (lambda (&optional (x (foo 1)))  ;[2]
     (foo x)))                      ;[3]
@end lisp


or, alternatively:

@lisp
 (lambda (&optional                               ;[1]
            (x (locally (declare (notinline foo)) ;[2]
                 (foo 1))))                       ;[3]
   (declare (notinline foo))                      ;[4]
   (foo x))                                       ;[5]
@end lisp


Finally, here is an example that shows the @term{scope} of
@term{declarations} in an @term{iteration form}.

@lisp
 (let ((x  1))                     ;[1]
   (declare (special x))           ;[2]
     (let ((x 2))                  ;[3]
       (dotimes (i x x)            ;[4]
         (declare (special x)))))  ;[5]
@EV{} 1
@end lisp


In this example, the first reference to @f{x} on the fourth line is to
the @term{lexical binding} of @f{x} established on the third line.
However, the second occurrence of @f{x} on the fourth line lies within
the @term{scope} of the @term{free declaration} on the fifth line
(because this is the @param{result-form} of the @code{dotimes})
and therefore refers to the @term{dynamic binding} of @f{x}.



@node Lambda Lists
@section Lambda Lists

A @newterm{lambda list} is a @term{list} that
specifies a set of @term{parameters} (sometimes called @term{lambda variables})
and a protocol for receiving @term{values} for those @term{parameters}.

There are several kinds of @term{lambda lists}.


@float Figure,fig3.10
@cartouche
@multitable{@code{define-method-combination} @kwd{arguments} option}{@term{define-method-combination arguments lambda list}}
@headitem Context @tab Kind of Lambda List
@item @code{defun} @term{form} @tab @term{ordinary lambda list}
@item @code{defmacro} @term{form} @tab @term{macro lambda list}
@item @term{lambda expression} @tab @term{ordinary lambda list}
@item @code{flet} local @term{function} definition @tab @term{ordinary lambda list}
@item @code{labels} local @term{function} definition @tab @term{ordinary lambda list}
@item @code{handler-case} @param{clause} specification @tab @term{ordinary lambda list}
@item @code{restart-case} @param{clause} specification @tab @term{ordinary lambda list}
@item @code{macrolet} local @term{macro} definition @tab @term{macro lambda list}
@item @code{define-method-combination} @tab @term{ordinary lambda list}
@item @code{define-method-combination} @kwd{arguments} option @tab @term{define-method-combination arguments lambda list}
@item @code{defstruct} @kwd{constructor} option @tab @term{boa lambda list}
@item @code{defgeneric} @term{form} @tab @term{generic function lambda list}
@item @code{defgeneric} @term{method} clause @tab @term{specialized lambda list}
@item @code{defmethod} @term{form} @tab @term{specialized lambda list}
@item @code{defsetf} @term{form} @tab @term{defsetf lambda list}
@item @code{define-setf-expander} @term{form} @tab @term{macro lambda list}
@item @code{deftype} @term{form} @tab @term{deftype lambda list}
@item @code{destructuring-bind} @term{form} @tab @term{destructuring lambda list}
@item @code{define-compiler-macro} @term{form} @tab @term{macro lambda list}
@item @code{define-modify-macro} @term{form} @tab @term{define-modify-macro lambda list}
@end multitable
@end cartouche
@caption{What Kind of Lambda Lists to Use}
@end float


@Thenextfigure{}@spc{}lists some @term{defined names} that are applicable
to @term{lambda lists}.


@float Figure,fig3.11
@cartouche
@multitable{lambda-list-keywords}{lambda-parameters-limit}{}

@item lambda-list-keywords @tab lambda-parameters-limit @tab
@end multitable
@end cartouche
@caption{Defined names applicable to lambda lists}
@end float


@menu
* Ordinary Lambda Lists::
* Generic Function Lambda Lists::
* Specialized Lambda Lists::
* Macro Lambda Lists::
* Destructuring Lambda Lists::
* Boa Lambda Lists::
* Defsetf Lambda Lists::
* Deftype Lambda Lists::
* Define-modify-macro Lambda Lists::
* Define-method-combination Arguments Lambda Lists::
* Syntactic Interaction of Documentation Strings and Declarations::
@end menu
@node Ordinary Lambda Lists
@subsection Ordinary Lambda Lists

An @newterm{ordinary lambda list} is used to describe how a set of
@term{arguments} is received by an @term{ordinary} @term{function}.
The @term{defined names} in @thenextfigure{}@spc{}are those which use
@term{ordinary lambda lists}:


@float Figure,fig3.12
@cartouche
@multitable{define-method-combination}{handler-case}{restart-case}

@item define-method-combination @tab handler-case @tab restart-case
@item defun @tab labels @tab
@item flet @tab lambda @tab
@end multitable
@end cartouche
@caption{Standardized Operators that use Ordinary Lambda Lists}
@end float


An @term{ordinary lambda list} can contain the @term{lambda list keywords} shown
in @thenextfigure{}.


@float Figure,fig3.13
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{optional}}{@keyref{rest}}

@item @keyref{allow-other-keys} @tab @keyref{key} @tab @keyref{rest}
@item @keyref{aux} @tab @keyref{optional} @tab
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Ordinary Lambda Lists}
@end float


Each @term{element} of a @term{lambda list} is either a parameter specifier
or a @term{lambda list keyword}.
Implementations are free to provide additional @term{lambda list keywords}.
For a list of all @term{lambda list keywords}
used by the implementation, see @code{lambda-list-keywords}.

The syntax for @term{ordinary lambda lists} is as follows:


@auxbnf{lambda-list, @lparen{}@starparam{var}@CR{} @spc{}@ttbrac{@opt{} @star{@VarValueSuppliedP{}}}@CR{} @spc{}@ttbrac{@rest{} @param{var}}@CR{} @spc{}@f{[}@Vtop{}@hbox{@key{} @star{@KeyVarValueSuppliedP{}}}  @hbox{@brac{@allowotherkeys{}}@f{]}}@CR{} @spc{}@ttbrac{@aux{} @star{@VarValue{}}}@rparen{}@CR{}}

A @param{var} or @param{supplied-p-parameter} must be a @term{symbol}
that is not the name of a @term{constant variable}.

An @param{init-form} can be any @term{form}.
Whenever any @param{init-form} is evaluated for any parameter
specifier, that @term{form} may refer to any parameter variable to
the left of the specifier in which the @param{init-form} appears,
including any @param{supplied-p-parameter} variables, and may rely
on the fact that no other parameter variable has yet been bound
(including its own parameter variable).

A @param{keyword-name} can be any @term{symbol},
but by convention is normally a @term{keyword}@sub{1};
all @term{standardized} @term{functions} follow that convention.

An @term{ordinary lambda list} has five parts, any or all of which may be empty.
For information about the treatment of argument mismatches,
see @ref{Error Checking in Function Calls}.

@node Specifiers for the required parameters
@subsubsection Specifiers for the required parameters

These are all the parameter specifiers up to
the first @term{lambda list keyword};
if there are no @term{lambda list keywords},
then all the specifiers are for required parameters.
Each required parameter is specified by a parameter variable @param{var}.
@param{var} is bound as a lexical variable unless it is declared @code{special}.

If there are @f{n} required parameters (@f{n} may be zero),
there must be at least @f{n} passed arguments, and the
required parameters are bound to the first @f{n} passed arguments;
see @ref{Error Checking in Function Calls}.
The other parameters are then processed using any remaining arguments.


@node Specifiers for optional parameters
@subsubsection Specifiers for optional parameters
@cindex &optional

If @keyref{optional} is present,
the optional parameter specifiers are those following
@keyref{optional}
up to the next @term{lambda list keyword} or the end of the list.
If optional parameters are specified, then each one is processed as
follows.  If any unprocessed arguments remain, then the parameter variable
@param{var} is bound to the next remaining argument, just as for a required
parameter.  If no arguments remain, however, then @param{init-form}
is evaluated, and the parameter variable
is bound to the resulting value
(or to @nil{}@spc{}if no @param{init-form} appears
in the parameter specifier).
If another variable name @param{supplied-p-parameter}
appears in the specifier, it is bound
to @term{true} if an argument had been available, and to @term{false} if no
argument remained (and therefore @param{init-form} had to be evaluated).
@param{Supplied-p-parameter}
is bound not to an argument but to a value indicating whether or not
an argument had been supplied for the corresponding @param{var}.


@node A specifier for a rest parameter
@subsubsection A specifier for a rest parameter
@cindex &rest

@keyref{rest}, if present, must be followed by a single @term{rest parameter}
specifier, which in turn must be followed by another
@term{lambda list keyword} or the end of the @term{lambda list}.  After all
optional parameter specifiers have been processed, then there may or
may not be a @term{rest parameter}.  If there is a @term{rest parameter}, it is
bound to a @term{list} of all as-yet-unprocessed arguments.  If
no unprocessed arguments remain, the @term{rest parameter} is bound to the
@term{empty list}.  If there is no @term{rest parameter} and there are no
@term{keyword parameters}, then an error
should be signaled if
any unprocessed arguments remain; see @ref{Error Checking in Function Calls}.
The value of a @term{rest parameter}
is permitted, but not required, to share structure with the
last argument to @code{apply}.

@cindex &key
@cindex &allow-other-keys

@node Specifiers for keyword parameters
@subsubsection Specifiers for keyword parameters

If @keyref{key}
is present, all specifiers up to the next @term{lambda list keyword}
or the end of the @term{list} are keyword parameter specifiers.
When keyword parameters are processed,
the same arguments are processed that
would be made into a @term{list} for a @term{rest parameter}.
It is permitted to specify both @keyref{rest} and @keyref{key}.
In this case the remaining arguments are used for both purposes;
that is, all remaining arguments are made into a @term{list} for the
@term{rest parameter}, and are also processed for the @keyref{key} parameters.
If @keyref{key} is specified, there must remain
an even number of arguments; see @ref{Odd Number of Keyword Arguments}.
These arguments are considered as pairs,
the first argument in each pair being interpreted as a name
and the second as the corresponding value.
The first @term{object} of each pair must be a @term{symbol};
see @ref{Invalid Keyword Arguments}.
The keyword parameter specifiers may optionally be followed by the
@term{lambda list keyword} @keyref{allow-other-keys}.

In each keyword parameter specifier must be a name @param{var} for
the parameter variable.
If the @param{var} appears alone or in a @f{(@param{var} @param{init-form})}
combination, the keyword name used when matching @term{arguments} to @term{parameters}
is a @term{symbol} in the @code{KEYWORD} @term{package} whose @term{name} is the
@term{same} (under @code{string=}) as @param{var}'s.
If the notation @f{((@param{keyword-name} @param{var}) @param{init-form})} is used,
then the keyword name used to match @term{arguments} to @term{parameters} is
@param{keyword-name}, which may be a @term{symbol} in any @term{package}.
(Of course, if it is not a @term{symbol} in the @code{KEYWORD} @term{package},
it does not necessarily self-evaluate, so care must be taken when calling the function
to make sure that normal evaluation still yields the keyword name.)
Thus

@lisp
 (defun foo (&key radix (type 'integer)) ...)
@end lisp

means exactly the same as

@lisp
 (defun foo (&key ((:radix radix)) ((:type type) 'integer)) ...)
@end lisp


The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.  For each keyword parameter
specifier, if there is an argument pair whose name matches that
specifier's name (that is, the names are @code{eq}), then the
parameter variable for that specifier is bound to the second item (the
value) of that argument pair.  If more than one such argument pair
matches, the leftmost argument pair is used.  If no such argument pair
exists, then the @param{init-form} for that specifier is evaluated and
the parameter variable is bound to that value (or to @nil{}@spc{}if no
@param{init-form} was specified).  @param{supplied-p-parameter} is
treated as for @keyref{optional} parameters: it is bound to @term{true} if there
was a matching argument pair, and to @term{false} otherwise.

Unless keyword argument checking is suppressed,
an argument pair must a name matched by a parameter specifier;
see @ref{Unrecognized Keyword Arguments}.

If keyword argument checking is suppressed,
then it is permitted for an argument pair
to match no parameter specifier, and the argument pair is ignored, but
such an argument pair is accessible through the @term{rest parameter} if
one was supplied.  The purpose of these mechanisms is to allow sharing
of argument lists among several @term{lambda expressions} and to
allow either the caller or the called @term{lambda expression} to
specify that such sharing may be taking place.

Note that if @keyref{key} is present, a keyword argument of @kwd{allow-other-keys}
is always permitted---regardless of whether the associated value is @term{true}
or @term{false}.  However, if the value is @term{false}, other non-matching
keywords are not tolerated (unless @keyref{allow-other-keys} was used).

Furthermore, if the receiving argument list specifies a regular argument which
would be flagged by @kwd{allow-other-keys}, then @kwd{allow-other-keys} has both
its special-cased meaning (identifying whether additional keywords are permitted)
and its normal meaning (data flow into the function in question).

@node Suppressing Keyword Argument Checking
@subsubsection Suppressing Keyword Argument Checking

@anchor{SuppressingKeyArgChecks}

If @keyref{allow-other-keys} was specified in the @term{lambda list} of a @term{function},
@term{keyword}@sub{2} @term{argument} checking is suppressed in calls
to that @term{function}.

If @thekeyarg{allow-other-keys} is @term{true} in a call to a @term{function},
@term{keyword}@sub{2} @term{argument} checking is suppressed
in that call.

@Thekeyarg{allow-other-keys} is permissible in all situations involving
@term{keyword}@sub{2} @term{arguments}, even when its associated @term{value}
is @term{false}.

@node Examples of Suppressing Keyword Argument Checking
@subsubsection Examples of Suppressing Keyword Argument Checking


@lisp
;;; The caller can supply :ALLOW-OTHER-KEYS T to suppress checking.
 ((lambda (&key x) x) :x 1 :y 2 :allow-other-keys t) @EV{} 1
;;; The callee can use &ALLOW-OTHER-KEYS to suppress checking.
 ((lambda (&key x &allow-other-keys) x) :x 1 :y 2) @EV{} 1
;;; :ALLOW-OTHER-KEYS NIL is always permitted.
 ((lambda (&key) t) :allow-other-keys nil) @EV{} T
;;; As with other keyword arguments, only the left-most pair
;;; named :ALLOW-OTHER-KEYS has any effect.
 ((lambda (&key x) x)
  :x 1 :y 2 :allow-other-keys t :allow-other-keys nil)
@EV{} 1
;;; Only the left-most pair named :ALLOW-OTHER-KEYS has any effect,
;;; so in safe code this signals a PROGRAM-ERROR (and might enter the
;;; debugger).  In unsafe code, the consequences are undefined.
 ((lambda (&key x) x)                   ;This call is not valid
  :x 1 :y 2 :allow-other-keys nil :allow-other-keys t)
@end lisp





@node Specifiers for @keyref{aux} variables
@subsubsection Specifiers for @keyref{aux} variables
@cindex &aux

These are not really parameters.  If the @term{lambda list keyword}
@keyref{aux} is present, all specifiers after it are auxiliary variable
specifiers.  After all parameter specifiers have been processed, the
auxiliary variable specifiers (those following @aux{}) are processed
from left to right.  For each one, @param{init-form} is evaluated and
@param{var} is bound to that value (or to @nil{}@spc{}if no @param{init-form}
was specified).  @keyref{aux} variable processing is analogous to
@code{let*} processing.

@lisp
 (lambda (x y &aux (a (car x)) (b 2) c) (list x y a b c))
    @EQ{} (lambda (x y) (let* ((a (car x)) (b 2) c) (list x y a b c)))
@end lisp



@node Examples of Ordinary Lambda Lists
@subsubsection Examples of Ordinary Lambda Lists

Here are some examples involving @term{optional parameters} and @term{rest parameters}:

@lisp
 ((lambda (a b) (+ a (* b 3))) 4 5) @EV{} 19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4 5) @EV{} 19
 ((lambda (a &optional (b 2)) (+ a (* b 3))) 4) @EV{} 10
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)))
@EV{} (2 NIL 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6)
@EV{} (6 T 3 NIL NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3)
@EV{} (6 T 3 T NIL)
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x)) 6 3 8)
@EV{} (6 T 3 T (8))
 ((lambda (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))
  6 3 8 9 10 11)
@EV{} (6 t 3 t (8 9 10 11))
@end lisp


Here are some examples involving @term{keyword parameters}:

@lisp
 ((lambda (a b &key c d) (list a b c d)) 1 2) @EV{} (1 2 NIL NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6) @EV{} (1 2 6 NIL)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8) @EV{} (1 2 NIL 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :c 6 :d 8) @EV{} (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) 1 2 :d 8 :c 6) @EV{} (1 2 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a 1 :d 8 :c 6) @EV{} (:a 1 6 8)
 ((lambda (a b &key c d) (list a b c d)) :a :b :c :d) @EV{} (:a :b :d NIL)
 ((lambda (a b &key ((:sea c)) d) (list a b c d)) 1 2 :sea 6) @EV{} (1 2 6 NIL)
 ((lambda (a b &key ((c c)) d) (list a b c d)) 1 2 'c 6) @EV{} (1 2 6 NIL)
@end lisp


Here are some examples involving @term{optional parameters}, @term{rest parameters},
and @term{keyword parameters} together:

@lisp
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1)
@EV{} (1 3 NIL 1 ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 2)
@EV{} (1 2 NIL 1 ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) :c 7)
@EV{} (:c 7 NIL :c ())
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :c 7)
@EV{} (1 6 7 1 (:c 7))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8)
@EV{} (1 6 NIL 8 (:d 8))
 ((lambda (a &optional (b 3) &rest x &key c (d a))
    (list a b c d x)) 1 6 :d 8 :c 9 :d 10)
@EV{} (1 6 9 8 (:d 8 :c 9 :d 10))
@end lisp


As an example of the use of @keyref{allow-other-keys} and
@kwd{allow-other-keys}, consider a @term{function} that takes two named
arguments of its own and also accepts additional named arguments to be
passed to @code{make-array}:

@lisp
 (defun array-of-strings (str dims &rest named-pairs
                          &key (start 0) end &allow-other-keys)
   (apply #'make-array dims
          :initial-element (subseq str start end)
          :allow-other-keys t
          named-pairs))
@end lisp


This @term{function} takes a @term{string} and dimensioning
information and returns an @term{array} of the specified
dimensions, each of whose elements is the specified
@term{string}.  However, @kwd{start} and @kwd{end} named
arguments may be used to specify that a substring of the given
@term{string} should be used.  In addition, the presence of
@keyref{allow-other-keys} in the @term{lambda list} indicates that the
caller may supply additional named arguments; the @term{rest parameter}
provides access to them.  These additional named arguments are passed
to @code{make-array}.  The @term{function} @code{make-array}
normally does not allow the named arguments @kwd{start}
and @kwd{end} to be used, and an error should be
signaled if such named arguments are supplied to @code{make-array}.
However, the presence in the call to @code{make-array}
of the named argument @kwd{allow-other-keys} with
a @term{true} value causes any extraneous named arguments, including
@kwd{start} and @kwd{end}, to be acceptable and ignored.



@node Generic Function Lambda Lists
@subsection Generic Function Lambda Lists

A @newterm{generic function lambda list} is used to describe the overall shape of
the argument list to be accepted by a @term{generic function}.
Individual @term{method} @term{signatures} might contribute additional
@term{keyword parameters} to the @term{lambda list} of the @term{effective method}.

A @term{generic function lambda list} is used by @code{defgeneric}.

A @term{generic function lambda list} has the following syntax:


@auxbnf{lambda-list, @lparen{}@starparam{var}@CR{} @spc{}@ttbrac{@opt{} @star{@JustVar{}}}@CR{} @spc{}@ttbrac{@rest{} @param{var}}@CR{} @spc{}@f{[}@Vtop{}@hbox{@keyparam{} @star{@JustKey{}}}  @hbox{@brac{@allowotherkeys{}}@f{]}@rparen{}}@CR{}}

A @term{generic function lambda list} can contain the @term{lambda list keywords} shown
in @thenextfigure{}.


@float Figure,fig3.14
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{optional}}{}

@item @keyref{allow-other-keys} @tab @keyref{optional} @tab
@item @keyref{key} @tab @keyref{rest} @tab
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Generic Function Lambda Lists}
@end float


A @term{generic function lambda list} differs from an @term{ordinary lambda list}
in the following ways:


@table @asis
@item @id{@bf{Required arguments}}


Zero or more @term{required parameters} must be specified.

@item @id{@bf{Optional and keyword arguments}}


@term{Optional parameters} and @term{keyword parameters} may not have
default initial value forms nor use supplied-p parameters.

@item @id{@bf{Use of @keyref{aux}}}


The use of @keyref{aux} is not allowed.
@end table



@goodbreak{}
@node Specialized Lambda Lists
@subsection Specialized Lambda Lists

A @newterm{specialized lambda list} is used to @term{specialize} a @term{method}
for a particular @term{signature} and to describe how @term{arguments} matching
that @term{signature} are received by the @term{method}.
The @term{defined names} in @thenextfigure{}@spc{}use @term{specialized lambda lists}
in some way; see the dictionary entry for each for information about how.


@float Figure,fig3.15
@cartouche
@multitable{defmethod}{defgeneric}{}

@item defmethod @tab defgeneric @tab
@end multitable
@end cartouche
@caption{Standardized Operators that use Specialized Lambda Lists}
@end float


A @term{specialized lambda list} can contain the @term{lambda list keywords} shown
in @thenextfigure{}.


@float Figure,fig3.16
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{optional}}{@keyref{rest}}

@item @keyref{allow-other-keys} @tab @keyref{key} @tab @keyref{rest}
@item @keyref{aux} @tab @keyref{optional} @tab
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Specialized Lambda Lists}
@end float


A @term{specialized lambda list} is syntactically the same as an @term{ordinary lambda list}
except that each @term{required parameter} may optionally be associated with a @term{class}
or @term{object} for which that @term{parameter} is @term{specialized}.


@auxbnf{lambda-list, @lparen{}@star{@SpecializedVar{}}@CR{} @xparen{}@ttbrac{@opt{} @star{@VarValueSuppliedP{}}}@CR{} @xparen{}@ttbrac{@rest{} @param{var}}@CR{} @xparen{}@ttbrac{@key{} @star{@KeyVarValueSuppliedP{}} @brac{@allowotherkeys{}}}@CR{} @xparen{}@ttbrac{@aux{} @star{@VarValue{}}}@rparen{}@CR{}}


@node Macro Lambda Lists
@subsection Macro Lambda Lists

A @newterm{macro lambda list} is used in describing @term{macros}
defined by the @term{operators} in @thenextfigure{}.


@float Figure,fig3.17
@cartouche
@multitable{define-compiler-macro}{defmacro}{macrolet}

@item define-compiler-macro @tab defmacro @tab macrolet
@item define-setf-expander @tab  @tab
@end multitable
@end cartouche
@caption{Operators that use Macro Lambda Lists}
@end float


With the additional restriction that
an @term{environment parameter} may appear only once
(at any of the positions indicated),
a @term{macro lambda list} has the following syntax:

@macrolambdalist{}
@auxbnf{envvar, @ttbrac{@environment{} @param{var}}}
@auxbnf{wholevar, @ttbrac{@whole{} @param{var}}}
@auxbnf{lambda-list, @lparen{}@down{wholevar} @down{envvar} @xparen{}@down{reqvars} @down{envvar} @xparen{}@down{optvars} @down{envvar}@CR{} @xparen{}@down{restvar} @down{envvar} @xparen{}@down{keyvars} @down{envvar} @xparen{}@down{auxvars} @down{envvar}@rparen{}@spc{}|@CR{} @lparen{}@down{wholevar} @down{envvar} @xparen{}@down{reqvars} @down{envvar} @xparen{}@down{optvars} @down{envvar} @f{.} @xparen{}@param{var}@rparen{}}
@auxbnf{pattern, @paren{@down{wholevar} @down{reqvars} @down{optvars} @down{restvar} @down{keyvars} @down{auxvars}} |@CR{} @paren{@down{wholevar} @down{reqvars} @down{optvars} @f{.} @param{var}}}

A @term{macro lambda list} can contain
the @term{lambda list keywords} shown in @thenextfigure{}.


@float Figure,fig3.18
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{environment}}{@keyref{whole}}

@item @keyref{allow-other-keys} @tab @keyref{environment} @tab @keyref{rest}
@item @keyref{aux} @tab @keyref{key} @tab @keyref{whole}
@item @keyref{body} @tab @keyref{optional} @tab
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Macro Lambda Lists}
@end float


@term{Optional parameters} (introduced by @keyref{optional}) and
@term{keyword parameters} (introduced by @keyref{key})
can be supplied in a @term{macro lambda list},
just as in an @term{ordinary lambda list}.
Both may contain default initialization forms and @term{supplied-p parameters}.

@keyref{body}
@cindex &body
is identical in function to @keyref{rest},
but it can be used to inform certain output-formatting
and editing functions that the remainder of the @term{form} is
treated as a body, and should be indented accordingly.
Only one of @keyref{body} or @keyref{rest} can be used at any particular level;
see @ref{Destructuring by Lambda Lists}.
@keyref{body} can appear at any level of a
@term{macro lambda list};
for details, see @ref{Destructuring by Lambda Lists}.

@keyref{whole}
@cindex &whole
is followed by a single variable that is bound to the
entire macro-call form; this is the value that the @term{macro function}
receives as its first argument.
If @keyref{whole} and a following variable appear,
they must appear first in @param{lambda-list},
before any other parameter or @term{lambda list keyword}.
@keyref{whole} can appear at any level of a @term{macro lambda list}.
At inner levels, the @keyref{whole} variable is bound to
the corresponding part of the argument,
as with @keyref{rest}, but unlike @keyref{rest}, other arguments are also allowed.
The use of @keyref{whole} does not affect the pattern of arguments
specified.

@keyref{environment}
@cindex &environment
is followed by a single variable that is bound
to an @term{environment} representing the @term{lexical environment} in which the
macro call is to be interpreted.
This @term{environment}
should be used with
@code{macro-function},
@code{get-setf-expansion},
@code{compiler-macro-function},
and
@code{macroexpand}
(for example) in computing the expansion of the macro, to ensure that any
@term{lexical bindings} or definitions established in the
@term{compilation environment} are taken into account.
@keyref{environment} can only appear at the top level of a
@term{macro lambda list}, and can only
appear once, but can appear anywhere in that list;
the @keyref{environment} @term{parameter} is @term{bound} along with @keyref{whole}
before any other @term{variables} in the @term{lambda list}, regardless of where
@keyref{environment} appears in the @term{lambda list}.
The @term{object} that is bound to the
@term{environment parameter} has @term{dynamic extent}.

Destructuring allows a @term{macro lambda list} to express
the structure of a macro call syntax.
If no @term{lambda list keywords} appear,
then the @term{macro lambda list} is a @term{tree}
containing parameter names at the leaves.
The pattern and the @term{macro form} must have compatible @term{tree structure};
that is, their @term{tree structure} must be equivalent,
or it must differ only in that some @term{leaves} of the pattern
match @term{non-atomic} @term{objects} of the @term{macro form}.
For information about error detection in this @term{situation},
see @ref{Destructuring Mismatch}.

A destructuring @term{lambda list}
(whether at top level or embedded)
can
be dotted, ending
in a parameter name.  This situation is treated exactly as if the
parameter name that ends the @term{list} had appeared preceded by @keyref{rest}.

It is permissible for a @term{macro} @term{form} (or a @term{subexpression} of a
@term{macro} @term{form})
to be a @term{dotted list}
only  when @f{(... @ampers{}rest var)} or @f{(... . var)} is used to match
it. It is the responsibility of the @term{macro} to recognize and deal
with such situations.
@editornote{KMP: Apparently the dotted-macro-forms cleanup doesn't allow for
the macro to `manually' notice dotted forms and fix them as well.
It shouldn't be required that this be done only by @ampers{}REST or
a dotted pattern; it should only matter that ultimately the
non-macro result of a full-macro expansion not contain dots.
Anyway, I plan to address this editorially unless someone
raises an objection.}

@node Destructuring by Lambda Lists
@subsubsection Destructuring by Lambda Lists
@anchor{DestructuringByLambdaLists}

Anywhere in a @term{macro lambda list} where a parameter
name can appear, and where @term{ordinary lambda list} syntax
(as described in @ref{Ordinary Lambda Lists}) does not
otherwise allow a @term{list}, a @term{destructuring lambda list}
can appear in place
of the parameter name.  When this is done, then the argument
that would match the parameter is treated as a (possibly dotted) @term{list},
to be used as an argument list for satisfying the
parameters in the embedded @term{lambda list}.
This is known as destructuring.


Destructuring is the process of decomposing a compound @term{object} into
its component parts, using an abbreviated, declarative syntax, rather
than writing it out by hand using the primitive component-accessing
functions.  Each component part is bound to a variable.



A destructuring operation requires an @term{object} to be decomposed,
a pattern that specifies what components are to be extracted, and the names
of the variables whose values are to be the components.

@node Data-directed Destructuring by Lambda Lists
@subsubsection Data-directed Destructuring by Lambda Lists


In data-directed destructuring,
the pattern is a sample @term{object} of the @term{type} to be decomposed.
Wherever a component is to be extracted,
a @term{symbol} appears in the pattern;
this @term{symbol} is the name of the variable whose value will be that component.

@node Examples of Data-directed Destructuring by Lambda Lists
@subsubsection Examples of Data-directed Destructuring by Lambda Lists


An example pattern is

@tt{(a b c)}

which destructures a list of three elements.  The variable @f{a} is assigned
to the first element, @f{b} to the second, etc.  A more complex example
is

@tt{((first . rest) . more)}

The important features of data-directed destructuring are its syntactic
simplicity and the ability to extend it to lambda-list-directed destructuring.



@node Lambda-list-directed Destructuring by Lambda Lists
@subsubsection Lambda-list-directed Destructuring by Lambda Lists


An extension of data-directed destructuring of @term{trees} is
lambda-list-directed destructuring.  This derives from the analogy
between the three-element destructuring pattern

@tt{(first second third)}

and the three-argument @term{lambda list}

@tt{(first second third)}


Lambda-list-directed destructuring is identical to data-directed destructuring
if no @term{lambda list keywords} appear in the pattern.
Any list in the pattern (whether a sub-list or the whole pattern itself)
that contains a @term{lambda list keyword} is interpreted specially.
Elements of the list to the left of the first
@term{lambda list keyword} are treated as destructuring patterns, as usual, but the
remaining elements of the list are treated like a function's
@term{lambda list}
except that where a variable would normally be required, an arbitrary
destructuring pattern is allowed.  Note that in case of ambiguity,
@term{lambda list} syntax is preferred over destructuring syntax.  Thus, after
@keyref{optional} a list of elements is a list of a destructuring pattern
and a default value form.

The detailed behavior of each @term{lambda list keyword} in a
lambda-list-directed destructuring
pattern is as follows:


@table @asis
@item @id{@keyref{optional}}


Each following element is a variable or a list of a destructuring
pattern, a default value form, and a supplied-p variable.  The default value and
the supplied-p variable can be omitted.
If the list being destructured ends
early, so that it does not have an element to match against this destructuring
(sub)-pattern, the default form is evaluated and destructured instead.  The
supplied-p variable receives the value
@nil{}@spc{}if the default form is used, @code{t}@spc{}otherwise.

@item @id{@keyref{rest}, @keyref{body}}


The next element is a destructuring pattern that matches the
rest of the list.  @keyref{body} is identical to @keyref{rest} but declares that what
is being matched is a list of forms that constitutes the body of @term{form}.
This next element must be the last unless a @term{lambda list keyword} follows it.

@item @id{@keyref{aux}}


The remaining elements are not destructuring patterns at all, but are
auxiliary variable bindings.

@item @id{@keyref{whole}}


The next element is a destructuring pattern that matches the entire
form in a macro, or the entire @term{subexpression} at inner levels.

@item @id{@keyref{key}}


Each following element is one of

@table @asis

@item @id{@t{}}

a @term{variable},

@item @id{or}

a list of a variable,
an optional initialization form,
and an optional supplied-p variable.

@item @id{or}

a list of a list of a keyword and a destructuring pattern,
an optional initialization form,
and an optional supplied-p variable.
@end table

The rest of the list being destructured
is taken to be alternating keywords and values and is taken apart appropriately.

@item @id{@keyref{allow-other-keys}}


Stands by itself.
@end table





@node Destructuring Lambda Lists
@subsection Destructuring Lambda Lists

A @newterm{destructuring lambda list} is used by @code{destructuring-bind}.

@term{Destructuring lambda lists} are closely related to
@term{macro lambda lists}; see @ref{Macro Lambda Lists}.
A @term{destructuring lambda list} can contain all of the
@term{lambda list keywords} listed for @term{macro lambda lists}
except for @keyref{environment}, and supports destructuring in the
same way.  Inner @term{lambda lists} nested within a @term{macro lambda list}
have the syntax of @term{destructuring lambda lists}.

A @term{destructuring lambda list} has the following syntax:

@dmacrolambdalist{}
@auxbnf{envvar, @ttbrac{@environment{} @param{var}}}
@auxbnf{wholevar, @ttbrac{@whole{} @param{var}}}
@auxbnf{lambda-list, @paren{@down{wholevar} @down{reqvars} @down{optvars} @down{restvar} @down{keyvars} @down{auxvars}} |@CR{} @paren{@down{wholevar} @down{reqvars} @down{optvars} @f{.} @param{var}}}


@node Boa Lambda Lists
@subsection Boa Lambda Lists

A @newterm{boa lambda list} is a @term{lambda list} that is syntactically
like an @term{ordinary lambda list}, but that is processed in
``@b{b}y @b{o}rder of @b{a}rgument'' style.

A @term{boa lambda list} is used only in a @code{defstruct} @term{form},
when explicitly specifying the @term{lambda list}
of a constructor @term{function} (sometimes called a ``boa constructor'').

The @keyref{optional}, @keyref{rest}, @keyref{aux},
@keyref{key}, and @keyref{allow-other-keys}
@term{lambda list keywords} are recognized in a @term{boa lambda list}.
The way these @term{lambda list keywords} differ from their
use in an @term{ordinary lambda list} follows.

Consider this example, which describes how @code{destruct} processes
its @kwd{constructor} option.

@lisp
 (:constructor create-foo
         (a &optional b (c 'sea) &rest d &aux e (f 'eff)))
@end lisp


This defines @f{create-foo} to be a constructor of one or more arguments.
The first argument is used to initialize the @f{a} slot.  The second
argument is used to initialize the @f{b} slot.  If there isn't any
second argument, then the default value given in the body of the
@code{defstruct} (if given) is used instead.
The third argument is used to
initialize the @f{c} slot.  If there isn't any third argument, then the
symbol @f{sea} is used instead.  Any arguments following the third
argument are collected into a @term{list}
and used to initialize the @f{d}
slot.  If there are three or fewer arguments, then @nil{}@spc{}is placed in
the @f{d} slot.  The @f{e} slot is not initialized;
its initial value is @term{implementation-defined}.
Finally, the @f{f} slot is initialized to contain the symbol @f{eff}.
@keyref{key} and @keyref{allow-other-keys} arguments default
in a manner similar to that of @keyref{optional} arguments: if no default
is supplied in the @term{lambda list} then the default value
given in the body of the @code{defstruct} (if given) is used instead.
For example:

@lisp
 (defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)
                                             &key (d 2)
                                             &aux e (f 'eff))))
   (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))

 (create-foo 10) @EV{} #S(FOO A 10 B 2 C SEA D 2 E @term{implemention-dependent} F EFF)
 (create-foo 10 'bee 'see :d 'dee)
@EV{} #S(FOO A 10 B BEE C SEE D DEE E @term{implemention-dependent} F EFF)
@end lisp


If keyword arguments of the form
@f{((@i{key} @i{var}) @brac{@i{default} @brac{@i{svar}}})}
are specified, the @term{slot} @term{name} is matched with @i{var}
(not @i{key}).

The actions taken in the @f{b} and @f{e} cases were carefully
chosen to allow the user to specify all possible behaviors.
The @keyref{aux} variables can be used to completely override the default
initializations given in the body.

If no default value is supplied for an @term{aux variable} variable,
the consequences are undefined if an attempt is later made to read
the corresponding @term{slot}'s value before a value is explicitly assigned.
If such a @term{slot} has a @kwd{type} option specified,
this suppressed initialization does not imply a type mismatch situation;
the declared type is only required to apply when the @term{slot} is finally assigned.

With this definition, the following can be written:

@lisp
 (create-foo 1 2)
@end lisp

instead of

@lisp
 (make-foo :a 1 :b 2)
@end lisp

and @f{create-foo} provides defaulting different
from that of @f{make-foo}.

Additional arguments that do not correspond to slot names but
are merely present to supply values used in subsequent initialization
computations are allowed.
For example, in the definition

@lisp
 (defstruct (frob (:constructor create-frob
                  (a &key (b 3 have-b) (c-token 'c)
                          (c (list c-token (if have-b 7 2))))))
         a b c)
@end lisp


the @tt{c-token} argument is used merely to supply a value used in the
initialization of the @tt{c} slot. The @term{supplied-p parameters}
associated with @term{optional parameters} and @term{keyword parameters}
might also be used this way.



@node Defsetf Lambda Lists
@subsection Defsetf Lambda Lists

A @newterm{defsetf lambda list} is used by @code{defsetf}.

A @term{defsetf lambda list} has the following syntax:


@auxbnf{lambda-list, @lparen{}@starparam{var}@CR{} @xparen{}@ttbrac{@opt{} @star{@VarValueSuppliedP{}}}@CR{} @xparen{}@ttbrac{@rest{} @param{var}}@CR{} @xparen{}@f{[}@Vtop{}@hbox{@key{} @star{@KeyVarValueSuppliedP{}}}  @hbox{@brac{@allowotherkeys{}}@f{]}}@CR{} @xparen{}@ttbrac{@environment{} @param{var}}}

A @term{defsetf lambda list} can contain the @term{lambda list keywords} shown
in @thenextfigure{}.


@float Figure,fig3.19
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{optional}}{@keyref{rest}}

@item @keyref{allow-other-keys} @tab @keyref{key} @tab @keyref{rest}
@item @keyref{environment} @tab @keyref{optional} @tab
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Defsetf Lambda Lists}
@end float


A @term{defsetf lambda list} differs from an @term{ordinary lambda list}
only in that it does not permit the use of @keyref{aux},
and that it permits use of @keyref{environment},
which introduces an @term{environment parameter}.


@node Deftype Lambda Lists
@subsection Deftype Lambda Lists

A @newterm{deftype lambda list} is used by @code{deftype}.

A @term{deftype lambda list} has the same syntax as a @term{macro lambda list},
and can therefore contain the @term{lambda list keywords} as a @term{macro lambda list}.

A @term{deftype lambda list} differs from a @term{macro lambda list}
only in that if no @param{init-form} is supplied for an @term{optional parameter}
or @term{keyword parameter} in the @param{lambda-list}, the default @term{value}
for that @term{parameter} is the @term{symbol} @t{*} (rather than @nil{}).


@node Define-modify-macro Lambda Lists
@subsection Define-modify-macro Lambda Lists

A @newterm{define-modify-macro lambda list} is used by
@code{define-modify-macro}.

A @term{define-modify-macro lambda list} can contain the
@term{lambda list keywords} shown in @thenextfigure{}.


@float Figure,fig3.20
@cartouche
@multitable{@keyref{optional}}{@keyref{rest}}

@item @keyref{optional} @tab @keyref{rest}
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Define-modify-macro Lambda Lists}
@end float


@term{Define-modify-macro lambda lists} are similar to
@term{ordinary lambda lists}, but do not support keyword arguments.
@code{define-modify-macro} has no need match keyword arguments, and
a @term{rest parameter} is sufficient.  @term{Aux variables} are also
not supported, since @code{define-modify-macro} has no body @term{forms}
which could refer to such @term{bindings}.  See the @term{macro} @ref{define-modify-macro}.


@node Define-method-combination Arguments Lambda Lists
@subsection Define-method-combination Arguments Lambda Lists

A @newterm{define-method-combination arguments lambda list} is used by
the @kwd{arguments} option to @code{define-method-combination}.

A @term{define-method-combination arguments lambda list} can contain the
@term{lambda list keywords} shown in @thenextfigure{}.


@float Figure,fig3.21
@cartouche
@multitable{@keyref{allow-other-keys}}{@keyref{optional}}{@keyref{whole}}

@item @keyref{allow-other-keys} @tab @keyref{key} @tab @keyref{rest}
@item @keyref{aux} @tab @keyref{optional} @tab @keyref{whole}
@end multitable
@end cartouche
@caption{Lambda List Keywords used by Define-method-combination arguments Lambda Lists}
@end float


@term{Define-method-combination arguments lambda lists} are similar to
@term{ordinary lambda lists}, but also permit the use of @keyref{whole}.


@node Syntactic Interaction of Documentation Strings and Declarations
@subsection Syntactic Interaction of Documentation Strings and Declarations

In a number of situations, a @term{documentation string} can appear amidst a
series of @t{declare} @term{expressions} prior to a series of @term{forms}.

In that case, if a @term{string} @mat{S} appears where a @term{documentation string} is
permissible and is not followed by
either a @t{declare} @term{expression}
or a @term{form}
then @mat{S} is taken to be a @term{form};
otherwise, @mat{S} is taken as a @term{documentation string}.
The consequences are unspecified if more than one such @term{documentation string}
is present.


@node Error Checking in Function Calls
@section Error Checking in Function Calls


@menu
* Argument Mismatch Detection::
@end menu
@node Argument Mismatch Detection
@subsection Argument Mismatch Detection

@node Safe and Unsafe Calls
@subsubsection Safe and Unsafe Calls
@anchor{SafeAndUnsafeCalls}

A @term{call} is a @newterm{safe call} if each of the following is
either @term{safe} @term{code} or @term{system code} (other than
@term{system code} that results from @term{macro expansion} of
@term{programmer code}):

@itemize @bullet{}
@item the @term{call}.
@item the definition of the @term{function} being @term{called}.
@item the point of @term{functional evaluation}
@end itemize


The following special cases require some elaboration:


@itemize @bullet{}
@item
If the @term{function} being called is a @term{generic function},
it is considered @term{safe} if all of the following are
@term{safe code} or @term{system code}:


@itemize --
@item its definition (if it was defined explicitly).
@item the @term{method} definitions for all @term{applicable} @term{methods}.
@item the definition of its @term{method combination}.
@end itemize


@item
For the form @f{(coerce @param{x} 'function)},
where @param{x} is a @term{lambda expression},
the value of the @term{optimize quality} @code{safety}
in the global environment at the time the @code{coerce}
is @term{executed} applies to the resulting @term{function}.



@item
For a call to @thefunction{ensure-generic-function}, the value of the
@term{optimize quality} @code{safety} in the @term{environment}
@term{object} passed as the @kwd{environment} @term{argument} applies
to the resulting @term{generic function}.

@item
For a call to @code{compile} with a @term{lambda expression} as the
@term{argument}, the value of the @term{optimize quality} @code{safety}
in the @term{global environment} at the time @code{compile} is @term{called}
applies to the resulting @term{compiled function}.

@item
For a call to @code{compile} with only one argument, if the original definition
of the @term{function} was @term{safe}, then the resulting @term{compiled function}
must also be @term{safe}.

@item
A @term{call} to a @term{method} by @code{call-next-method} must be
considered @term{safe} if each of the following is
@term{safe code} or @term{system code}:


@itemize --
@item the definition of the @term{generic function} (if it was defined explicitly).
@item the @term{method} definitions for all @term{applicable} @term{methods}.
@item the definition of the @term{method combination}.
@item the point of entry into the body of the @term{method defining form},
where the @term{binding} of @code{call-next-method} is established.
@item the point of @term{functional evaluation} of the name @code{call-next-method}.
@end itemize

@end itemize


An @newterm{unsafe call} is a @term{call} that is not a @term{safe call}.

The informal intent is that the @term{programmer} can rely on a @term{call}
to be @term{safe}, even when @term{system code} is involved, if all reasonable
steps have been taken to ensure that the @term{call} is @term{safe}.
For example, if a @term{programmer} calls @code{mapcar} from @term{safe}
@term{code} and supplies a @term{function} that was @term{compiled}
as @term{safe}, the @term{implementation} is required to ensure that
@code{mapcar} makes a @term{safe call} as well.

@node Error Detection Time in Safe Calls
@subsubsection Error Detection Time in Safe Calls


If an error is signaled in a @term{safe call},
the exact point of the @term{signal} is @term{implementation-dependent}.
In particular, it might be signaled at compile time or at run time,
and if signaled at run time,
it might be prior to, during, or after @term{executing} the @term{call}.
However, it is always prior to the execution of the body of the @term{function}
being @term{called}.



@node Too Few Arguments
@subsubsection Too Few Arguments

It is not permitted to supply too few @term{arguments} to a @term{function}.
Too few arguments means fewer @term{arguments} than the number of @term{required parameters}
for the @term{function}.

If this @term{situation} occurs in a @term{safe call},
an error @oftype{program-error} must be signaled;
and in an @term{unsafe call} the @term{situation} has undefined consequences.


@node Too Many Arguments
@subsubsection Too Many Arguments

It is not permitted to supply too many @term{arguments} to a @term{function}.
Too many arguments means more @term{arguments} than the number of @term{required parameters}
plus the number of @term{optional parameters}; however, if the @term{function}
uses @keyref{rest} or @keyref{key}, it is not possible for it to receive too many arguments.

If this @term{situation} occurs in a @term{safe call},
an error @oftype{program-error} must be signaled;
and in an @term{unsafe call} the @term{situation} has undefined consequences.


@node Unrecognized Keyword Arguments
@subsubsection Unrecognized Keyword Arguments
@anchor{UnrecognizedKeyArgs}

It is not permitted to supply a keyword argument to a @term{function}
using a name that is not recognized by that @term{function}
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking}.

If this @term{situation} occurs in a @term{safe call},
an error @oftype{program-error} must be signaled;
and in an @term{unsafe call} the @term{situation} has undefined consequences.


@node Invalid Keyword Arguments
@subsubsection Invalid Keyword Arguments
@anchor{InvalidKeyArgs}

It is not permitted to supply a keyword argument to a @term{function}
using a name that is not a @term{symbol}.

If this @term{situation} occurs in a @term{safe call},
an error @oftype{program-error} must be signaled
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking};
and in an @term{unsafe call} the @term{situation} has undefined consequences.


@node Odd Number of Keyword Arguments
@subsubsection Odd Number of Keyword Arguments
@anchor{OddNumberOfKeyArgs}


An odd number of @term{arguments} must not be supplied for the @term{keyword parameters}.

If this @term{situation} occurs in a @term{safe call},
an error @oftype{program-error} must be signaled
unless keyword argument checking is suppressed as described
in @ref{Suppressing Keyword Argument Checking};
and in an @term{unsafe call} the @term{situation} has undefined consequences.



@node Destructuring Mismatch
@subsubsection Destructuring Mismatch
@anchor{DestructuringMismatch}


When matching a @term{destructuring lambda list} against a @term{form},
the pattern and the @term{form} must have compatible @term{tree structure},
as described in @ref{Macro Lambda Lists}.

Otherwise, in a @term{safe call},
an error @oftype{program-error} must be signaled;
and in an @term{unsafe call} the @term{situation} has undefined consequences.



@node Errors When Calling a Next Method
@subsubsection Errors When Calling a Next Method

If @code{call-next-method} is called with @term{arguments}, the ordered
set of @term{applicable} @term{methods} for the changed set of @term{arguments}
for @code{call-next-method} must be the same as the ordered set of
@term{applicable} @term{methods} for the original @term{arguments} to the
@term{generic function}, or else an error should be signaled.

The comparison between the set of methods applicable to the
new arguments and the set applicable to the original arguments is
insensitive to order differences among methods with the same
specializers.

If @code{call-next-method} is called with @term{arguments} that specify
a different ordered set of @term{applicable} methods and there is no
@term{next method} available, the test for different methods and the
associated error signaling (when present) takes precedence over calling
@code{no-next-method}.




@node Traversal Rules and Side Effects
@section Traversal Rules and Side Effects


The consequences are undefined
when @term{code} executed during an @term{object-traversing} operation
destructively modifies the @term{object} in a way that might affect the
ongoing traversal operation.
In particular, the following rules apply.

@table @asis
@item @id{@b{List traversal}}


For @term{list} traversal operations, the @term{cdr} chain of the
@term{list} is not allowed to be destructively modified.

@item @id{@b{Array traversal}}


For @term{array} traversal operations, the @term{array} is not allowed
to be adjusted and its @term{fill pointer}, if any, is not allowed to
be changed.

@item @id{@b{Hash-table traversal}}


For @term{hash table} traversal operations, new elements may not be added
or deleted except that the element corresponding to the current hash key
may be changed or removed.

@item @id{@b{Package traversal}}


For @term{package} traversal operations (@eg{} @code{do-symbols}),
new @term{symbols} may not be @term{interned} in or @term{uninterned}
from the @term{package} being traversed
or any @term{package} that it uses except that the
current @term{symbol} may be @term{uninterned} from the @term{package}
being traversed.
@end table



@node Destructive Operations
@section Destructive Operations

@menu
* Modification of Literal Objects::
* Transfer of Control during a Destructive Operation::
@end menu
@node Modification of Literal Objects
@subsection Modification of Literal Objects

The consequences are undefined if @term{literal} @term{objects}
are destructively modified.  For this purpose, the following operations
are considered @term{destructive}:


@table @asis

@item @id{@code{random-state}}


Using it as an @term{argument} to @thefunction{random}.

@item @id{@code{cons}}


Changing the @term{car}@sub{1} or @term{cdr}@sub{1} of the @term{cons},
or performing a @term{destructive} operation on an @term{object} which is either
the @term{car}@sub{2} or the @term{cdr}@sub{2} of the @term{cons}.

@item @id{@code{array}}


Storing a new value into some element of the @term{array},
or performing a @term{destructive} operation
on an @term{object} that is already such an @term{element}.

Changing the @term{fill pointer}, @term{dimensions}, or displacement of
the @term{array} (regardless of whether the @term{array} is @term{actually adjustable}).

Performing a @term{destructive} operation on another @term{array}
that is displaced to the @term{array} or that otherwise shares its contents
with the @term{array}.

@item @id{@code{hash-table}}


Performing a @term{destructive} operation on any @term{key}.

Storing a new @term{value}@sub{4} for any @term{key},
or performing a @term{destructive} operation
on any @term{object} that is such a @term{value}.

Adding or removing entries from the @term{hash table}.

@item @id{@code{structure-object}}


Storing a new value into any slot,
or performing a @term{destructive} operation on an @term{object}
that is the value of some slot.

@item @id{@code{standard-object}}


Storing a new value into any slot,
or performing a @term{destructive} operation on an @term{object}
that is the value of some slot.

Changing the class of the @term{object} (@eg{} using @thefunction{change-class}).

@item @id{@code{readtable}}


Altering the @term{readtable case}.

Altering the syntax type of any character in this readtable.

Altering the @term{reader macro function} associated with any @term{character}
in the @term{readtable}, or altering the @term{reader macro functions}
associated with @term{characters} defined as @term{dispatching macro characters}
in the @term{readtable}.

@item @id{@code{stream}}


Performing I/O operations on the @term{stream},
or @term{closing} the @term{stream}.

@item @id{All other standardized types}


[This category includes, for example, @code{character},
@code{condition},
@code{function},
@code{method-combination},
@code{method},
@code{number},
@code{package},
@code{pathname},
@code{restart},
and @code{symbol}.]

There are no @term{standardized} @term{destructive} operations
defined on @term{objects} of these @term{types}.
@end table



@node Transfer of Control during a Destructive Operation
@subsection Transfer of Control during a Destructive Operation

Should a transfer of control out of a @term{destructive} operation occur
(@eg{} due to an error) the state of the @param{object} being modified is
@term{implementation-dependent}.

@node Examples of Transfer of Control during a Destructive Operation
@subsubsection Examples of Transfer of Control during a Destructive Operation

The following examples illustrate some of the many ways in which the
@term{implementation-dependent} nature of the modification can manifest
itself.

@lisp
 (let ((a (list 2 1 4 3 7 6 'five)))
   (ignore-errors (sort a #'<))
   a)
@EV{} (1 2 3 4 6 7 FIVE)
@OV{} (2 1 4 3 7 6 FIVE)
@OV{} (2)

 (prog foo ((a (list 1 2 3 4 5 6 7 8 9 10)))
   (sort a #'(lambda (x y) (if (zerop (random 5)) (return-from foo a) (> x y)))))
@EV{} (1 2 3 4 5 6 7 8 9 10)
@OV{} (3 4 5 6 2 7 8 9 10 1)
@OV{} (1 2 4 3)
@end lisp


@node Evaluation and Compilation Dictionary
@section Evaluation and Compilation Dictionary


@menu
* lambda (Symbol)::
* lambda (Macro)::
* compile::
* eval::
* eval-when::
* load-time-value::
* quote::
* compiler-macro-function::
* define-compiler-macro::
* defmacro::
* macro-function::
* macroexpand; macroexpand-1::
* define-symbol-macro::
* symbol-macrolet::
* *macroexpand-hook*::
* proclaim::
* declaim::
* declare::
* ignore; ignorable::
* dynamic-extent::
* type::
* inline; notinline::
* ftype::
* declaration::
* optimize::
* special::
* locally::
* the::
* special-operator-p::
* constantp::
@end menu

@node lambda (Symbol)
@subsection lambda (Symbol)
@syindex lambda
@cindex lambda



@subsubheading Syntax:

@Defspec{lambda, lambda-list @DeclsAndDoc{} @starparam{form}}

@subsubheading Arguments:

@param{lambda-list}---an @term{ordinary lambda list}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{documentation}---a @term{string}; @noeval{}.

@param{form}---a @term{form}.

@subsubheading Description:

A @term{lambda expression} is a @term{list} that can be used in place of a
@term{function name} in certain contexts to denote a @term{function} by
directly describing its behavior rather than indirectly by referring to the
name of an @term{established} @term{function}.

@param{Documentation} is attached to the denoted @param{function} (if any
is actually created) as a @term{documentation string}.

@subsubheading See Also:

@ref{function (Special Operator)},
@ref{documentation},
@ref{Lambda Expressions},
@ref{Lambda Forms},
@ref{Syntactic Interaction of Documentation Strings and Declarations}

@subsubheading Notes:

The @term{lambda form}

@lisp
 ((lambda @param{lambda-list} . @param{body}) . @param{arguments})
@end lisp


is semantically equivalent to the @term{function form}

@lisp
 (funcall #'(lambda @param{lambda-list} . @param{body}) . @param{arguments})
@end lisp




@node lambda (Macro)
@subsection lambda (Macro)
@syindex lambda
@cindex lambda


@subsubheading Syntax:

@DefmacWithValues{lambda, lambda-list @DeclsAndDoc{} @starparam{form}, @param{function}}

@subsubheading Arguments and Values:

@param{lambda-list}---an @term{ordinary lambda list}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{documentation}---a @term{string}; @noeval{}.

@param{form}---a @term{form}.

@param{function}---a @term{function}.

@subsubheading Description:

Provides a shorthand notation for a @code{function} @term{special form}
involving a @term{lambda expression} such that:

@lisp
    (lambda @param{lambda-list} @DeclsAndDoc{} @starparam{form})
 @EQ{} (function (lambda @param{lambda-list} @DeclsAndDoc{} @starparam{form}))
 @EQ{} #'(lambda @param{lambda-list} @DeclsAndDoc{} @starparam{form})
@end lisp


@subsubheading Examples:

@lisp
 (funcall (lambda (x) (+ x 3)) 4) @EV{} 7
@end lisp


@subsubheading See Also:

@ref{lambda (Symbol)} (symbol)

@subsubheading Notes:

This macro could be implemented by:

@lisp
(defmacro lambda (&whole form &rest bvl-decls-and-body)
  (declare (ignore bvl-decls-and-body))
  `#',form)
@end lisp



@node compile
@subsection compile (Function)
@syindex compile
@cindex compile



@subsubheading Syntax:

@DefunWithValues{compile, name @opt{} definition, function\, warnings-p\, failure-p}

@subsubheading Arguments and Values:

@param{name}---a @term{function name}, or @nil{}.

@param{definition}---a @term{lambda expression} or a @term{function}.
@Default{the function definition of @param{name} if it names a @term{function},
or the @term{macro function} of @param{name} if it names a @term{macro}}
The consequences are undefined if no @param{definition} is supplied
when the @param{name} is @nil{}.

@param{function}---the @param{function-name},
or a @term{compiled function}.

@param{warnings-p}---a @term{generalized boolean}.

@param{failure-p}---a @term{generalized boolean}.

@subsubheading Description:

Compiles an @term{interpreted function}.

@code{compile} produces a @term{compiled function} from @param{definition}.
If the @param{definition} is a @term{lambda expression},
it is coerced to a @term{function}.
If the @param{definition} is already a @term{compiled function},
@code{compile} either produces that function itself (@ie{} is an identity operation)
or an equivalent function.

@editornote{KMP: There are a number of ambiguities here that still need resolution.}
If the @param{name} is @nil{},
the resulting @term{compiled function} is returned directly as the @term{primary value}.
If a @term{non-nil} @param{name} is given,
then the resulting @term{compiled function} replaces
the existing @term{function} definition of @param{name}
and the @param{name} is returned as the @term{primary value};
if @param{name} is a @term{symbol} that names a @term{macro},
its @term{macro function} is updated
and the @param{name} is returned as the @term{primary value}.

@term{Literal objects} appearing in code processed by
the @code{compile} function are neither copied nor @term{coalesced}.
The code resulting from the execution of @code{compile}
references @term{objects} that are @code{eql} to the corresponding
@term{objects} in the source code.

@code{compile} is permitted, but not required, to @term{establish}
a @term{handler} for @term{conditions} @oftype{error}.
For example, the @term{handler} might issue a warning and
restart compilation from some @term{implementation-dependent} point
in order to let the compilation proceed without manual intervention.

The @term{secondary value}, @param{warnings-p}, is @term{false}
if no @term{conditions} @oftype{error} or @code{warning}
were detected by the compiler, and @term{true} otherwise.

The @term{tertiary value}, @param{failure-p}, is @term{false}
if no @term{conditions} @oftype{error} or @code{warning}
(other than @code{style-warning})
were detected by the compiler, and @term{true} otherwise.

@subsubheading Examples:

@lisp
 (defun foo () "bar") @EV{} FOO
 (compiled-function-p #'foo) @EV{} @term{implementation-dependent}
 (compile 'foo) @EV{} FOO
 (compiled-function-p #'foo) @EV{} @term{true}
 (setf (symbol-function 'foo)
       (compile nil '(lambda () "replaced"))) @EV{} #<Compiled-Function>
 (foo) @EV{} "replaced"
@end lisp


@subsubheading Affected By:

@code{*error-output*},
@code{*macroexpand-hook*}.

The presence of macro definitions and proclamations.

@subsubheading Exceptional Situations:

The consequences are undefined if the @term{lexical environment} surrounding the
@term{function} to be compiled contains any @term{bindings} other than those for
@term{macros}, @term{symbol macros}, or @term{declarations}.


For information about errors detected during the compilation process,
see @ref{Exceptional Situations in the Compiler}.

@subsubheading See Also:

@ref{compile-file}


@node eval
@subsection eval (Function)
@syindex eval
@cindex eval


@subsubheading Syntax:

@DefunWithValues{eval, form, @starparam{result}}

@subsubheading Arguments and Values:

@param{form}---a @term{form}.

@param{results}---the @term{values} @term{yielded} by the @term{evaluation} of @param{form}.

@subsubheading Description:

Evaluates @param{form} in the current @term{dynamic environment}
and the @term{null lexical environment}.

@code{eval} is a user interface to the evaluator.

The evaluator expands macro calls as if through the use of @code{macroexpand-1}.

Constants appearing in code
processed by @code{eval} are
not copied nor coalesced. The code resulting from the execution of
@code{eval}
references @term{objects}
that are @code{eql} to the corresponding @term{objects} in
the source code.

@subsubheading Examples:

@lisp
 (setq form '(1+ a) a 999) @EV{} 999
 (eval form) @EV{} 1000
 (eval 'form) @EV{} (1+ A)
 (let ((a '(this would break if eval used local value))) (eval form))
@EV{} 1000
@end lisp


@subsubheading See Also:

@ref{macroexpand-1},
@ref{The Evaluation Model}

@subsubheading Notes:

To obtain the current dynamic value of a @term{symbol},
use of @code{symbol-value} is equivalent (and usually preferable)
to use of @code{eval}.

Note that an @code{eval} @term{form} involves two levels of @term{evaluation}
for its @term{argument}.  First, @param{form} is @term{evaluated} by the
normal argument evaluation mechanism as would occur with any @term{call}.
The @term{object} that results from this normal @term{argument} @term{evaluation}
becomes the @term{value} of the @param{form} @term{parameter}, and is then
@term{evaluated} as part of the @code{eval} @term{form}.
For example:

@lisp
 (eval (list 'cdr (car '((quote (a . b)) c)))) @EV{} b
@end lisp

The @term{argument} @term{form} @f{(list 'cdr (car '((quote (a . b)) c)))} is evaluated
in the usual way to produce the @term{argument} @f{(cdr (quote (a . b)))};
@code{eval} then evaluates its @term{argument}, @f{(cdr (quote (a . b)))}, to produce @f{b}.
Since a single @term{evaluation} already occurs for any @term{argument} @term{form}
in any @term{function form},
@code{eval} is sometimes said to perform ``an extra level of evaluation.''



@node eval-when
@subsection eval-when (Special Operator)
@syindex eval-when
@cindex eval-when


@subsubheading Syntax:

@DefspecWithValues{eval-when, @paren{@starparam{situation}} @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{situation}---One of the @term{symbols}
@kwd{compile-toplevel}
@cindex :compile-toplevel
,
@kwd{load-toplevel}
@cindex :load-toplevel
,
@kwd{execute}
@cindex :execute
,
@t{compile}
@cindex compile
,
@t{load}
@cindex load
, or
@t{eval}
@cindex eval
.

The use of @t{eval}, @t{compile}, and @t{load} is deprecated.

@param{forms}---an @term{implicit progn}.

@param{results}---the @term{values} of the @term{forms} if they are executed,
or @nil{}@spc{}if they are not.

@subsubheading Description:

The body of an @code{eval-when} form is processed as an @term{implicit progn},
but only in the @param{situations} listed.



The use of the @param{situations} @kwd{compile-toplevel} (or @tt{compile}) and
@kwd{load-toplevel} (or @tt{load}) controls whether and when @term{evaluation}
occurs when @code{eval-when} appears as a @term{top level form} in
code processed by @code{compile-file}.  See @ref{File Compilation}.

The use of the @param{situation} @kwd{execute} (or @tt{eval}) controls whether
evaluation occurs for other @code{eval-when} @term{forms}; that is,
those that are not @term{top level forms}, or those in code processed by
@code{eval} or @code{compile}.  If the @kwd{execute} situation is
specified in such a @term{form}, then the body @param{forms} are processed as
an @term{implicit progn}; otherwise, the @code{eval-when} @term{form}
returns @nil{}.



@code{eval-when}
normally appears as a @term{top level form}, but it is meaningful
for it to appear as a @term{non-top-level form}.
However, the compile-time side
effects described in @ref{Compilation}
only take place when @code{eval-when} appears as a
@term{top level form}.


@subsubheading Examples:

One example of the use of @code{eval-when} is that for the
compiler to be able to read a file properly when it uses user-defined
@term{reader macros}, it is necessary to write

@lisp
 (eval-when (:compile-toplevel :load-toplevel :execute)
   (set-macro-character #@bsl{}$ #'(lambda (stream char)
                                (declare (ignore char))
                                (list 'dollar (read stream))))) @EV{} T
@end lisp

This causes the call to @code{set-macro-character} to be executed
in the compiler's execution environment, thereby modifying its
reader syntax table.

@lisp
;;;     The EVAL-WHEN in this case is not at toplevel, so only the :EXECUTE
;;;     keyword is considered. At compile time, this has no effect.
;;;     At load time (if the LET is at toplevel), or at execution time
;;;     (if the LET is embedded in some other form which does not execute
;;;     until later) this sets (SYMBOL-FUNCTION 'FOO1) to a function which
;;;     returns 1.
 (let ((x 1))
   (eval-when (:execute :load-toplevel :compile-toplevel)
     (setf (symbol-function 'foo1) #'(lambda () x))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting
;;;     (SYMBOL-FUNCTION 'FOO2) to a function which returns 2.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (let ((x 2))
     (eval-when (:execute :load-toplevel :compile-toplevel)
       (setf (symbol-function 'foo2) #'(lambda () x)))))

;;;     If this expression occurs at the toplevel of a file to be compiled,
;;;     it has BOTH a compile time AND a load-time effect of setting the
;;;     function cell of FOO3 to a function which returns 3.
 (eval-when (:execute :load-toplevel :compile-toplevel)
   (setf (symbol-function 'foo3) #'(lambda () 3)))

;;; #4: This always does nothing. It simply returns NIL.
 (eval-when (:compile-toplevel)
   (eval-when (:compile-toplevel)
     (print 'foo4)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO5 is
;;;     printed at compile time. If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:compile-toplevel)
   (eval-when (:execute)
     (print 'foo5)))

;;;     If this form occurs at toplevel of a file to be compiled, FOO6 is
;;;     printed at compile time.  If this form occurs in a non-top-level
;;;     position, nothing is printed at compile time. Regardless of context,
;;;     nothing is ever printed at load time or execution time.
 (eval-when (:execute :load-toplevel)
   (eval-when (:compile-toplevel)
     (print 'foo6)))
@end lisp


@subsubheading See Also:

@ref{compile-file}, @ref{Compilation}

@subsubheading Notes:

The following effects are logical consequences of the definition of
@code{eval-when}:


@itemize @bullet{}
@item
Execution of a single @code{eval-when}
expression executes the body code at most once.

@item
@term{Macros} intended for use in @term{top level forms}
should be written so that side-effects are done by the @term{forms}
in the macro expansion.  The macro-expander itself should not do
the side-effects.

For example:

Wrong:

@lisp
 (defmacro foo ()
   (really-foo)
   `(really-foo))
@end lisp


Right:

@lisp
 (defmacro foo ()
   `(eval-when (:compile-toplevel :execute :load-toplevel) (really-foo)))
@end lisp


Adherence to this convention means that such @term{macros} behave
intuitively when appearing as @term{non-top-level forms}.

@item
Placing a variable binding around an @code{eval-when} reliably
captures the binding because the compile-time-too mode cannot occur
(@ie{} introducing a variable binding means that the @code{eval-when}
is not a @term{top level form}).
For example,

@lisp
 (let ((x 3))
   (eval-when (:execute :load-toplevel :compile-toplevel) (print x)))
@end lisp


prints @tt{3}
at execution (@ie{} load) time, and does not print anything at
compile time.  This is important so that expansions of
@code{defun} and
@code{defmacro}
can be done in terms of @code{eval-when} and can correctly capture
the @term{lexical environment}.

@lisp
 (defun bar (x) (defun foo () (+ x 3)))
@end lisp


might expand into

@lisp
 (defun bar (x)
   (progn (eval-when (:compile-toplevel)
            (compiler::notice-function-definition 'foo '(x)))
          (eval-when (:execute :load-toplevel)
            (setf (symbol-function 'foo) #'(lambda () (+ x 3))))))
@end lisp


which would be treated by the above rules the same as

@lisp
 (defun bar (x)
   (setf (symbol-function 'foo) #'(lambda () (+ x 3))))
@end lisp


when the definition of @f{bar} is not a @term{top level form}.
@end itemize




@node load-time-value
@subsection load-time-value (Special Operator)
@syindex load-time-value
@cindex load-time-value


@subsubheading Syntax:

@DefspecWithValues{load-time-value, form @opt{} read-only-p, object}

@subsubheading Arguments and Values:

@param{form}---a @term{form}; @evalspecial{}.

@param{read-only-p}---a @term{boolean}; @noeval{}.

@param{object}---the @term{primary value} resulting from evaluating @param{form}.

@subsubheading Description:

@code{load-time-value} provides a mechanism for delaying evaluation of @param{form}
until the expression is in the run-time environment; see @ref{Compilation}.

@param{Read-only-p} designates whether the result can be considered a
@term{constant object}.
If @code{t},
the result is a read-only quantity that can,
if appropriate to the @term{implementation},
be copied into read-only space and/or @term{coalesced} with @term{similar}
@term{constant objects} from other @term{programs}.
If @nil{}@spc{}(the default),
the result must be neither copied nor coalesced;
it must be considered to be potentially modifiable data.

If a @code{load-time-value} expression is processed by @code{compile-file},
the compiler performs its normal semantic processing (such as macro expansion
and translation into machine code) on @param{form}, but arranges for the
execution of @param{form} to occur at load time in a @term{null lexical environment},
with the result of this @term{evaluation} then being treated as
a @term{literal object}
at run time.  It is guaranteed that the evaluation of @param{form}
will take place only once when the @term{file} is @term{loaded}, but
the order of evaluation with respect to the evaluation of
@term{top level forms} in the file is @term{implementation-dependent}.
@cindex order of evaluation
@cindex evaluation order

If a @code{load-time-value} expression appears within a function compiled
with @code{compile}, the @param{form} is evaluated at compile time in a
@term{null lexical environment}.  The result of this compile-time evaluation
is treated as
a @term{literal object}
in the compiled code.

If a @code{load-time-value} expression is processed by @code{eval},
@param{form} is evaluated in a @term{null lexical environment},
and one value is returned.  Implementations that implicitly compile
(or partially compile) expressions processed by @code{eval}
might evaluate @param{form} only once, at the time this compilation is performed.

If the @term{same} @term{list} @f{(load-time-value @param{form})} is
evaluated or compiled more than once, it is @term{implementation-dependent}
whether @param{form} is evaluated only once or is evaluated more than once.
This can happen both when an expression being evaluated or compiled shares
substructure, and when the @term{same} @term{form} is processed by @code{eval} or
@code{compile} multiple times.
Since a @code{load-time-value} expression can be
referenced in more than one place and can be evaluated multiple times
by @code{eval}, it is
@term{implementation-dependent} whether each execution returns
a fresh @term{object}
or returns the same @term{object} as some other execution.
Users must use caution when destructively modifying the resulting
@term{object}.

If two lists @f{(load-time-value @param{form})}
that are the @term{same} under @code{equal} but are not @term{identical}
are evaluated or compiled,
their values always come from distinct evaluations of @param{form}.
Their @term{values} may not be coalesced
unless @param{read-only-p} is @code{t}.

@subsubheading Examples:

@lisp
;;; The function INCR1 always returns the same value, even in different images.
;;; The function INCR2 always returns the same value in a given image,
;;; but the value it returns might vary from image to image.
(defun incr1 (x) (+ x #.(random 17)))
(defun incr2 (x) (+ x (load-time-value (random 17))))

;;; The function FOO1-REF references the nth element of the first of
;;; the *FOO-ARRAYS* that is available at load time.  It is permissible for
;;; that array to be modified (e.g., by SET-FOO1-REF); FOO1-REF will see the
;;; updated values.
(defvar *foo-arrays* (list (make-array 7) (make-array 8)))
(defun foo1-ref (n) (aref (load-time-value (first *my-arrays*) nil) n))
(defun set-foo1-ref (n val)
  (setf (aref (load-time-value (first *my-arrays*) nil) n) val))

;;; The function BAR1-REF references the nth element of the first of
;;; the *BAR-ARRAYS* that is available at load time.  The programmer has
;;; promised that the array will be treated as read-only, so the system
;;; can copy or coalesce the array.
(defvar *bar-arrays* (list (make-array 7) (make-array 8)))
(defun bar1-ref (n) (aref (load-time-value (first *my-arrays*) t) n))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified, because the object was already read-only
;;; when it was written as a literal vector rather than created by a constructor.
;;; User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value #(A B C) nil)))
    (values (svref v n) v)))

;;; This use of LOAD-TIME-VALUE permits the indicated vector to be coalesced
;;; even though NIL was specified in the outer situation because T was specified
;;; in the inner situation.  User programs must treat the vector v as read-only.
(defun baz-ref (n)
  (let ((v (load-time-value (load-time-value (vector 1 2 3) t) nil)))
    (values (svref v n) v)))
@end lisp


@subsubheading See Also:

@ref{compile-file},
@ref{compile},
@ref{eval},
@ref{Minimal Compilation},
@ref{Compilation}

@subsubheading Notes:

@code{load-time-value} must appear outside of quoted structure in a
``for @term{evaluation}'' position.  In situations which would appear to call
for use of @code{load-time-value} within a quoted structure,
the @term{backquote} @term{reader macro} is probably called for;
see @ref{Backquote}.

Specifying @nil{}@spc{}for @param{read-only-p} is not a way to force an object
to become modifiable if it has already been made read-only.  It is only a way
to say that, for an object that is modifiable, this operation is not intended
to make that object read-only.



@node quote
@subsection quote (Special Operator)
@syindex quote
@cindex quote


@subsubheading Syntax:

@DefspecWithValues{quote, object, object}

@subsubheading Arguments and Values:

@param{object}---an @term{object}; @noeval{}.

@subsubheading Description:

@Thespecop{quote} just returns @param{object}.

The consequences are undefined if @term{literal objects} (including
@term{quoted objects}) are destructively modified.

@subsubheading Examples:

@lisp
 (setq a 1) @EV{} 1
 (quote (setq a 3)) @EV{} (SETQ A 3)
 a @EV{} 1
 'a @EV{} A
 ''a @EV{} (QUOTE A)
 '''a @EV{} (QUOTE (QUOTE A))
 (setq a 43) @EV{} 43
 (list a (cons a 3)) @EV{} (43 (43 . 3))
 (list (quote a) (quote (cons a 3))) @EV{} (A (CONS A 3))
 1 @EV{} 1
 '1 @EV{} 1
 "foo" @EV{} "foo"
 '"foo" @EV{} "foo"
 (car '(a b)) @EV{} A
 '(car '(a b)) @EV{} (CAR (QUOTE (A B)))
 #(car '(a b)) @EV{} #(CAR (QUOTE (A B)))
 '#(car '(a b)) @EV{} #(CAR (QUOTE (A B)))
@end lisp


@subsubheading See Also:

@ref{Evaluation},
@ref{Single-Quote},
@ref{Compiler Terminology}

@subsubheading Notes:

The textual notation @f{'@param{object}} is equivalent to @f{(quote @param{object})};
see @ref{Compiler Terminology}.

Some @term{objects}, called @term{self-evaluating objects},
do not require quotation by @code{quote}.
However, @term{symbols} and @term{lists} are used to represent parts of programs,
and so would not be useable as constant data in a program without @code{quote}.
Since @code{quote} suppresses the @term{evaluation} of these @term{objects},
they become data rather than program.


@node compiler-macro-function
@subsection compiler-macro-function (Accessor)
@syindex compiler-macro-function
@cindex compiler-macro-function



@subsubheading Syntax:

@DefunWithValues{compiler-macro-function, name @opt{} environment, function}
@Defsetf{compiler-macro-function, name @opt{} environment, new-function}

@subsubheading Arguments and Values:

@param{name}---a @term{function name}.

@param{environment}---an @term{environment} @term{object}.

@param{function}, @param{new-function}---a @term{compiler macro function}, or @nil{}.

@subsubheading Description:

@term{Accesses} the @term{compiler macro function} named @param{name}, if any,
in the @param{environment}.

A value of @nil{}@spc{}denotes the absence of a @term{compiler macro function} named @param{name}.

@subsubheading Exceptional Situations:

The consequences are undefined if @param{environment} is @term{non-nil}
in a use of @SETFof{compiler-macro-function}.

@subsubheading See Also:

@ref{define-compiler-macro}, @ref{Compiler Macros}



@node define-compiler-macro
@subsection define-compiler-macro (Macro)
@syindex define-compiler-macro
@cindex define-compiler-macro



@subsubheading Syntax:

@DefmacWithValuesNewline{define-compiler-macro, name lambda-list @DeclsAndDoc{} @starparam{form}, name}

@subsubheading Arguments and Values:

@param{name}---a @term{function name}.

@param{lambda-list}---a @term{macro lambda list}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{documentation}---a @term{string}; @noeval{}.

@param{form}---a @term{form}.

@subsubheading Description:

@editornote{KMP: This definition probably needs to be fully expanded to not
refer through the definition of defmacro, but should suffice for now.}

This is the normal mechanism for defining a @term{compiler macro function}.
Its manner of definition is the same as for @code{defmacro}; the only
differences are:


@itemize @bullet{}
@item The @param{name} can be a @term{function name} naming
any @term{function} or @term{macro}.

@item The expander function is installed as a @term{compiler macro function}
for the @param{name}, rather than as a @term{macro function}.

@item The @keyref{whole} argument is bound to the form argument that
is passed to the @term{compiler macro function}.  The remaining lambda-list
parameters are specified as if this form contained the function name in the
@term{car} and the actual arguments in the @term{cdr}, but if the @term{car}
of the actual form is the symbol @code{funcall}, then the destructuring of
the arguments is actually performed using its @term{cddr} instead.

@param{Documentation} is attached as a @term{documentation string}
to @param{name} (as kind @code{compiler-macro})
and to the @term{compiler macro function}.

@item Unlike an ordinary @term{macro}, a @term{compiler macro}
can decline to provide an expansion merely by returning a form that is
the @term{same} as the original (which can be obtained by using
@keyref{whole}).
@end itemize


@subsubheading Examples:

@lisp
 (defun square (x) (expt x 2)) @EV{} SQUARE
 (define-compiler-macro square (&whole form arg)
   (if (atom arg)
       `(expt ,arg 2)
       (case (car arg)
         (square (if (= (length arg) 2)
                     `(expt ,(nth 1 arg) 4)
                     form))
         (expt   (if (= (length arg) 3)
                     (if (numberp (nth 2 arg))
                         `(expt ,(nth 1 arg) ,(* 2 (nth 2 arg)))
                         `(expt ,(nth 1 arg) (* 2 ,(nth 2 arg))))
                     form))
         (otherwise `(expt ,arg 2))))) @EV{} SQUARE
 (square (square 3)) @EV{} 81
 (macroexpand '(square x)) @EV{} (SQUARE X), @term{false}
 (funcall (compiler-macro-function 'square) '(square x) nil)
@EV{} (EXPT X 2)
 (funcall (compiler-macro-function 'square) '(square (square x)) nil)
@EV{} (EXPT X 4)
 (funcall (compiler-macro-function 'square) '(funcall #'square x) nil)
@EV{} (EXPT X 2)

 (defun distance-positional (x1 y1 x2 y2)
   (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2))))
@EV{} DISTANCE-POSITIONAL
 (defun distance (&key (x1 0) (y1 0) (x2 x1) (y2 y1))
   (distance-positional x1 y1 x2 y2))
@EV{} DISTANCE
 (define-compiler-macro distance (&whole form
                                  &rest key-value-pairs
                                  &key (x1 0  x1-p)
                                       (y1 0  y1-p)
                                       (x2 x1 x2-p)
                                       (y2 y1 y2-p)
                                  &allow-other-keys
                                  &environment env)
   (flet ((key (n) (nth (* n 2) key-value-pairs))
          (arg (n) (nth (1+ (* n 2)) key-value-pairs))
          (simplep (x)
            (let ((expanded-x (macroexpand x env)))
              (or (constantp expanded-x env)
                  (symbolp expanded-x)))))
     (let ((n (/ (length key-value-pairs) 2)))
       (multiple-value-bind (x1s y1s x2s y2s others)
           (loop for (key) on key-value-pairs by #'cddr
                 count (eq key ':x1) into x1s
                 count (eq key ':y1) into y1s
                 count (eq key ':x2) into x2s
                 count (eq key ':y1) into y2s
                 count (not (member key '(:x1 :x2 :y1 :y2)))
                   into others
                 finally (return (values x1s y1s x2s y2s others)))
         (cond ((and (= n 4)
                     (eq (key 0) :x1)
                     (eq (key 1) :y1)
                     (eq (key 2) :x2)
                     (eq (key 3) :y2))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (if x1-p (and (= x1s 1) (simplep x1)) t)
                     (if y1-p (and (= y1s 1) (simplep y1)) t)
                     (if x2-p (and (= x2s 1) (simplep x2)) t)
                     (if y2-p (and (= y2s 1) (simplep y2)) t)
                     (zerop others))
                `(distance-positional ,x1 ,y1 ,x2 ,y2))
               ((and (< x1s 2) (< y1s 2) (< x2s 2) (< y2s 2)
                     (zerop others))
                (let ((temps (loop repeat n collect (gensym))))
                  `(let ,(loop for i below n
                               collect (list (nth i temps) (arg i)))
                     (distance
                       ,@@(loop for i below n
                               append (list (key i) (nth i temps)))))))
               (t form))))))
@EV{} DISTANCE
 (dolist (form
           '((distance :x1 (setq x 7) :x2 (decf x) :y1 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (decf x) :x2 (decf x) :y2 (decf x))
             (distance :x1 (setq x 7) :y1 (incf x))
             (distance :x1 (setq x 7) :y1 (incf x) :x1 (incf x))
             (distance :x1 a1 :y1 b1 :x2 a2 :y2 b2)
             (distance :x1 a1 :x2 a2 :y1 b1 :y2 b2)
             (distance :x1 a1 :y1 b1 :z1 c1 :x2 a2 :y2 b2 :z2 c2)))
   (print (funcall (compiler-macro-function 'distance) form nil)))
@OUT{} (LET ((#:G6558 (SETQ X 7))
@OUT{}       (#:G6559 (DECF X))
@OUT{}       (#:G6560 (DECF X))
@OUT{}       (#:G6561 (DECF X)))
@OUT{}   (DISTANCE :X1 #:G6558 :X2 #:G6559 :Y1 #:G6560 :Y2 #:G6561))
@OUT{} (DISTANCE-POSITIONAL (SETQ X 7) (DECF X) (DECF X) (DECF X))
@OUT{} (LET ((#:G6567 (SETQ X 7))
@OUT{}       (#:G6568 (INCF X)))
@OUT{}   (DISTANCE :X1 #:G6567 :Y1 #:G6568))
@OUT{} (DISTANCE :X1 (SETQ X 7) :Y1 (INCF X) :X1 (INCF X))
@OUT{} (DISTANCE-POSITIONAL A1 B1 A2 B2)
@OUT{} (DISTANCE-POSITIONAL A1 B1 A2 B2)
@OUT{} (DISTANCE :X1 A1 :Y1 B1 :Z1 C1 :X2 A2 :Y2 B2 :Z2 C2)
@EV{} NIL
@end lisp


@subsubheading See Also:

@ref{compiler-macro-function},
@ref{defmacro},
@ref{documentation},
@ref{Syntactic Interaction of Documentation Strings and Declarations}

@subsubheading Notes:

The consequences of writing a @term{compiler macro} definition for a function
in the @code{COMMON-LISP} @term{package} are undefined; it is quite possible that in some
@term{implementations} such an attempt would override an equivalent or equally
important definition.  In general, it is recommended that a programmer only
write @term{compiler macro} definitions for @term{functions} he or she personally
maintains--writing a @term{compiler macro} definition for a function maintained
elsewhere is normally considered a violation of traditional rules of modularity
and data abstraction.



@node defmacro
@subsection defmacro (Macro)
@syindex defmacro
@cindex defmacro



@subsubheading Syntax:

@DefmacWithValuesNewline{defmacro, name lambda-list @DeclsAndDoc{} @starparam{form}, name}

@subsubheading Arguments and Values:

@param{name}---a @term{symbol}.

@param{lambda-list}---a @term{macro lambda list}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{documentation}---a @term{string}; @noeval{}.

@param{form}---a @term{form}.

@subsubheading Description:

Defines @param{name} as a @term{macro}
by associating a @term{macro function} with that @param{name}
in the global environment.
The @term{macro function} is defined in the same @term{lexical environment}
in which the @code{defmacro} @term{form} appears.


The parameter variables in @param{lambda-list} are bound to
destructured portions of the macro call.

The expansion function
accepts two arguments, a @term{form} and an
@term{environment}.  The expansion function returns a @term{form}.
The body of the expansion function is specified by @param{forms}.
@param{Forms} are executed in order.  The value of the
last @param{form} executed is returned as the expansion of the
@term{macro}.
The body @param{forms} of the expansion function (but not the @param{lambda-list})
are implicitly enclosed in a @term{block} whose name is @param{name}.

The @param{lambda-list} conforms to the requirements described in @ref{Macro Lambda Lists}.

@param{Documentation} is attached as a @term{documentation string}
to @param{name} (as kind @code{function})
and to the @term{macro function}.

@code{defmacro} can be used to redefine a @term{macro} or to replace
a @term{function} definition with a @term{macro} definition.


Recursive expansion of the @term{form} returned must terminate,
including the expansion of other @term{macros} which are @term{subforms}
of other @term{forms} returned.

The consequences are undefined if the result of fully macroexpanding
a @term{form}
contains any @term{circular} @term{list structure} except in @term{literal objects}.

If a @code{defmacro} @term{form} appears as a @term{top level form},
the @term{compiler} must store the @term{macro} definition at compile time,
so that occurrences of the macro later on in the file can be expanded correctly.
Users must ensure that the body of the @term{macro} can be evaluated at
compile time if it is referenced within the @term{file} being @term{compiled}.

@subsubheading Examples:

@lisp
 (defmacro mac1 (a b) "Mac1 multiplies and adds"
            `(+ ,a (* ,b 3))) @EV{} MAC1
 (mac1 4 5) @EV{} 19
 (documentation 'mac1 'function) @EV{} "Mac1 multiplies and adds"
 (defmacro mac2 (&optional (a 2 b) (c 3 d) &rest x) `'(,a ,b ,c ,d ,x)) @EV{} MAC2
 (mac2 6) @EV{} (6 T 3 NIL NIL)
 (mac2 6 3 8) @EV{} (6 T 3 T (8))
 (defmacro mac3 (&whole r a &optional (b 3) &rest x &key c (d a))
    `'(,r ,a ,b ,c ,d ,x)) @EV{} MAC3
 (mac3 1 6 :d 8 :c 9 :d 10) @EV{} ((MAC3 1 6 :D 8 :C 9 :D 10) 1 6 9 8 (:D 8 :C 9 :D 10))
@end lisp





The stipulation that
an embedded @term{destructuring lambda list} is permitted only
where @term{ordinary lambda list} syntax would permit a parameter name
but not a @term{list} is made to prevent ambiguity.  For example,
the following is not valid:

@lisp
 (defmacro loser (x &optional (a b &rest c) &rest z)
   ...)
@end lisp

because @term{ordinary lambda list} syntax does permit a
@term{list} following @optional{};
the list @f{(a b @ampers{}rest c)} would be interpreted as describing an
optional parameter named @f{a} whose default value is that of the
form @f{b}, with a supplied-p parameter named @keyref{rest} (not valid),
and an extraneous symbol @f{c} in the list (also not valid).  An almost
correct way to express this is

@lisp
 (defmacro loser (x &optional ((a b &rest c)) &rest z)
   ...)
@end lisp

The extra set of parentheses removes the ambiguity.  However, the
definition is now incorrect because a macro call such as @f{(loser (car pool))}
would not provide any argument form for the lambda list @f{(a b @ampers{}rest c)},
and so the default value against which to match the @term{lambda list} would be
@nil{}@spc{}because no explicit default value was specified.
The consequences of this are  unspecified
since the empty list, @nil{}, does not have @term{forms} to satisfy the
parameters @f{a} and @f{b}.  The fully correct definition would be either

@lisp
 (defmacro loser (x &optional ((a b &rest c) '(nil nil)) &rest z)
   ...)
@end lisp

or

@lisp
 (defmacro loser (x &optional ((&optional a b &rest c)) &rest z)
   ...)
@end lisp

These differ slightly: the first requires that if the macro call
specifies @f{a} explicitly then it must also specify @f{b} explicitly,
whereas the second does not have this requirement.  For example,

@lisp
 (loser (car pool) ((+ x 1)))
@end lisp

would be a valid call for the second definition but not for the first.


@lisp
 (defmacro dm1a (&whole x) `',x)
 (macroexpand '(dm1a))  @EV{} (QUOTE (DM1A))
 (macroexpand '(dm1a a)) is an error.

 (defmacro dm1b (&whole x a &optional b) `'(,x ,a ,b))
 (macroexpand '(dm1b))  is an error.
 (macroexpand '(dm1b q))  @EV{} (QUOTE ((DM1B Q) Q NIL))
 (macroexpand '(dm1b q r)) @EV{} (QUOTE ((DM1B Q R) Q R))
 (macroexpand '(dm1b q r s)) is an error.
@end lisp


@lisp
 (defmacro dm2a (&whole form a b) `'(form ,form a ,a b ,b))
 (macroexpand '(dm2a x y)) @EV{} (QUOTE (FORM (DM2A X Y) A X B Y))
 (dm2a x y) @EV{} (FORM (DM2A X Y) A X B Y)

 (defmacro dm2b (&whole form a (&whole b (c . d) &optional (e 5))
                 &body f &environment env)
   ``(,',form ,,a ,',b ,',(macroexpand c env) ,',d ,',e ,',f))
 ;Note that because backquote is involved, implementations may differ
 ;slightly in the nature (though not the functionality) of the expansion.
 (macroexpand '(dm2b x1 (((incf x2) x3 x4)) x5 x6))
 @EV{} (LIST* '(DM2B X1 (((INCF X2) X3 X4))
                   X5 X6)
            X1
            '((((INCF X2) X3 X4)) (SETQ X2 (+ X2 1)) (X3 X4) 5 (X5 X6))),
     T
 (let ((x1 5))
   (macrolet ((segundo (x) `(cadr ,x)))
     (dm2b x1 (((segundo x2) x3 x4)) x5 x6)))
 @EV{} ((DM2B X1 (((SEGUNDO X2) X3 X4)) X5 X6)
      5 (((SEGUNDO X2) X3 X4)) (CADR X2) (X3 X4) 5 (X5 X6))
@end lisp



@subsubheading See Also:

@ref{define-compiler-macro},
@ref{destructuring-bind},
@ref{documentation},
@ref{macroexpand},
@ref{*macroexpand-hook*},
@ref{macrolet},
@ref{macro-function},
@ref{Evaluation},
@ref{Compilation},
@ref{Syntactic Interaction of Documentation Strings and Declarations}



@node macro-function
@subsection macro-function (Accessor)
@syindex macro-function
@cindex macro-function


@subsubheading Syntax:

@DefunWithValues{macro-function, symbol @opt{} environment, function}
@Defsetf{macro-function, symbol @opt{} environment, new-function}

@subsubheading Arguments and Values:

@param{symbol}---a @term{symbol}.

@param{environment}---an @term{environment} @term{object}.

@param{function}---a @term{macro function} or @nil{}.

@param{new-function}---a @term{macro function}.

@subsubheading Description:

Determines whether @param{symbol} has a function definition
as a macro in the specified @param{environment}.

If so, the macro expansion function, a function of two arguments,
is returned.  If @param{symbol} has no function definition
in the lexical environment @param{environment}, or its definition
is not a @term{macro}, @code{macro-function} returns @nil{}.




It is possible for both @code{macro-function} and
@code{special-operator-p}
to return @term{true} of @param{symbol}.  The @term{macro} definition must
be available for use by programs that understand only the standard
@clisp{}@spc{}@term{special forms}.

@subsubheading Examples:
@lisp
 (defmacro macfun (x) '(macro-function 'macfun)) @EV{} MACFUN
 (not (macro-function 'macfun)) @EV{} @term{false}
@end lisp

@lisp
 (macrolet ((foo (&environment env)
               (if (macro-function 'bar env)
                  ''yes
                  ''no)))
    (list (foo)
          (macrolet ((bar () :beep))
             (foo))))

@EV{} (NO YES)
@end lisp


@subsubheading Affected By:
@f{(setf macro-function)}, @code{defmacro}, and @code{macrolet}.

@subsubheading Exceptional Situations:

The consequences are undefined if @param{environment} is @term{non-nil}
in a use of @SETFof{macro-function}.

@subsubheading See Also:

@ref{Evaluation}

@subsubheading Notes:

@code{setf} can be used with @code{macro-function} to install
a @term{macro} as a symbol's global function definition:

@lisp
 (setf (macro-function symbol) fn)
@end lisp

The value installed must be a @term{function} that accepts two arguments,
the entire macro call and an @term{environment},
and computes the expansion for that call.
Performing this operation causes @param{symbol} to have only that
macro definition as its global function definition; any previous
definition, whether as a @term{macro} or as a
@term{function}, is lost.


@node macroexpand; macroexpand-1
@subsection macroexpand, macroexpand-1 (Function)
@syindex macroexpand
@cindex macroexpand
@syindex macroexpand-1
@cindex macroexpand-1
@anchor{macroexpand}
@anchor{macroexpand-1}


@subsubheading Syntax:

@DefunWithValues{macroexpand, form @opt{} env, expansion\, expanded-p}
@DefunWithValues{macroexpand-1, form @opt{} env, expansion\, expanded-p}

@subsubheading Arguments and Values:

@param{form}---a @term{form}.

@param{env}---an @term{environment} @term{object}.
@Default{@nil{}}

@param{expansion}---a @term{form}.

@param{expanded-p}---a @term{generalized boolean}.

@subsubheading Description:

@code{macroexpand} and @code{macroexpand-1} expand @term{macros}.

If @param{form} is a @term{macro form},
then @code{macroexpand-1} expands the @term{macro form} call once.

@code{macroexpand}
repeatedly expands @param{form} until it is no longer a @term{macro form}.
In effect, @code{macroexpand} calls @code{macroexpand-1} repeatedly
until the @term{secondary value} it returns is @nil{}.

If @param{form} is a @term{macro form},
then the @param{expansion} is a @term{macro expansion}
and @param{expanded-p} is @term{true}.
Otherwise,
the @param{expansion} is the given @param{form}
and @param{expanded-p} is @term{false}.

Macro expansion is carried out as follows.
Once @code{macroexpand-1} has
determined that the @param{form} is a @term{macro form},
it obtains an appropriate expansion @term{function} for the
@term{macro} or @term{symbol macro}.
The value of
@code{*macroexpand-hook*} is
coerced to a @term{function} and
then called as a @term{function} of three arguments:
the expansion @term{function},
the @param{form},
and the @param{env}.
The @term{value} returned from this call is taken to be the expansion
of the @param{form}.

In addition to @term{macro} definitions in the global environment,
any local macro definitions established within @param{env} by @code{macrolet}
or @code{symbol-macrolet} are considered.
If only @param{form} is supplied as an argument,
then the environment is effectively null, and only global macro definitions
as established by @code{defmacro} are considered.
@term{Macro} definitions are shadowed by local @term{function} definitions.

@subsubheading Examples:

@lisp
 (defmacro alpha (x y) `(beta ,x ,y)) @EV{} ALPHA
 (defmacro beta (x y) `(gamma ,x ,y)) @EV{} BETA
 (defmacro delta (x y) `(gamma ,x ,y)) @EV{} EPSILON
 (defmacro expand (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand form env)
     `(values ',expansion ',expanded-p))) @EV{} EXPAND
 (defmacro expand-1 (form &environment env)
   (multiple-value-bind (expansion expanded-p)
       (macroexpand-1 form env)
     `(values ',expansion ',expanded-p))) @EV{} EXPAND-1
@medbreak{}
;; Simple examples involving just the global environment
 (macroexpand-1 '(alpha a b)) @EV{} (BETA A B), @term{true}
 (expand-1 (alpha a b)) @EV{} (BETA A B), @term{true}
 (macroexpand '(alpha a b)) @EV{} (GAMMA A B), @term{true}
 (expand (alpha a b)) @EV{} (GAMMA A B), @term{true}
 (macroexpand-1 'not-a-macro) @EV{} NOT-A-MACRO, @term{false}
 (expand-1 not-a-macro) @EV{} NOT-A-MACRO, @term{false}
 (macroexpand '(not-a-macro a b)) @EV{} (NOT-A-MACRO A B), @term{false}
 (expand (not-a-macro a b)) @EV{} (NOT-A-MACRO A B), @term{false}
@medbreak{}
;; Examples involving lexical environments
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand-1 '(alpha a b))) @EV{} (BETA A B), @term{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand-1 (alpha a b))) @EV{} (DELTA A B), @term{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (macroexpand '(alpha a b))) @EV{} (GAMMA A B), @term{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (expand (alpha a b))) @EV{} (GAMMA A B), @term{true}
 (macrolet ((beta (x y) `(epsilon ,x ,y)))
   (expand (alpha a b))) @EV{} (EPSILON A B), @term{true}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (expand a))) @EV{} (FIRST X), @term{true}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (macroexpand 'a))) @EV{} A, @term{false}
 (symbol-macrolet ((b (alpha x y)))
   (expand-1 b)) @EV{} (ALPHA X Y), @term{true}
 (symbol-macrolet ((b (alpha x y)))
   (expand b)) @EV{} (GAMMA X Y), @term{true}
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand-1 a)) @EV{} B, @term{true}
 (symbol-macrolet ((b (alpha x y))
                   (a b))
   (expand a)) @EV{} (GAMMA X Y), @term{true}
@medbreak{}
;; Examples of shadowing behavior
 (flet ((beta (x y) (+ x y)))
   (expand (alpha a b))) @EV{} (BETA A B), @term{true}
 (macrolet ((alpha (x y) `(delta ,x ,y)))
   (flet ((alpha (x y) (+ x y)))
     (expand (alpha a b)))) @EV{} (ALPHA A B), @term{false}
 (let ((x (list 1 2 3)))
   (symbol-macrolet ((a (first x)))
     (let ((a x))
       (expand a)))) @EV{} A, @term{false}
@end lisp


@subsubheading Affected By:

@code{defmacro},
@code{setf} of @code{macro-function},
@code{macrolet},
@code{symbol-macrolet}

@subsubheading See Also:

@ref{*macroexpand-hook*},
@ref{defmacro},
@ref{setf} of @ref{macro-function},
@ref{macrolet},
@ref{symbol-macrolet},
@ref{Evaluation}

@subsubheading Notes:

Neither @code{macroexpand} nor @code{macroexpand-1}
makes any explicit attempt to expand @term{macro forms} that are
either @term{subforms} of the @param{form}
or @term{subforms} of the @param{expansion}.
Such expansion might occur implicitly, however,
due to the semantics or implementation of the @term{macro function}.


@node define-symbol-macro
@subsection define-symbol-macro (Macro)
@syindex define-symbol-macro
@cindex define-symbol-macro


@subsubheading Syntax:

@DefmacWithValuesNewline{define-symbol-macro, symbol expansion, symbol}

@subsubheading Arguments and Values:

@param{symbol}---a @term{symbol}.

@param{expansion}---a @term{form}.

@subsubheading Description:

Provides a mechanism for globally affecting the @term{macro expansion}
of the indicated @param{symbol}.

Globally establishes an expansion function for the @term{symbol macro}
named by @param{symbol}.
The only guaranteed property of an expansion @term{function} for a @term{symbol macro}
is that when it is applied to the @term{form} and the @term{environment} it returns
the correct expansion.  (In particular, it is @term{implementation-dependent}
whether the expansion is conceptually stored in the expansion function,
the @term{environment}, or both.)

Each global reference to @param{symbol} (@ie{} not @term{shadowed}@sub{2} by a
@term{binding} for a @term{variable} or @term{symbol macro} named by
the same @term{symbol}) is expanded by the normal macro expansion process;
see @ref{Symbols as Forms}.
The expansion of a @term{symbol macro} is subject to further @term{macro expansion}
in the same @term{lexical environment} as the @term{symbol macro} reference,
exactly analogous to normal @term{macros}.

The consequences are unspecified if a @code{special} declaration is made for
@param{symbol} while in the scope of this definition (@ie{} when it is not
@term{shadowed}@sub{2} by a @term{binding} for a @term{variable}
or @term{symbol macro} named by the same @term{symbol}).

Any use of @code{setq} to set the value of
the @param{symbol}
while in the scope of this definition
is treated as if it were a @code{setf}.
@code{psetq} of @param{symbol}
is treated as if it were a @code{psetf}, and
@code{multiple-value-setq}
is treated as if it were a @code{setf} of @code{values}.

A @term{binding} for a @term{symbol macro} can be @term{shadowed}@sub{2}
by @code{let} or @code{symbol-macrolet}.

@subsubheading Examples:

@lisp
(defvar *things* (list 'alpha 'beta 'gamma)) @EV{} *THINGS*

(define-symbol-macro thing1 (first *things*)) @EV{} THING1
(define-symbol-macro thing2 (second *things*)) @EV{} THING2
(define-symbol-macro thing3 (third *things*)) @EV{} THING3

thing1 @EV{} ALPHA
(setq thing1 'ONE) @EV{} ONE
*things* @EV{} (ONE BETA GAMMA)
(multiple-value-setq (thing2 thing3) (values 'two 'three)) @EV{} TWO
thing3 @EV{} THREE
*things* @EV{} (ONE TWO THREE)

(list thing2 (let ((thing2 2)) thing2)) @EV{} (TWO 2)
@end lisp


@subsubheading Exceptional Situations:

If @param{symbol} is already defined as a @term{global variable},
an error @oftype{program-error} is signaled.

@subsubheading See Also:

@ref{symbol-macrolet},
@ref{macroexpand}


@node symbol-macrolet
@subsection symbol-macrolet (Special Operator)
@syindex symbol-macrolet
@cindex symbol-macrolet



@subsubheading Syntax:

@DefspecWithValuesNewline{symbol-macrolet, @paren{@starparen{symbol expansion}} @starparam{declaration}  @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{symbol}---a @term{symbol}.

@param{expansion}---a @term{form}.

@param{declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{forms}---an @term{implicit progn}.

@param{results}---the @term{values} returned by the @param{forms}.

@subsubheading Description:


@code{symbol-macrolet} provides a mechanism for
affecting the @term{macro expansion} environment for @term{symbols}.

@code{symbol-macrolet} lexically establishes expansion functions
for each of the @term{symbol macros} named by @param{symbols}.
The only guaranteed property of an expansion @term{function} for a @term{symbol macro}
is that when it is applied to the @term{form} and the @term{environment} it returns
the correct expansion.  (In particular, it is @term{implementation-dependent}
whether the expansion is conceptually stored in the expansion function,
the @term{environment}, or both.)

Each reference to @param{symbol} as a variable within the lexical @term{scope}
of @code{symbol-macrolet} is expanded by the normal macro expansion process;
see @ref{Symbols as Forms}.
The expansion of a symbol macro is subject to further macro expansion
in the same lexical environment as the symbol macro invocation, exactly
analogous to normal @term{macros}.

Exactly the same @param{declarations} are allowed as for @code{let}
with one exception: @code{symbol-macrolet} signals an error
if a @code{special} declaration names one of the @term{symbols}
being defined by @code{symbol-macrolet}.

When the @param{forms} of the @code{symbol-macrolet} form are expanded,
any use of @code{setq} to set the value of one of the specified variables
is treated as if it were a @code{setf}.
@code{psetq} of a @term{symbol} defined as a symbol macro
is treated as if it were a @code{psetf}, and
@code{multiple-value-setq}
is treated as if it were a @code{setf} of @code{values}.

The use of @code{symbol-macrolet} can be shadowed by @code{let}.
In other words, @code{symbol-macrolet} only substitutes for occurrences
of @param{symbol} that would be in the @term{scope} of a lexical binding of
@param{symbol} surrounding the @param{forms}.

@subsubheading Examples:

@lisp
;;; The following is equivalent to
;;;   (list 'foo (let ((x 'bar)) x)),
;;; not
;;;   (list 'foo (let (('foo 'bar)) 'foo))
 (symbol-macrolet ((x 'foo))
   (list x (let ((x 'bar)) x)))
@EV{} (foo bar)
@NV{} (foo foo)

 (symbol-macrolet ((x '(foo x)))
   (list x))
@EV{} ((FOO X))
@end lisp


@subsubheading Exceptional Situations:
If an attempt is made to bind a @term{symbol} that is defined as a @term{global variable},
an error @oftype{program-error} is signaled.

If @param{declaration} contains a @code{special} declaration
that names one of the @term{symbols} being bound by @code{symbol-macrolet},
an error @oftype{program-error} is signaled.

@subsubheading See Also:

@ref{with-slots}, @ref{macroexpand}

@subsubheading Notes:

The special form @code{symbol-macrolet} is the basic mechanism that is used to
implement @code{with-slots}.

If a @code{symbol-macrolet} @term{form} is a @term{top level form},
the @param{forms} are also processed as @term{top level forms}.
See @ref{File Compilation}.



@node *macroexpand-hook*
@subsection *macroexpand-hook* (Variable)
@syindex *macroexpand-hook*
@cindex *macroexpand-hook*



@subsubheading Value Type:

a @term{designator} for a @term{function} of three @term{arguments}:
a @term{macro function},
a @term{macro form},
and an @term{environment} @term{object}.

@subsubheading Initial Value:

a @term{designator} for a function that is equivalent to @thefunction{funcall},
but that might have additional @term{implementation-dependent} side-effects.

@subsubheading Description:

Used as the expansion interface hook by @code{macroexpand-1} to
control the @term{macro expansion} process.
When a @term{macro form} is to be expanded,
this @term{function} is called with three arguments:
the @term{macro function},
the @term{macro form},
and the @term{environment} in which the @term{macro form} is to be expanded.
The @term{environment} @term{object} has @term{dynamic extent};
the consequences are undefined if the @term{environment} @term{object} is
referred to outside the @term{dynamic extent} of the macro expansion function.

@subsubheading Examples:

@lisp
 (defun hook (expander form env)
    (format t "Now expanding: ~S~%" form)
    (funcall expander form env)) @EV{} HOOK
 (defmacro machook (x y) `(/ (+ ,x ,y) 2)) @EV{} MACHOOK
 (macroexpand '(machook 1 2)) @EV{} (/ (+ 1 2) 2), @term{true}
 (let ((*macroexpand-hook* #'hook)) (macroexpand '(machook 1 2)))
@OUT{} Now expanding (MACHOOK 1 2)
@EV{} (/ (+ 1 2) 2), @term{true}
@end lisp


@subsubheading See Also:

@ref{macroexpand}, @ref{Evaluation}

@subsubheading Notes:

The net effect of the chosen initial value is to just invoke the
@term{macro function}, giving it the @term{macro form} and
@term{environment} as its two arguments.

Users or user programs can @term{assign} this @term{variable} to
customize or trace the @term{macro expansion} mechanism.  Note, however,
that this @term{variable} is a global resource, potentially shared by
multiple @term{programs}; as such, if any two @term{programs} depend for
their correctness on the setting of this @term{variable}, those
@term{programs} may not be able to run in the same @term{Lisp image}.
For this reason, it is frequently best to confine its uses to debugging
situations.

Users who put their own function into @code{*macroexpand-hook*}
should consider saving the previous value of the hook, and calling that
value from their own.



@node proclaim
@subsection proclaim (Function)
@syindex proclaim
@cindex proclaim


@subsubheading Syntax:

@DefunWithValues{proclaim, declaration-specifier, @term{implementation-dependent}}

@subsubheading Arguments and Values:

@param{declaration-specifier}---a @term{declaration specifier}.

@subsubheading Description:

@term{Establishes} the @term{declaration} specified by @param{declaration-specifier}
in the @term{global environment}.

Such a @term{declaration}, sometimes called a @term{global declaration}
or a @term{proclamation}, is always in force unless locally @term{shadowed}.

@term{Names} of @term{variables} and @term{functions} within
@param{declaration-specifier} refer to @term{dynamic variables}
and global @term{function} definitions, respectively.

@Thenextfigure{}@spc{}shows a list of @param{declaration identifiers}
that can be used with @code{proclaim}.


@float Figure,fig3.22
@cartouche
@multitable{declaration}{notinline}{optimize}{type}

@item declaration @tab inline @tab optimize @tab type
@item ftype @tab notinline @tab special @tab
@end multitable
@end cartouche
@caption{Global Declaration Specifiers}
@end float


An implementation is free to support other (@term{implementation-defined})
@term{declaration identifiers} as well.

@subsubheading Examples:

@lisp
 (defun declare-variable-types-globally (type vars)
   (proclaim `(type ,type ,@@vars))
   type)

 ;; Once this form is executed, the dynamic variable *TOLERANCE*
 ;; must always contain a float.
 (declare-variable-types-globally 'float '(*tolerance*))
@EV{} FLOAT
@end lisp


@subsubheading See Also:

@ref{declaim},
@ref{declare},
@ref{Compilation}

@subsubheading Notes:

Although the @term{execution} of a @code{proclaim} @term{form}
has effects that might affect compilation, the compiler does not make
any attempt to recognize and specially process @code{proclaim} @term{forms}.
A @term{proclamation} such as the following, even if a @term{top level form},
does not have any effect until it is executed:

@lisp
(proclaim '(special *x*))
@end lisp


If compile time side effects are desired, @code{eval-when} may be useful.
For example:

@lisp
 (eval-when (:execute :compile-toplevel :load-toplevel)
   (proclaim '(special *x*)))
@end lisp


In most such cases, however, it is preferrable to use @code{declaim} for
this purpose.

Since @code{proclaim} @term{forms} are ordinary @term{function forms},
@term{macro forms} can expand into them.


@node declaim
@subsection declaim (Macro)
@syindex declaim
@cindex declaim



@subsubheading Syntax:

@DefmacWithValues{declaim, @starparam{declaration-specifier}, @term{implementation-dependent}}

@subsubheading Arguments and Values:

@param{declaration-specifier}---a @term{declaration specifier}; @noeval{}.

@subsubheading Description:

Establishes the @term{declarations} specified by the @param{declaration-specifiers}.

If a use of this macro appears as a @term{top level form} in a @term{file}
being processed by the @term{file compiler}, the proclamations are also made
at compile-time.  As with other defining macros, it is unspecified whether or
not the compile-time side-effects of a @code{declaim} persist after the
@term{file} has been @term{compiled}.

@subsubheading Examples:

@subsubheading See Also:

@ref{declare},
@ref{proclaim}



@node declare
@subsection declare (Symbol)
@syindex declare
@cindex declare


@subsubheading Syntax:

@Defspec{declare, @starparam{declaration-specifier}}

@subsubheading Arguments:

@param{declaration-specifier}---a @term{declaration specifier}; @noeval{}.

@subsubheading Description:

A @t{declare} @term{expression}, sometimes called a @term{declaration},
can occur only at the beginning of the bodies of certain @term{forms};
that is, it may be preceded only by other @t{declare} @term{expressions},
or by a @term{documentation string} if the context permits.

A @t{declare} @term{expression} can occur in a @term{lambda expression}
or in any of the @term{forms} listed in @thenextfigure{}.


@float Figure,fig3.23
@cartouche
@multitable{define-method-combination}{pprint-logical-block}{with-hash-table-iterator}

@item defgeneric @tab do-external-symbols @tab prog
@item define-compiler-macro @tab do-symbols @tab prog*
@item define-method-combination @tab dolist @tab restart-case
@item define-setf-expander @tab dotimes @tab symbol-macrolet
@item defmacro @tab flet @tab with-accessors
@item defmethod @tab handler-case @tab with-hash-table-iterator
@item defsetf @tab labels @tab with-input-from-string
@item deftype @tab let @tab with-open-file
@item defun @tab let* @tab with-open-stream
@item destructuring-bind @tab locally @tab with-output-to-string
@item do @tab macrolet @tab with-package-iterator
@item do* @tab multiple-value-bind @tab with-slots
@item do-all-symbols @tab pprint-logical-block @tab
@end multitable
@end cartouche
@caption{Standardized Forms In Which Declarations Can Occur}
@end float


A @t{declare} @term{expression} can only occur
where specified by the syntax of these @term{forms}.
The consequences of attempting to evaluate a @t{declare} @term{expression}
are undefined.  In situations where such @term{expressions} can appear,
explicit checks are made for their presence and they are never actually evaluated;
it is for this reason that they
are called  ``@t{declare} @term{expressions}''
rather than ``@t{declare} @term{forms}.''

@term{Macro forms} cannot expand into declarations;
@t{declare} @term{expressions} must appear as actual @term{subexpressions} of
the @term{form} to which they refer.

@Thenextfigure{}@spc{}shows a list of @term{declaration identifiers}
that can be used with @t{declare}.


@float Figure,fig3.24
@cartouche
@multitable{dynamic-extent}{notinline}{optimize}

@item dynamic-extent @tab ignore @tab optimize
@item ftype @tab inline @tab special
@item ignorable @tab notinline @tab type
@end multitable
@end cartouche
@caption{Local Declaration Specifiers}
@end float


An implementation is free to support other (@term{implementation-defined})
@term{declaration identifiers} as well.

@subsubheading Examples:

@lisp
 (defun nonsense (k x z)
   (foo z x)                     ;First call to foo
   (let ((j (foo k x))           ;Second call to foo
         (x (* k k)))
     (declare (inline foo) (special x z))
     (foo x j z)))               ;Third call to foo
@end lisp


In this example,
the @code{inline} declaration applies
only to the third call to @f{foo}, but not to the first or second ones.
The @code{special} declaration of @f{x} causes @code{let}
to make a dynamic @term{binding} for @f{x}, and causes the reference to
@f{x}
in the body of @code{let} to be a dynamic reference.
The reference to @f{x} in the second call to @f{foo} is a local reference
to the second parameter of @tt{nonsense}.
The reference to @f{x} in the first call to @f{foo} is a local
reference, not a @code{special} one.  The @code{special} declaration of @f{z}
causes the reference to @f{z} in the
third
call
to @f{foo} to be a dynamic reference; it does not
refer to the parameter to @f{nonsense} named @f{z}, because that
parameter @term{binding} has not been declared to be @code{special}.
(The @code{special} declaration of @f{z} does not appear in the body
of @code{defun},  but in an inner @term{form}, and therefore does not
affect the @term{binding} of the @term{parameter}.)

@subsubheading Exceptional Situations:

The consequences  of trying to use a @t{declare} @term{expression} as
a @term{form} to be @term{evaluated} are undefined.

@editornote{KMP: Probably we need to say something here about ill-formed
declare expressions.}

@subsubheading See Also:

@ref{proclaim},
@ref{Type Specifiers},
@ref{declaration},
@ref{dynamic-extent},
@ref{ftype},
@ref{ignorable},
@ref{ignore},
@ref{inline},
@ref{notinline},
@ref{optimize},
@ref{type}


@node ignore; ignorable
@subsection ignore, ignorable (Declaration)
@syindex ignore
@cindex ignore
@syindex ignorable
@cindex ignorable
@anchor{ignore}
@anchor{ignorable}



@subsubheading Syntax:

@f{@paren{ignore @star{@curly{@param{var} | @paren{@t{function} @param{fn}}}}}}

@f{@paren{ignorable @star{@curly{@param{var} | @paren{@t{function} @param{fn}}}}}}

@subsubheading Arguments:

@param{var}---a @term{variable} @term{name}.

@param{fn}---a @term{function} @term{name}.

@subsubheading Valid Context:

@term{declaration}

@subsubheading Binding Types Affected:

@term{variable}, @term{function}

@subsubheading Description:

The @code{ignore} and @code{ignorable} declarations
refer to @term{for-value} @term{references}
to @term{variable} @term{bindings} for the @param{vars}
and to @term{function} @term{bindings} for the @param{fns}.

An @code{ignore} @term{declaration} specifies that
@term{for-value} @term{references} to the indicated @term{bindings}
will not
occur within the scope of the @term{declaration}.
Within the @term{scope} of such a @term{declaration},
it is desirable
for a compiler to issue a warning about
the presence of
either a @term{for-value} @term{reference} to any @param{var} or @param{fn},
or a @code{special} @term{declaration} for any @param{var}.

An @code{ignorable} @term{declaration} specifies that
@term{for-value} @term{references} to the indicated @term{bindings}
might or might not
occur within the scope of the @term{declaration}.
Within the @term{scope} of such a @term{declaration},
it is not desirable
for a compiler to issue a warning about
the presence or absence of
either a @term{for-value} @term{reference} to any @param{var} or @param{fn},
or a @code{special} @term{declaration} for any @param{var}.

When not within the @term{scope}
of a @code{ignore} or @code{ignorable} @term{declaration},
it is desirable
for a compiler to issue a warning about
any @param{var} for which there is
neither a @term{for-value} @term{reference}
nor a @code{special} @term{declaration},
or about
any @param{fn} for which there is
no @term{for-value} @term{reference}.

Any warning about a ``used'' or ``unused'' @term{binding} must be @oftype{style-warning},
and may not affect program semantics.


The @term{stream variables} established by
@code{with-open-file},
@code{with-open-stream},
@code{with-input-from-string},
and @code{with-output-to-string},
and all @term{iteration variables} are, by definition, always ``used''.
Using @f{(declare (ignore @param{v}))},
for such a @term{variable} @param{v} has unspecified consequences.



@subsubheading See Also:

@ref{declare}


@node dynamic-extent
@subsection dynamic-extent (Declaration)
@syindex dynamic-extent
@cindex dynamic-extent


@subsubheading Syntax:

@f{(dynamic-extent @interleave{@starparam{var} |
@star{@paren{@t{function} @param{fn}}}})}

@subsubheading Arguments:

@param{var}---a @term{variable} @term{name}.

@param{fn}---a @term{function} @term{name}.

@subsubheading Valid Context:

@term{declaration}

@subsubheading Binding Types Affected:

@term{variable}, @term{function}

@subsubheading Description:


In some containing @term{form}, @param{F}, this declaration
asserts for each @param{var@mat{@subs1{i}}} (which need not be bound by @param{F}),
and for each @term{value} @param{v@mat{@subs{ij}}} that @param{var@mat{@subs1{i}}} takes on,
and for each @term{object} @param{x@mat{@subs{ijk}}} that
is
an @term{otherwise inaccessible part} of @param{v@mat{@subs{ij}}} at any time when
@param{v@mat{@subs{ij}}}
becomes the value of @param{var@mat{@subs1{i}}},
that just after the execution of @param{F} terminates,
@param{x@mat{@subs{ijk}}} is either @term{inaccessible}
(if @param{F} established a @term{binding} for @param{var@mat{@subs1{i}}})
or still an @term{otherwise inaccessible part} of the current value of
@param{var@mat{@subs1{i}}} (if @param{F} did not establish a @term{binding}
for @param{var@mat{@subs1{i}}}).
The same relation holds for each @param{fn@mat{@subs1{i}}},
except that the @term{bindings} are in the @term{function} @term{namespace}.

The compiler is permitted to use
this information in any way that is appropriate to the @term{implementation}
and that does not conflict with the semantics of @clisp{}.

@code{dynamic-extent} declarations can be @term{free declarations}
or @term{bound declarations}.

The @param{vars} and @param{fns} named in a @code{dynamic-extent}
declaration must not refer to @term{symbol macro} or @term{macro} bindings.

@subsubheading Examples:

Since stack allocation of the initial value entails knowing at the
@term{object}'s creation time that the @term{object} can be
@term{stack-allocated},  it is not generally useful to make a
@code{dynamic-extent} @term{declaration} for @term{variables}
which have no lexically apparent initial value.
For example, it is probably useful to write:

@lisp
 (defun f ()
   (let ((x (list 1 2 3)))
     (declare (dynamic-extent x))
         ...))
@end lisp


This would permit those compilers that wish to do so to @term{stack allocate}
the list held by the local variable @tt{x}.  It is permissible,
but in practice probably not as useful, to write:

@lisp
 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))
@end lisp


Most compilers would probably not @term{stack allocate} the @term{argument}
to @tt{g} in @tt{f} because it would be a modularity violation for the compiler
to assume facts about @tt{g} from within @tt{f}.   Only an implementation that
was willing to be responsible for recompiling @tt{f} if the definition of @tt{g}
changed incompatibly could legitimately @term{stack allocate} the @term{list}
argument to @tt{g} in @tt{f}.

Here is another example:

@lisp
 (declaim (inline g))
 (defun g (x) (declare (dynamic-extent x)) ...)
 (defun f () (g (list 1 2 3)))

 (defun f ()
   (flet ((g (x) (declare (dynamic-extent x)) ...))
     (g (list 1 2 3))))

@end lisp

In the previous example, some compilers might determine that optimization was
possible and others might not.

A variant of this is the so-called ``stack allocated rest list''
that can be achieved (in implementations supporting the optimization) by:

@lisp
 (defun f (&rest x)
   (declare (dynamic-extent x))
   ...)
@end lisp


Note that although the initial value of @tt{x} is not explicit, the @tt{f}
function is responsible for assembling the list @tt{x} from the passed arguments,
so the @tt{f} function can be optimized by the compiler to construct a
@term{stack-allocated} list instead of a heap-allocated list in implementations
that support such.

In the following example,

@lisp
 (let ((x (list 'a1 'b1 'c1))
       (y (cons 'a2 (cons 'b2 (cons 'c2 nil)))))
   (declare (dynamic-extent x y))
   ...)
@end lisp

The @term{otherwise inaccessible parts} of @tt{x} are three
@term{conses},  and the @term{otherwise inaccessible parts}
of @tt{y} are three other @term{conses}.
None of the symbols @tt{a1},  @tt{b1},  @tt{c1},  @tt{a2},
@tt{b2},  @tt{c2},  or @nil{}@spc{}is an
@term{otherwise inaccessible part} of @tt{x} or @tt{y} because each
is @term{interned} and hence @term{accessible} by the @term{package}
(or @term{packages}) in which it is @term{interned}.
However, if a freshly allocated @term{uninterned} @term{symbol} had
been used, it would have been an @term{otherwise inaccessible part} of
the @term{list} which contained it.

@lisp
;; In this example, the implementation is permitted to @term{stack allocate}
;; the list that is bound to X.
 (let ((x (list 1 2 3)))
   (declare (dynamic-extent x))
   (print x)
   :done)
@OUT{} (1 2 3)
@EV{} :DONE

;; In this example, the list to be bound to L can be @term{stack-allocated}.
 (defun zap (x y z)
   (do ((l (list x y z) (cdr l)))
       ((null l))
     (declare (dynamic-extent l))
     (prin1 (car l)))) @EV{} ZAP
 (zap 1 2 3)
@OUT{} 123
@EV{} NIL

;; Some implementations might open-code LIST-ALL-PACKAGES in a way
;; that permits using @term{stack allocation} of the list to be bound to L.
 (do ((l (list-all-packages) (cdr l)))
     ((null l))
   (declare (dynamic-extent l))
   (let ((name (package-name (car l))))
     (when (string-search "COMMON-LISP" name) (print name))))
@OUT{} "COMMON-LISP"
@OUT{} "COMMON-LISP-USER"
@EV{} NIL

;; Some implementations might have the ability to @term{stack allocate}
;; rest lists.  A declaration such as the following should be a cue
;; to such implementations that stack-allocation of the rest list
;; would be desirable.
 (defun add (&rest x)
   (declare (dynamic-extent x))
   (apply #'+ x)) @EV{} ADD
 (add 1 2 3) @EV{} 6

 (defun zap (n m)
   ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).
   ;; It may be slow, but with a good compiler at least it
   ;; doesn't waste much heap storage.  :-@rcurly{}
   (let ((a (make-array n)))
     (declare (dynamic-extent a))
     (dotimes (i n)
       (declare (dynamic-extent i))
       (setf (aref a i) (random (+ i 1))))
     (aref a m))) @EV{} ZAP
 (< (zap 5 3) 3) @EV{} @term{true}
@end lisp


The following are in error, since the value of @tt{x} is used outside of its
@term{extent}:

@lisp
 (length (list (let ((x (list 1 2 3)))  ; Invalid
                (declare (dynamic-extent x))
                x)))

 (progn (let ((x (list 1 2 3)))  ; Invalid
          (declare (dynamic-extent x))
          x)
        nil)
@end lisp


@subsubheading See Also:

@ref{declare}

@subsubheading Notes:

The most common optimization is to @term{stack allocate} the
initial value of the @term{objects} named by the @param{vars}.

It is permissible for an implementation to simply ignore this declaration.


@node type
@subsection type (Declaration)
@syindex type
@cindex type


@subsubheading Syntax:

@f{(type @param{typespec} @starparam{var})}

@f{(@param{typespec} @starparam{var})}

@subsubheading Arguments:

@param{typespec}---a @term{type specifier}.

@param{var}---a @term{variable} @term{name}.

@subsubheading Valid Context:

@term{declaration} or @term{proclamation}

@subsubheading Binding Types Affected:

@term{variable}

@subsubheading Description:

Affects
only variable @term{bindings} and specifies that the
@param{vars} take on
values only of the specified @param{typespec}.
In particular, values assigned to the variables by @code{setq},
as well as the initial values of the @param{vars} must be of
the specified @param{typespec}.
@code{type} declarations never apply to function @term{bindings} (see @code{ftype}).

A type declaration of a @term{symbol}
defined by @code{symbol-macrolet} is equivalent
to wrapping a @code{the}
expression around the expansion of that @term{symbol},
although the @term{symbol}'s @term{macro expansion} is not actually affected.


The meaning of a type declaration
is equivalent to changing each reference to
a variable (@param{var}) within the scope of the
declaration to @tt{(the @param{typespec} @param{var})},
changing each expression assigned to the
variable (@param{new-value}) within the scope of the declaration to
@tt{(the @param{typespec} @param{new-value})},
and executing
@tt{(the @param{typespec} @param{var})} at the moment the scope of the declaration
is entered.

A @term{type} declaration is valid in all declarations. The interpretation
of a type declaration is as follows:

@enumerate 1
@item During the execution of any reference to the
declared variable within the scope of the declaration, the consequences
are
undefined
if
the value of the declared variable is not of the declared @term{type}.

@item During the execution of any
@code{setq} of the declared variable within the scope
of the declaration, the consequences are
undefined
if the newly assigned value of the
declared variable is not of the declared @term{type}.

@item At the moment the
scope of the declaration is entered, the consequences are
undefined
if the value of the
declared variable is not of the declared @term{type}.
@end enumerate


A @term{type} declaration affects only variable references within
its scope.

If nested @term{type} declarations refer to the same variable,
then the value of the variable must be a member of the intersection of
the declared @term{types}.

If there is a local @tt{type} declaration for a dynamic
variable, and there is also a global @tt{type} proclamation for that same
variable, then the value of the variable within the scope of the local
declaration must be a member of the intersection of the two declared
@term{types}.

@code{type} declarations can  be @term{free declarations}
or @term{bound declarations}.

A @term{symbol} cannot be both the name of a @term{type} and the name of a
declaration.  Defining a @term{symbol} as the @term{name} of a @term{class},
@term{structure}, @term{condition}, or @term{type}, when the @term{symbol}
has been @term{declared} as a declaration name, or vice versa, signals an error.

Within the @term{lexical scope} of an @code{array} type declaration,
all references to @term{array} @term{elements} are assumed to satisfy the
@term{expressed array element type} (as opposed to the @term{upgraded array element type}).
A compiler can treat
the code within the scope of the @code{array} type declaration as if each
@term{access} of an @term{array} @term{element} were surrounded by an appropriate
@code{the} form.

@subsubheading Examples:

@lisp
 (defun f (x y)
   (declare (type fixnum x y))
   (let ((z (+ x y)))
     (declare (type fixnum z))
     z)) @EV{} F
 (f 1 2) @EV{} 3
 ;; The previous definition of F is equivalent to
 (defun f (x y)
   ;; This declaration is a shorthand form of the TYPE declaration
   (declare (fixnum x y))
   ;; To declare the type of a return value, it's not necessary to
   ;; create a named variable.  A THE special form can be used instead.
   (the fixnum (+ x y))) @EV{} F
 (f 1 2) @EV{} 3
@end lisp



@lisp
 (defvar *one-array* (make-array 10 :element-type '(signed-byte 5)))
 (defvar *another-array* (make-array 10 :element-type '(signed-byte 8)))

 (defun frob (an-array)
   (declare (type (array (signed-byte 5) 1) an-array))
   (setf (aref an-array 1) 31)
   (setf (aref an-array 2) 127)
   (setf (aref an-array 3) (* 2 (aref an-array 3)))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (aref an-array 0))))

 (frob *one-array*)
 (frob *another-array*)
@end lisp


@medbreak{}

The above definition of @f{frob} is equivalent to:

@lisp
 (defun frob (an-array)
   (setf (the (signed-byte 5) (aref an-array 1)) 31)
   (setf (the (signed-byte 5) (aref an-array 2)) 127)
   (setf (the (signed-byte 5) (aref an-array 3))
         (* 2 (the (signed-byte 5) (aref an-array 3))))
   (let ((foo 0))
     (declare (type (signed-byte 5) foo))
     (setf foo (the (signed-byte 5) (aref an-array 0)))))
@end lisp


Given an implementation in which
@term{fixnums} are 29 bits but @code{fixnum} @term{arrays}
are upgraded to signed 32-bit @term{arrays},
the following
could be compiled with all @term{fixnum} arithmetic:

@lisp
 (defun bump-counters (counters)
   (declare (type (array fixnum *) bump-counters))
   (dotimes (i (length counters))
     (incf (aref counters i))))
@end lisp


@subsubheading See Also:

@ref{declare},
@ref{declaim},
@ref{proclaim}

@subsubheading Notes:

@f{(@param{typespec} @starparam{var})}
is an abbreviation for @f{(type @param{typespec} @starparam{var})}.

A @code{type} declaration for the arguments to a function does not
necessarily imply anything about the type of the result.  The following
function is not permitted to be compiled using @term{implementation-dependent}
@term{fixnum}-only arithmetic:

@lisp
 (defun f (x y) (declare (fixnum x y)) (+ x y))
@end lisp


To see why, consider @f{(f most-positive-fixnum 1)}.
Common Lisp defines that @f{F} must return a @term{bignum} here, rather
than signal an error or produce a mathematically incorrect result.
If you have special knowledge such ``@term{fixnum} overflow'' cases will
not come up, you can declare the result value to be in the @term{fixnum}
range, enabling some compilers to use more efficient arithmetic:

@lisp
 (defun f (x y)
   (declare (fixnum x y))
   (the fixnum (+ x y)))
@end lisp


Note, however, that in the three-argument case, because of the possibility
of an implicit intermediate value growing too large, the following will not
cause @term{implementation-dependent} @term{fixnum}-only arithmetic to be used:

@lisp
 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ x y z)))
@end lisp


To see why, consider @f{(f most-positive-fixnum 1 -1).}
Although the arguments and the result are all @term{fixnums}, an intermediate
value is not a @term{fixnum}.  If it is important that
@term{implementation-dependent} @term{fixnum}-only arithmetic be selected
in @term{implementations} that provide it,
consider writing something like this instead:

@lisp
 (defun f (x y)
   (declare (fixnum x y z))
   (the fixnum (+ (the fixnum (+ x y)) z)))
@end lisp



@node inline; notinline
@subsection inline, notinline (Declaration)
@syindex inline
@cindex inline
@syindex notinline
@cindex notinline
@anchor{inline}
@anchor{notinline}


@subsubheading Syntax:

@tt{(inline @starparam{function-name})}

@tt{(notinline @starparam{function-name})}

@subsubheading Arguments:

@param{function-name}---a @term{function name}.

@subsubheading Valid Context:

@term{declaration} or @term{proclamation}

@subsubheading Binding Types Affected:

@term{function}

@subsubheading Description:

@code{inline} specifies that
it is desirable for the compiler to produce inline calls
to the @term{functions} named by @param{function-names};
that is, the code for a specified @param{function-name}
should be integrated into the calling routine, appearing ``in line''
in place of a procedure call.
A compiler is free to ignore this declaration.
@code{inline} declarations never apply to variable @term{bindings}.

If one of the @term{functions} mentioned has a lexically apparent local definition
(as made by @code{flet} or @code{labels}), then the declaration
applies to that local definition and not to the global function definition.

While no @term{conforming implementation} is required to perform inline expansion
of user-defined functions, those @term{implementations} that do attempt
to recognize the following paradigm:

To define a @term{function} @f{f} that is not @code{inline} by default
but for which @f{(declare (inline f))} will make @param{f} be locally inlined,
the proper definition sequence is:

@lisp
 (declaim (inline f))
 (defun f ...)
 (declaim (notinline f))
@end lisp


The @code{inline} proclamation preceding the @code{defun} @term{form}
ensures that the @term{compiler} has the opportunity save the information
necessary for inline expansion, and the @code{notinline} proclamation
following the @code{defun} @term{form} prevents @f{f} from being expanded
inline everywhere.

@code{notinline} specifies that it is
undesirable to compile the @term{functions}
named by @param{function-names} in-line.
A compiler is not free to ignore this declaration;
calls to the specified functions must be implemented as out-of-line subroutine calls.

If one of the @term{functions}
mentioned has a lexically apparent local definition
(as made by @code{flet} or @code{labels}), then the declaration
applies to that local definition and not to the global function definition.

In the presence of a @term{compiler macro} definition for
@param{function-name}, a @code{notinline} declaration prevents that
@term{compiler macro} from being used.
An @code{inline} declaration may be used to encourage use of
@term{compiler macro} definitions.  @code{inline} and @code{notinline}
declarations otherwise have no effect when the lexically visible definition
of @param{function-name} is a @term{macro} definition.

@code{inline} and @code{notinline} declarations can be @term{free declarations} or
@term{bound declarations}.
@code{inline} and @code{notinline} declarations of functions that
appear before the body of a
@code{flet}
or  @code{labels}
@term{form} that defines that function are @term{bound declarations}.
Such declarations in other contexts are @term{free declarations}.

@subsubheading Examples:

@lisp
 ;; The globally defined function DISPATCH should be open-coded,
 ;; if the implementation supports inlining, unless a NOTINLINE
 ;; declaration overrides this effect.
 (declaim (inline dispatch))
 (defun dispatch (x) (funcall (get (car x) 'dispatch) x))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-1 () (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (defun top-level-2 ()
   (declare (notinline dispatch))
   (dispatch (read-command)))
 ;; Here is an example where inlining would be prohibited.
 (declaim (notinline dispatch))
 (defun top-level-3 () (dispatch (read-command)))
 ;; Here is an example where inlining would be encouraged.
 (defun top-level-4 ()
   (declare (inline dispatch))
   (dispatch (read-command)))
@end lisp


@subsubheading See Also:

@ref{declare},
@ref{declaim},
@ref{proclaim}


@node ftype
@subsection ftype (Declaration)
@syindex ftype
@cindex ftype


@subsubheading Syntax:

@f{(ftype @param{type} @starparam{function-name})}

@subsubheading Arguments:

@param{function-name}---a @term{function name}.

@param{type}---a @term{type specifier}.

@subsubheading Valid Context:

@term{declaration} or @term{proclamation}

@subsubheading Binding Types Affected:

@term{function}

@subsubheading Description:

Specifies that the @term{functions} named by @param{function-names} are of
the functional type @param{type}.
For example:

@lisp
 (declare (ftype (function (integer list) t) ith)
          (ftype (function (number) float) sine cosine))
@end lisp

If one of the @term{functions} mentioned has a lexically apparent local definition
(as made by @code{flet} or @code{labels}), then the declaration
applies to that local definition and not to the global function definition.
@code{ftype} declarations never apply to variable @term{bindings} (see @tt{type}).

The lexically apparent bindings of @param{function-names} must not be
@term{macro} definitions.  (This is because @code{ftype} declares the
functional definition of each @term{function name} to be of a particular
subtype of @code{function}, and @term{macros} do not denote
@term{functions}.)

@code{ftype}
declarations
can be @term{free declarations} or @term{bound declarations}.
@code{ftype} declarations of functions that appear before the body of a
@code{flet}
or @code{labels}
@term{form} that defines that function are @term{bound declarations}.
Such declarations in other contexts are @term{free declarations}.


@subsubheading See Also:

@ref{declare},
@ref{declaim},
@ref{proclaim}


@node declaration
@subsection declaration (Declaration)
@syindex declaration
@cindex declaration


@subsubheading Syntax:

@f{(declaration @starparam{name})}

@subsubheading Arguments:

@param{name}---a @term{symbol}.

@subsubheading Valid Context:

@term{proclamation} only

@subsubheading Description:

Advises the compiler that each @param{name} is a valid but potentially
non-standard declaration name.  The purpose of this is to tell one
compiler not to issue warnings for declarations meant for another
compiler or other program processor.

@subsubheading Examples:

@lisp
 (declaim (declaration author target-language target-machine))
 (declaim (target-language ada))
 (declaim (target-machine IBM-650))
 (defun strangep (x)
   (declare (author "Harry Tweeker"))
   (member x '(strange weird odd peculiar)))
@end lisp


@subsubheading See Also:

@ref{declaim},
@ref{proclaim}


@node optimize
@subsection optimize (Declaration)
@syindex optimize
@cindex optimize


@subsubheading Syntax:

@f{(optimize @star{@curly{@param{quality} | (@param{quality} @param{value})}})}
@cindex compilation-speed
@cindex debug
@cindex safety
@cindex space
@cindex speed

@subsubheading Arguments:

@param{quality}---an @term{optimize quality}.

@param{value}---one of the @term{integers} @f{0}, @f{1}, @f{2}, or @f{3}.

@subsubheading Valid Context:

@term{declaration} or @term{proclamation}

@subsubheading Description:

Advises the compiler that each @param{quality} should be given attention
according to the specified corresponding @param{value}.
Each @param{quality} must be a @term{symbol} naming an @term{optimize quality};
the names and meanings of the standard @param{optimize qualities} are shown in
@thenextfigure{}.


@float Figure,fig3.25
@cartouche
@multitable{@code{compilation-speed}}{both code size and run-time space}
@headitem Name @tab Meaning
@item @code{compilation-speed} @tab speed of the compilation process
@item @code{debug} @tab ease of debugging
@item @code{safety} @tab run-time error checking
@item @code{space} @tab both code size and run-time space
@item @code{speed} @tab speed of the object code
@end multitable
@end cartouche
@caption{Optimize qualities}
@end float


There may be other, @term{implementation-defined} @term{optimize qualities}.

A @param{value} @f{0} means that the corresponding @param{quality} is totally
unimportant, and @f{3} that the @param{quality} is extremely important;
@f{1} and @f{2} are intermediate values, with @f{1} the
neutral value.
@f{(@param{quality} 3)} can be abbreviated to @param{quality}.

Note that @term{code} which has the optimization @f{(safety 3)},
or just @code{safety},
is called @term{safe} @term{code}.

The consequences are unspecified if a @param{quality} appears more than once
with @term{different} @param{values}.

@subsubheading Examples:

@lisp
 (defun often-used-subroutine (x y)
   (declare (optimize (safety 2)))
   (error-check x y)
   (hairy-setup x)
   (do ((i 0 (+ i 1))
        (z x (cdr z)))
       ((null z))
     ;; This inner loop really needs to burn.
     (declare (optimize speed))
     (declare (fixnum i))
     ))
@end lisp


@subsubheading See Also:

@ref{declare},
@ref{declaim},
@ref{proclaim},
@ref{Declaration Scope}

@subsubheading Notes:

An @code{optimize} declaration never applies to either a @term{variable} or
a @term{function} @term{binding}.  An @code{optimize} declaration can only
be a @term{free declaration}.  For more information, see @ref{Declaration Scope}.


@node special
@subsection special (Declaration)
@syindex special
@cindex special


@subsubheading Syntax:

@f{(special @starparam{var})}

@subsubheading Arguments:

@param{var}---a @term{symbol}.

@subsubheading Valid Context:

@term{declaration} or @term{proclamation}

@subsubheading Binding Types Affected:

@term{variable}

@subsubheading Description:

Specifies that all of
the @param{vars} named are dynamic.
This specifier affects variable @term{bindings} and
affects references.
All variable @term{bindings} affected are made to be dynamic @term{bindings},
and affected variable references refer to the current dynamic
@term{binding}.
For example:

@lisp
 (defun hack (thing *mod*)    ;The binding of the parameter
   (declare (special *mod*))  ; *mod* is visible to hack1,
   (hack1 (car thing)))       ; but not that of thing.
 (defun hack1 (arg)
   (declare (special *mod*))  ;Declare references to *mod*
                              ;within hack1 to be special.
   (if (atom arg) *mod*
       (cons (hack1 (car arg)) (hack1 (cdr arg)))))
@end lisp


A @code{special} declaration does not affect inner @term{bindings}
of a @param{var}; the inner @term{bindings} implicitly shadow
a @code{special} declaration and must be explicitly re-declared to
be @code{special}.
@code{special} declarations never apply to function @term{bindings}.

@code{special} declarations can be either @term{bound declarations},
affecting both a binding and references, or @term{free declarations},
affecting only references, depending on whether the declaration is
attached to a variable binding.

When used in a @term{proclamation}, a @code{special}
@term{declaration specifier}
applies to all @term{bindings} as well as to all references of the
mentioned variables.  For example, after

@lisp
 (declaim (special x))
@end lisp


then in a function definition such as

@lisp
 (defun example (x) ...)
@end lisp


the parameter @f{x} is bound as a dynamic variable
rather than as a lexical variable.

@subsubheading Examples:

@lisp
(defun declare-eg (y)                 ;this y is special
 (declare (special y))
 (let ((y t))                         ;this y is lexical
      (list y
            (locally (declare (special y)) y)))) ;this y refers to the
                                                 ;special binding of y
@EV{} DECLARE-EG
 (declare-eg nil) @EV{} (T NIL)
@end lisp


@lisp
(setf (symbol-value 'x) 6)
(defun foo (x)                         ;a lexical binding of x
  (print x)
  (let ((x (1+ x)))                    ;a special binding of x
    (declare (special x))              ;and a lexical reference
    (bar))
  (1+ x))
(defun bar ()
  (print (locally (declare (special x))
           x)))
(foo 10)
@OUT{} 10
@OUT{} 11
@EV{} 11
@end lisp


@lisp
(setf (symbol-value 'x) 6)
(defun bar (x y)            ;[1] 1st occurrence of x
  (let ((old-x x)           ;[2] 2nd occurrence of x -- same as 1st occurrence
        (x y))              ;[3] 3rd occurrence of x
    (declare (special x))
    (list old-x x)))
(bar 'first 'second) @EV{} (FIRST SECOND)
@end lisp


@lisp
 (defun few (x &optional (y *foo*))
   (declare (special *foo*))
   ...)
@end lisp

The reference to @f{*foo*}
in the first line of this example is not @code{special}
even though there is a @code{special} declaration in the second line.

@lisp
 (declaim (special prosp)) @EV{} @term{implementation-dependent}
 (setq prosp 1 reg 1) @EV{} 1
 (let ((prosp 2) (reg 2))         ;the binding of prosp is special
    (set 'prosp 3) (set 'reg 3)   ;due to the preceding proclamation,
    (list prosp reg))             ;whereas the variable reg is lexical
@EV{} (3 2)
 (list prosp reg) @EV{} (1 3)

 (declaim (special x))          ;x is always special.
 (defun example (x y)
   (declare (special y))
   (let ((y 3) (x (* x 2)))
     (print (+ y (locally (declare (special y)) y)))
     (let ((y 4)) (declare (special y)) (foo x)))) @EV{} EXAMPLE
@end lisp

In the contorted code above, the outermost and innermost @term{bindings} of
@f{y} are dynamic,
but the middle
binding is lexical. The two arguments to @f{+} are different,
one being the value, which is @f{3}, of the lexical variable
@f{y}, and the other being the value of the dynamic variable named @f{y}
(a @term{binding}
of which happens, coincidentally, to lexically surround it at
an outer level).  All the @term{bindings}
of @f{x} and references to @f{x}
are dynamic, however, because of the proclamation that @f{x} is
always @code{special}.

@subsubheading See Also:

@ref{defparameter},
@ref{defvar}


@node locally
@subsection locally (Special Operator)
@syindex locally
@cindex locally



@subsubheading Syntax:

@DefspecWithValues{locally, @starparam{declaration} @starparam{form}, @starparam{result}}

@subsubheading Arguments and Values:

@param{Declaration}---a @t{declare} @term{expression}; @noeval{}.

@param{forms}---an @term{implicit progn}.

@param{results}---the @term{values} of the @param{forms}.

@subsubheading Description:

Sequentially evaluates a body of @param{forms}
in a @term{lexical environment} where the given @param{declarations} have effect.

@subsubheading Examples:

@lisp
 (defun sample-function (y)  ;this y is regarded as special
   (declare (special y))
   (let ((y t))              ;this y is regarded as lexical
     (list y
           (locally (declare (special y))
             ;; this next y is regarded as special
             y))))
@EV{} SAMPLE-FUNCTION
 (sample-function nil) @EV{} (T NIL)
 (setq x '(1 2 3) y '(4 . 5)) @EV{} (4 . 5)

;;; The following declarations are not notably useful in specific.
;;; They just offer a sample of valid declaration syntax using LOCALLY.
 (locally (declare (inline floor) (notinline car cdr))
          (declare (optimize space))
    (floor (car x) (cdr y))) @EV{} 0, 1
@end lisp


@lisp
;;; This example shows a definition of a function that has a particular set
;;; of OPTIMIZE settings made locally to that definition.
 (locally (declare (optimize (safety 3) (space 3) (speed 0)))
   (defun frob (w x y &optional (z (foo x y)))
     (mumble x y z w)))
@EV{} FROB

;;; This is like the previous example, except that the optimize settings
;;; remain in effect for subsequent definitions in the same compilation unit.
 (declaim (optimize (safety 3) (space 3) (speed 0)))
 (defun frob (w x y &optional (z (foo x y)))
   (mumble x y z w))
@EV{} FROB
@end lisp


@subsubheading See Also:

@ref{declare}

@subsubheading Notes:

The @code{special} declaration may be used with @code{locally}
to affect references to, rather than @term{bindings} of, @term{variables}.

If a @code{locally} @term{form} is a @term{top level form}, the body @param{forms}
are also processed as @term{top level forms}.  See @ref{File Compilation}.



@node the
@subsection the (Special Operator)
@syindex the
@cindex the


@subsubheading Syntax:

@DefspecWithValues{the, value-type form, @starparam{result}}

@subsubheading Arguments and Values:

@param{value-type}---a @term{type specifier}; @noeval{}.

@param{form}---a @term{form}; @eval{}.

@param{results}---the @term{values} resulting from the @term{evaluation} of @param{form}.
These @term{values} must conform to the @term{type} supplied by @param{value-type};
see below.

@subsubheading Description:

@code{the} specifies that the @term{values}[1a] returned by @param{form}
are of the @term{types} specified by @param{value-type}.
The consequences are undefined if any @param{result}
is not of the declared type.


It is permissible for @param{form} to @term{yield} a different number of @term{values}
than are specified by @param{value-type}, provided that the values
for which @param{types} are declared are indeed of those @term{types}.
Missing values are treated as @nil{}@spc{}for the purposes of checking their @term{types}.

Regardless of number of @term{values} declared by @param{value-type},
the number of @term{values} returned by @thespecform{the} is the same as
the number of @term{values} returned by @param{form}.

@subsubheading Examples:

@lisp
 (the symbol (car (list (gensym)))) @EV{} #:G9876
 (the fixnum (+ 5 7)) @EV{} 12
 (the (values) (truncate 3.2 2)) @EV{} 1, 1.2
 (the integer (truncate 3.2 2)) @EV{} 1, 1.2
 (the (values integer) (truncate 3.2 2)) @EV{} 1, 1.2
 (the (values integer float) (truncate 3.2 2))   @EV{} 1, 1.2
 (the (values integer float symbol) (truncate 3.2 2)) @EV{} 1, 1.2
 (the (values integer float symbol t null list)
      (truncate 3.2 2)) @EV{} 1, 1.2
 (let ((i 100))
    (declare (fixnum i))
    (the fixnum (1+ i))) @EV{} 101
 (let* ((x (list 'a 'b 'c))
        (y 5))
    (setf (the fixnum (car x)) y)
    x) @EV{} (5 B C)
@end lisp


@subsubheading Exceptional Situations:

The consequences are undefined if
the @term{values} @term{yielded} by the @param{form}
are not of the @term{type} specified by @param{value-type}.

@subsubheading See Also:

@ref{values (Type Specifier)}

@subsubheading Notes:

The @code{values} @term{type specifier} can be used to indicate the types
of @term{multiple values}:

@lisp
 (the (values integer integer) (floor x y))
 (the (values string t)
      (gethash the-key the-string-table))
@end lisp


@code{setf} can be used with @code{the} type declarations.
In this case the declaration is transferred to the form that
specifies  the new value.  The resulting @code{setf} @term{form}
is then analyzed.


@node special-operator-p
@subsection special-operator-p (Function)
@syindex special-operator-p
@cindex special-operator-p



@subsubheading Syntax:

@DefunWithValues{special-operator-p, symbol, generalized-boolean}

@subsubheading Arguments and Values:

@param{symbol}---a @term{symbol}.

@param{generalized-boolean}---a @term{generalized boolean}.

@subsubheading Description:

@Predicate{symbol, a @term{special operator}}

@subsubheading Examples:

@lisp
 (special-operator-p 'if) @EV{} @term{true}
 (special-operator-p 'car) @EV{} @term{false}
 (special-operator-p 'one) @EV{} @term{false}
@end lisp


@subsubheading Exceptional Situations:

Should signal @code{type-error} if its argument is not a @term{symbol}.

@subsubheading Notes:

Historically, this function was called @f{special-form-p}.  The name was
finally declared a misnomer and changed, since it returned true for
@term{special operators}, not @term{special forms}.



@node constantp
@subsection constantp (Function)
@syindex constantp
@cindex constantp



@subsubheading Syntax:

@DefunWithValues{constantp, form @opt{} environment, generalized-boolean}

@subsubheading Arguments and Values:

@param{form}---a @term{form}.

@param{environment}---an @term{environment} @term{object}.
@Default{@nil{}}

@param{generalized-boolean}---a @term{generalized boolean}.

@subsubheading Description:

Returns @term{true} if @param{form} can be determined
by the @term{implementation} to be a @term{constant form}
in the indicated @param{environment};
otherwise, it returns @term{false} indicating either
that the @term{form} is not a @term{constant form}
or that it cannot be determined whether or not @term{form} is a @term{constant form}.

The following kinds of @term{forms} are considered @term{constant forms}:

@itemize @bullet{}
@item
@term{Self-evaluating objects}
(such as @term{numbers},
@term{characters},
and the various kinds of @term{arrays})
are always considered @term{constant forms}
and must be recognized as such by @code{constantp}.

@item
@term{Constant variables}, such as @term{keywords},
symbols defined by @clisp{}@spc{}as constant (such as @nil{}, @code{t}, and @code{pi}),
and symbols declared as constant by the user in the indicated @param{environment}
using @code{defconstant}
are always considered @term{constant forms}
and must be recognized as such by @code{constantp}.

@item
@code{quote} @term{forms} are always considered @term{constant forms}
and must be recognized as such by @code{constantp}.

@item
An @term{implementation} is permitted, but not required, to detect
additional @term{constant forms}.  If it does, it is also permitted,
but not required, to make use of information in the @param{environment}.
Examples of @term{constant forms} for which @code{constantp} might
or might not return @term{true} are:
@f{(sqrt pi)},
@f{(+ 3 2)},
@f{(length '(a b c))},
and
@f{(let ((x 7)) (zerop x))}.
@end itemize


If an @term{implementation} chooses to make use of the @param{environment}
information, such actions as expanding @term{macros} or performing function
inlining are permitted to be used, but not required;
however, expanding @term{compiler macros} is not permitted.

@subsubheading Examples:

@lisp
 (constantp 1) @EV{} @term{true}
 (constantp 'temp) @EV{} @term{false}
 (constantp ''temp)) @EV{} @term{true}
 (defconstant this-is-a-constant 'never-changing) @EV{} THIS-IS-A-CONSTANT
 (constantp 'this-is-a-constant) @EV{} @term{true}
 (constantp "temp") @EV{} @term{true}
 (setq a 6) @EV{} 6
 (constantp a) @EV{} @term{true}
 (constantp '(sin pi)) @EV{} @term{implementation-dependent}
 (constantp '(car '(x))) @EV{} @term{implementation-dependent}
 (constantp '(eql x x)) @EV{} @term{implementation-dependent}
 (constantp '(typep x 'nil)) @EV{} @term{implementation-dependent}
 (constantp '(typep x 't)) @EV{} @term{implementation-dependent}
 (constantp '(values this-is-a-constant)) @EV{} @term{implementation-dependent}
 (constantp '(values 'x 'y)) @EV{} @term{implementation-dependent}
 (constantp '(let ((a '(a b c))) (+ (length a) 6))) @EV{} @term{implementation-dependent}
@end lisp


@subsubheading Affected By:

The state of the global environment (@eg{} which @term{symbols} have been
declared to be the @term{names} of @term{constant variables}).

@subsubheading See Also:

@ref{defconstant}
